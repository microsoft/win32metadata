//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-2005
//
//  File: oestore.idl
//
//  Contents: Windows Mail API
//
//  History:    11-Oct-1997         SteveBailey         Created
//
//--------------------------------------------------------------------------
cpp_quote("#ifndef MSOEAPI_H")
cpp_quote("#define MSOEAPI_H")

cpp_quote("#include <winapifamily.h>")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

import "ocidl.idl";
import "objidl.idl";
import "mimeole.idl";


//+-------------------------------------------------------------------------
// Interfaces
//--------------------------------------------------------------------------
interface IOutlookExpress;
interface IStoreNamespace;
interface IStoreFolder;

cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// GUID Definitions")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#pragma comment(lib,\"uuid.lib\")")
cpp_quote("")
cpp_quote("// {3338DF69-4660-11d1-8A8D-00C04FB951F3}")
cpp_quote("DEFINE_GUID(CLSID_OutlookExpress, 0x3338df69, 0x4660, 0x11d1, 0x8a, 0x8d, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);")
cpp_quote("")
cpp_quote("// {0006F01A-0000-0000-C000-0000000046}")
cpp_quote("DEFINE_GUID(CLSID_Envelope, 0x0006F01A, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);")
cpp_quote("")
cpp_quote("// {3338DF6A-4660-11d1-8A8D-00C04FB951F3}")
cpp_quote("DEFINE_GUID(IID_IOutlookExpress, 0x3338df6a, 0x4660, 0x11d1, 0x8a, 0x8d, 0x00, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);")
cpp_quote("")
cpp_quote("// {E70C92A9-4BFD-11d1-8A95-00C04FB951F3}")
cpp_quote("DEFINE_GUID(CLSID_StoreNamespace, 0xe70c92a9, 0x4bfd, 0x11d1, 0x8a, 0x95, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);")
cpp_quote("")
cpp_quote("// {E70C92AA-4BFD-11d1-8A95-00C04FB951F3}")
cpp_quote("DEFINE_GUID(IID_IStoreNamespace, 0xe70c92aa, 0x4bfd, 0x11d1, 0x8a, 0x95, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);")
cpp_quote("")
cpp_quote("// {E70C92AC-4BFD-11d1-8A95-00C04FB951F3}")
cpp_quote("DEFINE_GUID(IID_IStoreFolder, 0xe70c92ac, 0x4bfd, 0x11d1, 0x8a, 0x95, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// Errors Definition Macros")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#ifndef FACILITY_INTERNET")
cpp_quote("#define FACILITY_INTERNET 12")
cpp_quote("#endif")
cpp_quote("#ifndef HR_E")
cpp_quote("#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)")
cpp_quote("#endif")
cpp_quote("#ifndef HR_S")
cpp_quote("#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)")
cpp_quote("#endif")
cpp_quote("#ifndef HR_CODE")
cpp_quote("#define HR_CODE(hr) (INT)(hr & 0xffff)")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// MSOEAPI Failure Return Values")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#define MSOEAPI_E_FILE_NOT_FOUND             HR_E(0xCF65)")
cpp_quote("#define MSOEAPI_E_STORE_INITIALIZE           HR_E(0xCF66)")
cpp_quote("#define MSOEAPI_E_INVALID_STRUCT_SIZE        HR_E(0xCF67)")
cpp_quote("#define MSOEAPI_E_CANT_LOAD_MSOERT           HR_E(0xCF68)")
cpp_quote("#define MSOEAPI_E_CANT_LOAD_INETCOMM         HR_E(0xCF69)")
cpp_quote("#define MSOEAPI_E_CANT_LOAD_MSOEACCT         HR_E(0xCF70)")
cpp_quote("#define MSOEAPI_E_CANT_MSOERT_BADVER         HR_E(0xCF71)")
cpp_quote("#define MSOEAPI_E_CANT_INETCOMM_BADVER       HR_E(0xCF72)")
cpp_quote("#define MSOEAPI_E_CANT_MSOEACCT_BADVER       HR_E(0xCF73)")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// String Definition Macros")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#ifdef __cplusplus")
cpp_quote("#define EXTERN_C extern \"C\"")
cpp_quote("#else")
cpp_quote("#define EXTERN_C extern")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("#ifndef STRCONSTA")
cpp_quote("#ifdef DEFINE_STRCONST")
cpp_quote("#define STRCONSTA(x,y)    EXTERN_C const char x[] = y")
cpp_quote("#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y")
cpp_quote("#else")
cpp_quote("#define STRCONSTA(x,y)    EXTERN_C const char x[]")
cpp_quote("#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]")
cpp_quote("#endif STRCONSTA")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// Strings")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("STRCONSTA(STR_MSOEAPI_INSTANCECLASS,      \"OutlookExpressHiddenWindow\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_IPSERVERCLASS,      \"OutlookExpressInProccessServer\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_INSTANCEMUTEX,      \"Local\\\\OutlookExpress_InstanceMutex_101897\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_DLLNAME,            \"MSOE.DLL\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_START,              \"CoStartOutlookExpress\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_SHUTDOWN,           \"CoShutdownOutlookExpress\");")
cpp_quote("STRCONSTA(STR_MSOEAPI_CREATE,             \"CoCreateOutlookExpress\");")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// Function Typedefs")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("typedef HRESULT (APIENTRY *PFNSTART)(DWORD dwFlags, LPCSTR pszCmdLine, INT nCmdShow);")
cpp_quote("typedef HRESULT (APIENTRY *PFNSHUTDOWN)(DWORD dwReserved);")
cpp_quote("typedef HRESULT (APIENTRY *PFNCREATE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);")
cpp_quote("")

//+-------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
const DWORD MSOEAPI_ACDM_CMDLINE    = 1;
const DWORD MSOEAPI_ACDM_NOTIFY     = 2;
const DWORD MSOEAPI_ACDM_ODBNOTIFY  = 3;
const DWORD MSOEAPI_ACDM_STGNOTIFY  = 4;

//+-------------------------------------------------------------------------
// DECLARE_HANDLE Macro
//--------------------------------------------------------------------------
#ifndef DECLARE_HANDLE
    #define DECLARE_HANDLE(name) \
        struct name##__ { DWORD unused; }; \
        typedef struct name##__ _far* name
#endif // DECLARE_HANDLE

//;begin_internal
//--------------------------------------------------------------------------
// FOLDERIDs and MESSAGEIDs in Windows Mail are 64 bits, and do not employ
// handle semantics. Currently, this doesn't affect folders accessible through 
// these interfaces (local folders only -- special, or user-created, folders).
// The children of FOLDERID_LOCAL_STORE are still saved into the primary
// Folders table, so compatibility is retained.
//
// If in future the IStoreNamespace/IStoreFolder implementations are extended
// to allow access to NNTP and IMAP folders, we will need new interface
// definitions to access the altered store.
//--------------------------------------------------------------------------
//;end_internal

//;begin_internal
//--------------------------------------------------------------------------
// Work Around:  The declaration of DECLARE_HANDLE is not remoting friendly.
// It declares the handle as a pointer to a structure, when it's actually used
// like a dword.  RPC will try to marshal what the handle points to, which
// won't work, since the handle isn't really being used as a pointer.  This
// declaration of DECLARE_HANDLE_TRANSMITTED_AS_INT uses the
// [transmit_as(INT)] attribute to indicate to rpc that the handle will be
// transmitted as an INT.  For every handle that is declared, we have to provide
// functions to convert to and from the transmitted type, and functions to free
// memory allocated for the transmitted type and the user type (4 functions
// total). DECLARE_HANDLE_TRANSMITTED_AS_INT is for porting legacy interfaces
// that use DECLARE_HANDLE only.  Do not use DECLARE_HANDLE or
// DECLARE_HANDLE_TRANSMITTED_AS_INT in new code!  Instead use the
// [context_handle] attribute to create handles in idl files.
//--------------------------------------------------------------------------
//;end_internal
#ifndef DECLARE_HANDLE_TRANSMITTED_AS_INT
#define DECLARE_HANDLE_TRANSMITTED_AS_INT(name) \
    struct name##__ { DWORD unused; }; \
    typedef [transmit_as(INT)] struct name##__ _far* name
#endif // DECLARE_HANDLE_TRANSMITTED_AS_INT


//+-------------------------------------------------------------------------
// HENUMSTORE
//--------------------------------------------------------------------------
DECLARE_HANDLE_TRANSMITTED_AS_INT(HENUMSTORE);
typedef HENUMSTORE *LPHENUMSTORE;

//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents: IOutlookExpress
//
//  History:    11-Oct-1997         SteveBailey         Created
//
//--------------------------------------------------------------------------
cpp_quote("#ifndef __LPOUTLOOKEXPRESS_DEFINED")
cpp_quote("#define __LPOUTLOOKEXPRESS_DEFINED")
[
    object,
    uuid(3338DF6A-4660-11d1-8A8D-00C04FB951F3),
    pointer_default(unique)
]
interface IOutlookExpress : IUnknown
{
    typedef IOutlookExpress *LPOUTLOOKEXPRESS;

    //+---------------------------------------------------------------------
    // Flags used in IOutlookExpress::Start
    //----------------------------------------------------------------------
    cpp_quote("#define MSOEAPI_START_SHOWSPLASH         0x00000001")
    cpp_quote("#define MSOEAPI_START_MESSAGEPUMP        0x00000002")
    cpp_quote("#define MSOEAPI_START_ALLOWCOMPACTION    0x00000004")
    cpp_quote("#define MSOEAPI_START_INSTANCEMUTEX      0x00000008")
    cpp_quote("#define MSOEAPI_START_SHOWERRORS         0x00000010")
    cpp_quote("#define MSOEAPI_START_APPWINDOW          0x00000020")
    cpp_quote("#define MSOEAPI_START_DEFAULTIDENTITY    0x00000040")
    cpp_quote("#define MSOEAPI_START_ALREADY_RUNNING    0x00000080")
    cpp_quote("#define MSOEAPI_START_STOREVALIDNODELETE 0x00000100")
    cpp_quote("#define MSOEAPI_START_NOSTORE            0x00000200")

    //+---------------------------------------------------------------------
    // MSOEAPI_START_APPLICATION
    //----------------------------------------------------------------------
    cpp_quote("#define MSOEAPI_START_APPLICATION \\")
    cpp_quote("    (MSOEAPI_START_SHOWSPLASH      | \\")
    cpp_quote("     MSOEAPI_START_SHOWERRORS      | \\")
    cpp_quote("     MSOEAPI_START_MESSAGEPUMP     | \\")
    cpp_quote("     MSOEAPI_START_ALLOWCOMPACTION | \\")
    cpp_quote("     MSOEAPI_START_INSTANCEMUTEX   | \\")
    cpp_quote("     MSOEAPI_START_APPWINDOW)")

    //+---------------------------------------------------------------------
    // MSOEAPI_START_COMOBJECT
    //----------------------------------------------------------------------
    cpp_quote("#define MSOEAPI_START_COMOBJECT \\")
    cpp_quote("     MSOEAPI_START_SHOWERRORS")

    //+---------------------------------------------------------------------
    // Methods
    //----------------------------------------------------------------------
    HRESULT Start(
            [in]        DWORD                       dwFlags,
            [in]        LPCSTR                      pszCmdLine,
            [in]        INT                         nCmdShow);
}

cpp_quote("#endif // __LPOUTLOOKEXPRESS_DEFINED")


//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents: IStoreNamespace
//
//  History:    11-Oct-1997         SteveBailey         Created
//
//--------------------------------------------------------------------------
cpp_quote("#ifndef __LPSTORENAMESPACE_DEFINED")
cpp_quote("#define __LPSTORENAMESPACE_DEFINED")
[
    object,
    uuid(E70C92AA-4BFD-11d1-8A95-00C04FB951F3),
    pointer_default(unique)
]
interface IStoreNamespace : IUnknown
{
    typedef IStoreNamespace *LPSTORENAMESPACE;

    //+---------------------------------------------------------------------
    // STOREFOLDERID - folderIds are persistable
    //----------------------------------------------------------------------
    typedef DWORD STOREFOLDERID;
    typedef STOREFOLDERID *LPSTOREFOLDERID;

    //+---------------------------------------------------------------------
    // Some Special FOLDER Values
    //----------------------------------------------------------------------
    const DWORD FOLDERID_ROOT     = 0;
    const DWORD FOLDERID_INVALID  = 0xffffffff;

    //+---------------------------------------------------------------------
    // MESSAGEID
    //----------------------------------------------------------------------
    typedef DWORD MESSAGEID;
    typedef MESSAGEID *LPMESSAGEID;

    //+---------------------------------------------------------------------
    // Some Special MESSAGEID values
    //----------------------------------------------------------------------
    const DWORD MESSAGEID_INVALID = 0xffffffff;
    const DWORD MESSAGEID_FIRST   = 0xffffffff;

    //+---------------------------------------------------------------------
    // Consts
    //----------------------------------------------------------------------
    const DWORD CCHMAX_FOLDER_NAME = 256;

    //+---------------------------------------------------------------------
    // Notification Messages
    //----------------------------------------------------------------------
    cpp_quote("#define WM_FOLDERNOTIFY      (WM_USER + 1600) // IStoreNamespace Notification - lparam=LPFOLDERNOTIFYEX, client must call CoTaskMemFree(lParam)")
    cpp_quote("#define WM_NEWMSGS           (WM_USER + 1650) // IStoreFolder Notification: wParam=MESSAGEID, lParam=Reserved")
    cpp_quote("#define WM_DELETEMSGS        (WM_USER + 1651) // IStoreFolder Notification: wParam=prgdwMsgId, lParam=cMsgs")
    cpp_quote("#define WM_DELETEFOLDER      (WM_USER + 1652) // IStoreFolder Notification: wParam=STOREFOLDERID or HFOLDER")

    // If wParam is equal to 0xffffffff then that means that all messages in the folder
    // were either marked as read (WM_MARKEDASREAD) or unread (WM_MARKEDASUNREAD)
    cpp_quote("#define WM_MARKEDASREAD      (WM_USER + 1653) // IStoreFolder Notification: wParamprgdwMsgId, lParam=cMsgs")
    cpp_quote("#define WM_MARKEDASUNREAD    (WM_USER + 1654) // IStoreFolder Notification: wParamprgdwMsgId, lParam=cMsgs")

    //+---------------------------------------------------------------------
    // FOLDERNOTIFYTYPE
    //----------------------------------------------------------------------
    typedef enum tagFOLDERNOTIFYTYPE {
        NEW_FOLDER = 1,
        DELETE_FOLDER,
        RENAME_FOLDER,
        MOVE_FOLDER,
        UNREAD_CHANGE,
        IMAPFLAG_CHANGE,
        UPDATEFLAG_CHANGE,
        FOLDER_PROPS_CHANGED
    } FOLDERNOTIFYTYPE;

    //+---------------------------------------------------------------------
    // FOLDERNOTIFYEX
    //----------------------------------------------------------------------
    typedef struct tagFOLDERNOTIFYEX {
        FOLDERNOTIFYTYPE type;
        STOREFOLDERID    idFolderOld;                // not used for CREATEFOLDER and DELETEFOLDER
        STOREFOLDERID    idFolderNew;
    } FOLDERNOTIFYEX, *LPFOLDERNOTIFYEX;

    //+---------------------------------------------------------------------
    // MESSAGEIDLIST - A list of message ids (DWORDs)
    //----------------------------------------------------------------------
    typedef struct tagMESSAGEIDLIST {
        DWORD               cbSize;                 // Sizeof this structure
        DWORD               cMsgs;                  // Number of elements in prghMessage
        [size_is(cMsgs)]    LPMESSAGEID prgdwMsgId; // Array of handles to messages
    } MESSAGEIDLIST, *LPMESSAGEIDLIST;

    //+---------------------------------------------------------------------
    // SPECIALFOLDER - How to identify a special folder
    //----------------------------------------------------------------------
    typedef enum tagSPECIALFOLDER {
        FOLDER_NOTSPECIAL = -1,                     // Not a special folder
        FOLDER_INBOX,                               // Default receive folder
        FOLDER_OUTBOX,                              // Default send folder
        FOLDER_SENT,                                // Things that have been sent
        FOLDER_DELETED,                             // Things that have been deleted
        FOLDER_DRAFT,                               // Things that are in progress
        FOLDER_MAX                                  // Don't use
    } SPECIALFOLDER;

    //----------------------------------------------------------------------
    // FOLDERPROPS - Properties of a folder
    //----------------------------------------------------------------------
//;begin_internal
    // Work Around:  The FOLDERPROPS stores the size of itself as one of
    // its fields.  This does not work well with remoting across the
    // 32/64-bit boundary.  The size on size of the structure on the 32-bit
    // side will be different from the size on the 64-bit side.  However,
    // cbSize will not change to indicate this difference.  If the caller
    // or callee then check to make sure that cbSize==sizeof(FOLDERPROPS),
    // then they will assume there is a version problem.  To solve this,
    // a new type is being created (which is just a DWORD) that is labeled
    // [transmit_as(DWORD)].  This allows us to change the value of cbSize
    // when it comes off the wire at the destination.
//;end_internal
    typedef [transmit_as(DWORD)] DWORD FOLDERPROPSSIZE;
//;begin_internal
    // Work Around:  MIDL emits a 16 bit value for the SPECIALFOLDER enum
    // and RPC verifies that it is high bit clean.  This isn't the case for
    // FOLDER_NOTSPECIAL == -1 == 0xffff
//;end_internal
    typedef [transmit_as(DWORD)] SPECIALFOLDER SPECIALFOLDER_XMIT;
    typedef struct tagFOLDERPROPS {
        FOLDERPROPSSIZE      cbSize;                     // Size of this structure
        STOREFOLDERID        dwFolderId;                 // Handle of this folder
        INT                  cSubFolders;                // Number of sub-folders
        SPECIALFOLDER_XMIT   sfType;                     // Special folder type
        DWORD                cUnread;                    // Number of un-read messages
        DWORD                cMessage;                   // Total # of messages
        CHAR                 szName[CCHMAX_FOLDER_NAME]; // The Folder Name
    } FOLDERPROPS, *LPFOLDERPROPS;

    //+---------------------------------------------------------------------
    // Methods
    //----------------------------------------------------------------------
    cpp_quote("#define NAMESPACE_INITIALIZE_CURRENTIDENTITY 0x00000001")
    HRESULT Initialize(                                                     // Initialize the object
            [in,unique] HWND                        hwndOwner,              // Window owner for things like compaction dialog
            [in]        DWORD                       dwReserved);            // Reserved for future use

    HRESULT GetDirectory(                                                   // Get the location of the store (filepath)
            [in,out,size_is(cchMaxPath)] LPSTR      pszPath,                // Buffer to put path of store into
            [in]        DWORD                       cchMaxPath);            // in: byte count size of pszPath, out: char count size of pszPath

    HRESULT OpenSpecialFolder(
            [in]        SPECIALFOLDER_XMIT          sfType,                 // Special folder type
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [out]       IStoreFolder                **ppFolder);            // Pointer to an IStoreFolder

    HRESULT OpenFolder(
            [in]        STOREFOLDERID               dwFolderId,             // Folder to open
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [out]       IStoreFolder                **ppFolder);            // Pointer to an IStoreFolder

    HRESULT CreateFolder(
            [in]        STOREFOLDERID               dwParentId,             // Parent of the new folder, can use FOLDERID_ROOT
            [in]        LPCSTR                      pszName,                // Name of new folder, must be less than MAX_FOLDER_NAME
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [out]       LPSTOREFOLDERID             pdwFolderId);           // Handle to the new folder

    HRESULT RenameFolder(
            [in]        STOREFOLDERID               dwFolderId,             // Folder to rename
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        LPCSTR                      pszNewName);            // New folder name, must be less than MAX_FOLDER_NAME

    HRESULT MoveFolder(
            [in]        STOREFOLDERID               dwFolderId,             // Folder to move
            [in]        STOREFOLDERID               dwParentId,             // FolderId of the new Parent
            [in]        DWORD                       dwReserved);            // Reserved for future use

    HRESULT DeleteFolder(
            [in]        STOREFOLDERID               dwFolderId,             // Folder to delete
            [in]        DWORD                       dwReserved);            // Reserved for future use

    [local]
    HRESULT GetFolderProps(
            [in]        STOREFOLDERID               dwFolderId,             // FolderId to get info for
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in,out]    LPFOLDERPROPS               pProps);                // in: set cbSize, out: Holds folder information

//;begin_internal
    // Work Around: GetFolderProps is not remoting friendly.  Set GetMessageProps below for details. 
//;end_internal
    [call_as(GetFolderProps)]
    HRESULT GetFolderPropsRemote(
            [in]        STOREFOLDERID               dwFolderId,             // FolderId to get info for
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in,out]    LPFOLDERPROPS               pProps);                // in: set cbSize, out: Holds folder information

    cpp_quote("// CLocalStore::CopyMoveMessages flags - dwFlags == 0 is copy")
    cpp_quote("#define CMF_MOVE                     0x0001                  // msgs deleted from src fldr after copy")
    cpp_quote("#define CMF_DELETE                   0x0002                  // same as CMF_MOVE but uses delete string for status")
    HRESULT CopyMoveMessages(
            [in]        IStoreFolder                *pSource,               // Source store folder
            [in]        IStoreFolder                *pDest,                 // Destination Store Folder
            [in]        LPMESSAGEIDLIST             pMsgIdList,             // List of MESSAGEIDs to move/copy
            [in]        DWORD                       dwFlags,                // CMF_xxx Flags
            [in]        DWORD                       dwFlagsRemove,          // MSG_xxx Flags to remove from copied/moved messages
            [in]        IProgressNotify             *pProgress);            // Store progress callback (client implements)

    [local]
    HRESULT RegisterNotification(
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HWND                        hwnd);                  // Handle to window to send notifications

    [call_as(RegisterNotification)]
    HRESULT RegisterNotificationRemote(
            [in]        DWORD                       dwReserved,             // Reserved for future use            
            [in]        IUnknown                   *pUnkObj);               // Store event dispatcher callback (implemented in the client stub)         

    HRESULT UnregisterNotification(
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HWND                        hwnd);                  // Handle to window to un-register for notifications

    HRESULT CompactAll(                                                     // Compacts all folders in the store
            [in]        DWORD                       dwReserved);            // Reserved for future use

    HRESULT GetFirstSubFolder(                                              // Enumerate sub folders
            [in]        STOREFOLDERID               dwFolderId,             // Pass FOLDERID_ROOT to enum root folders
            [in,out]    LPFOLDERPROPS               pProps,                 // If function succeeds, contents are valid
            [out]       LPHENUMSTORE                phEnum);                // Use in call to GetNextSubFolder, and then GetSubFolderClose

    HRESULT GetNextSubFolder(                                               // Get the next subfolder, returns S_FALSE if no more folders
            [in]        HENUMSTORE                  hEnum,                  // Handle received from GetFirstSubFolder
            [in,out]    LPFOLDERPROPS               pProps);                // If function returns S_OK, contains folder properties

    HRESULT GetSubFolderClose(                                              // Closes the handle associated with a folder enumeration
            [in]        HENUMSTORE                  hEnum);                 // Handle received from GetFirstSubFolder
}

cpp_quote("#endif // __LPSTORENAMESPACE_DEFINED")

//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents: IStoreFolder
//
//  History:    11-Oct-1997         SteveBailey         Created
//
//--------------------------------------------------------------------------
cpp_quote("#ifndef __LPSTOREFOLDER_DEFINED")
cpp_quote("#define __LPSTOREFOLDER_DEFINED")
[
    object,
    uuid(E70C92AC-4BFD-11d1-8A95-00C04FB951F3),
    pointer_default(unique)
]
interface IStoreFolder : IUnknown
{
    typedef IStoreFolder *LPSTOREFOLDER;

    //+---------------------------------------------------------------------
    // Message State Flags used in MESSAGEINFO::dwState
    //----------------------------------------------------------------------
    cpp_quote("#define MSG_DELETED                  0x0001  // The message has been deleted, compaction will remove it")
    cpp_quote("#define MSG_UNREAD                   0x0002  // The message is marked as un-read")
    cpp_quote("#define MSG_SUBMITTED                0x0004  // For messages waiting to be sent: OUTBOX ONLY")
    cpp_quote("#define MSG_UNSENT                   0x0008  // For msgs-in-progress saved to a folder")
    cpp_quote("#define MSG_RECEIVED                 0x0010  // For messages that came from a server")
    cpp_quote("#define MSG_NEWSMSG                  0x0020  // For news messages")
    cpp_quote("#define MSG_NOSECUI                  0x0040  // For messages where the user wants to die")
    cpp_quote("#define MSG_VOICEMAIL                0x0080  // The message has the X-Voicemail header set...")
    cpp_quote("#define MSG_REPLIED                  0x0100  // The message has been replied to")
    cpp_quote("#define MSG_FORWARDED                0x0200  // The message has been forwarded to")
    cpp_quote("#define MSG_RCPTSENT                 0x0400  // S/MIME Receipt has been sent")
    cpp_quote("#define MSG_FLAGGED                  0x0800  // The message is currently flaged")
    cpp_quote("#define MSG_LAST                     0x0200  // ** Keep this updated!! **")
    cpp_quote("#define MSG_EXTERNAL_FLAGS           0x00fe")
    cpp_quote("#define MSG_FLAGS                    0x000f")

    //----------------------------------------------------------------------
    // MESSAGEPROPS
    //----------------------------------------------------------------------
//;begin_internal
    // Work Around:  The MESSAGEPROPS stores the size of itself as one of
    // its fields.  See the comment above FOLDERPROPS for a description of
    // the problem and solution.
//;end_internal
    typedef [transmit_as(DWORD)] DWORD MESSAGEPROPSSIZE;
    typedef struct tagMESSAGEPROPS {
        MESSAGEPROPSSIZE cbSize;                    // Size of this structure
        DWORD           dwReserved;                 // Reserved don't use
        MESSAGEID       dwMessageId;                // Handle to this message
        DWORD           dwLanguage;                 // Codepage of this message
        DWORD           dwState;                    // MSG_xxx Flags

        // Things you don't get when MSGPROPS_FAST
        DWORD           cbMessage;                  // Size of the message
        IMSGPRIORITY    priority;                   // Message Priority
        FILETIME        ftReceived;                 // When the message was received
        FILETIME        ftSent;                     // When the message was sent
        LPSTR           pszSubject;                 // The subject of the message
        LPSTR           pszDisplayTo;               // The display to line of the message
        LPSTR           pszDisplayFrom;             // The display from line of the message
        LPSTR           pszNormalSubject;           // The normalized subject of the message
        DWORD           dwFlags;                    // IMF_xxx Flags defined in mimeole.idl
        IStream        *pStmOffsetTable;            // Use with IMimeMessage::LoadOffsetTable
    } MESSAGEPROPS, *LPMESSAGEPROPS;

    //+---------------------------------------------------------------------
    // HBATCHLOCK
    //----------------------------------------------------------------------
    DECLARE_HANDLE_TRANSMITTED_AS_INT(HBATCHLOCK);
    typedef HBATCHLOCK *LPHBATCHLOCK;

    //+---------------------------------------------------------------------
    // Method
    //----------------------------------------------------------------------
    HRESULT GetFolderProps(                                                 // Get folder info for this folder
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in,out]    LPFOLDERPROPS               pProps);                // in: set cbSize, out: contains folder information

    cpp_quote("#define MSGPROPS_FAST                0x00000001              // See MESSAGEPROPS structure, improved performance")
    [local]
    HRESULT GetMessageProps(
            [in]        MESSAGEID                   dwMessageId,            // Message Identifier
            [in]        DWORD                       dwFlags,                // GETMSGINFO_xxx Flags
            [in,out]    LPMESSAGEPROPS              pProps);                // Message Info - set cbSize before calling

//;begin_internal
    // Work Around: GetMessageProps and LPMESSAGEPROPS are not remoting
    // friendly.  The problem is that pProps is declared as [in,out], which
    // implies that all of pProps will be initialized by the caller
    // when a call is made. However, the only field of pProps that we know
    // will be initialized on the way in is cbSize.  The rest of the
    // structure will contain random memory.  When RPC tries to marshal the
    // structure on the way in, it will try to dereference pointers that are
    // uninitialized. To work around this without breaking IStoreNamespace
    // clients, GetMessagePropsRemote was created with the
    // [call_as(GetMessageProps)] attribute.  This means that when a client
    // has a remote reference to an IStoreNamespace and they make a call to
    // GetMessageProps, that call will be remoted using
    // GetMessagePropsRemote.  We must provide 2 functions to support this.
    // The first function, which acts as a proxy, takes the parameters that
    // are passed in to GetMessageProps, and converts them to a form that
    // GetMessagePropsRemote and RPC can use.  The other function, which acts
    // as a stub, converts the parameters from the remotable form back
    // into the form that is understood by GetMessageProps, then makes the
    // call to GetMessageProps on the server.  In our case, the proxy
    // function zero-initializes the fields of pProps, and the stub function
    // only passes the remoted pProps on to GetMessageProps.
//;end_internal
    [call_as(GetMessageProps)]
    HRESULT GetMessagePropsRemote(
            [in]        MESSAGEID                   dwMessageId,            // Message Identifier
            [in]        DWORD                       dwFlags,                // GETMSGINFO_xxx Flags
            [in,out]    LPMESSAGEPROPS              pProps);                // Message Info - set cbSize before calling

    HRESULT FreeMessageProps(                                               // Handles the case where pMsgInfo->dwMask has MIP_BYREF
            [in,out]    LPMESSAGEPROPS              pProps);                // Pointer to MESSAGEINFO structure to free

    HRESULT DeleteMessages(
            [in]        LPMESSAGEIDLIST             pMsgIdList,             // List of HMESSAGEs
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        IProgressNotify           *pProgress);            // Progress information

    HRESULT SetLanguage(
            [in]        DWORD                       dwLanguage,             // MLANG Codepage ID of message
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        LPMESSAGEIDLIST             pMsgIdList);            // List of HMESSAGEs to apply new language to

    HRESULT MarkMessagesAsRead(
            [in]        BOOL                        fRead,                  // Mark as Read or Unread
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        LPMESSAGEIDLIST             pMsgIdList);            // List of HMESSAGEs to mark as (un)read

    [local]
    HRESULT SetFlags(                                                       // Modify the flags of a message
            [in]        LPMESSAGEIDLIST             pMsgIdList,             // Array of messages to modify flags for
            [in]        DWORD                       dwState,                // MSG_xxx Flags to set on pMsgIdList
            [in]        DWORD                       dwStatemask,            // ~dwStateMask == MSG_xxx Flags to mask out
            [in,out,unique] LPDWORD                 prgdwNewFlags);         // optional caller allocated Array of new message state flags that match pMsgIdList array

    [call_as(SetFlags)]
    HRESULT SetFlagsRemote(                                                 // Modify the flags of a message
            [in]        LPMESSAGEIDLIST             pMsgIdList,             // Array of messages to modify flags for
            [in]        DWORD                       dwState,                // MSG_xxx Flags to set on pMsgIdList
            [in]        DWORD                       dwStatemask,            // MSG_xxx Flags to allow set on messages
            [in]        DWORD                       cMsgs,                  // if (prgdwNewFlags != NULL) size of caller array passed for new flags
            [in,out,unique,size_is(cMsgs)]  LPDWORD prgdwNewFlags);         // Array of new message state flags that match pMsgIdList array

    [local]
    HRESULT OpenMessage(                                                    // Open a message (get a stream or a message object)
            [in]        MESSAGEID                   dwMessageId,            // Handle to the message to open
            [in]        REFIID                      riid,                   // IID_IStream or IID_IMimeMessage stream is readonly
            [out,iid_is(riid)] LPVOID               *ppvObject);            // The object, you must ->Release it

//;begin_internal
    // Workaround: IMimeMessageW is not remoteable, so we'll
    // simply take an IStream and re-create the mime message on the other end
//;end_internal
    [call_as(OpenMessage)]
    HRESULT OpenMessageRemote(                                              // Open a message (get a stream or a message object)
            [in]        MESSAGEID                   dwMessageId,            // Handle to the message to open
            [in]        REFIID                      riid,                   // IID_IStream or IID_IMimeMessage stream is readonly
            [out,iid_is(riid)] LPVOID               *ppvObject);            // The object, you must ->Release it

    [local]
    HRESULT SaveMessage(                                                    // Add a new entry to a folder.
            [in]        REFIID                      riid,                   // IID_IStream or IID_IMimeMessage
            [in,iid_is(riid)] LPVOID                pvObject,               // Pointer to a stream or mime message
            [in]        DWORD                       dwMsgFlags,             // MSG_xxx Flags
            [out]       LPMESSAGEID                 pdwMessageId);          // Handle to the new message

    [call_as(SaveMessage)]
    HRESULT SaveMessageRemote(                                              // Add a new entry to a folder.
            [in]        REFIID                      riid,                   // IID_IStream or IID_IMimeMessage
            [in,iid_is(riid)] LPVOID                pvObject,               // Pointer to a stream or mime message
            [in]        DWORD                       dwMsgFlags,             // MSG_xxx Flags
            [out]       LPMESSAGEID                 pdwMessageId);          // Handle to the new message

    HRESULT BatchLock(                                                      // Lock to prepare for a batch operation
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [out]       LPHBATCHLOCK                phBatchLock);           // Handle to newly created lock

    HRESULT BatchFlush(                                                     // Flush the current batch operation
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HBATCHLOCK                  hBatchLock);            // Folder lock obtained from BatchLock

    HRESULT BatchUnlock(                                                    // Unlocks a batched operation
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HBATCHLOCK                  hBatchLock);            // Handle to lock obtained from BatchLock

    HRESULT CreateStream(                                                   // Create a new stream in a folder
            [in]        HBATCHLOCK                  hBatchLock,             // Handle to a folder lock, optional if doing a one-of
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [out]       IStream                     **ppStream,             // Pointer to new stream can be used for read/write
            [out]       LPMESSAGEID                 pdwMessageId);          // Handle to the new message

    cpp_quote("#define COMMITSTREAM_REVERT          0x00000001              // Don't add this stream/message to the folder")
    HRESULT CommitStream(                                                   // Commit/Revert a stream created with CreateStream
            [in]        HBATCHLOCK                  hBatchLock,             // Folder lock obtained from BatchLock
            [in]        DWORD                       dwFlags,                // COMMITSTREAM_xxx Flags
            [in]        DWORD                       dwMsgFlags,             // MSG_xxx Flags
            [in]        IStream                     *pStream,               // Stream obtained from CreateStream
            [in]        MESSAGEID                   dwMessageId,            // dwMessageId obtained from CreateStream
            [in]        IMimeMessage                *pMessage);             // Message to commit, if not passed in, pStream will be pared.

    [local]
    HRESULT RegisterNotification(
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HWND                        hwnd);                  // Handle to window to send notifications

    [call_as(RegisterNotification)]
    HRESULT RegisterNotificationRemote(
            [in]        DWORD                       dwReserved,             // Reserved for future use            
            [in]        IUnknown                   *pUnkObj);               // Store event dispatcher callback (implemented in the client stub)

    HRESULT UnregisterNotification(
            [in]        DWORD                       dwReserved,             // Reserved for future use
            [in]        HWND                        hwnd);                  // Handle to window to un-register for notifications

    HRESULT Compact(                                                        // Compacts this folder
            [in]        DWORD                       dwReserved);            // Reserved for future use

    [local]
    HRESULT GetFirstMessage(                                                // Get the first message in a folder
            [in]        DWORD                       dwFlags,                // MSGPROPS_xxx Flags
            [in]        DWORD                       dwMsgFlags,             // MSG_xxx Flags to enumerate on, pass 0 for none
            [in]        MESSAGEID                   dwMsgIdFirst,           // MessageId to start enumerating at, Use MESSAGEID_FIRST
            [in,out]    LPMESSAGEPROPS              pProps,                 // When function returns S_OK, contains message properties
            [out]       LPHENUMSTORE                phEnum);                // Upon successful return, contains handle to enumeration

//;begin_internal
    // Work Around: GetFirstMessage and LPMESSAGEPROPS are not remoting
    // friendly.  See the comment above GetMessagePropsRemote for a
    // description of the problem and solution.
//;end_internal
    [call_as(GetFirstMessage)]
    HRESULT GetFirstMessageRemote(                                          // Get the first message in a folder
            [in]        DWORD                       dwFlags,                // MSGPROPS_xxx Flags
            [in]        DWORD                       dwMsgFlags,             // MSG_xxx Flags to enumerate on, pass 0 for none
            [in]        MESSAGEID                   dwMsgIdFirst,           // MessageId to start enumerating at, Use MESSAGEID_FIRST
            [in,out]    LPMESSAGEPROPS              pProps,                 // When function returns S_OK, contains message properties
            [out]       LPHENUMSTORE                phEnum);                // Upon successful return, contains handle to enumeration

    // GetNextMessage() return values:
    //     S_FALSE is returned if no more items are found.
    [local]
    HRESULT GetNextMessage(                                                 // Get the next message in the enumeration
            [in]        HENUMSTORE                  hEnum,                  // Handle to the enumeration received in GetFirstMessage
            [in]        DWORD                       dwFlags,                // MSGPROPS_xxx Flags
            [in,out]    LPMESSAGEPROPS              pProps);                // When function returns S_OK, contains message properties

//;begin_internal
    // Work Around: GetNextMessage and LPMESSAGEPROPS are not remoting
    // friendly.  See the comment above GetMessagePropsRemote for a
    // description of the problem and solution.
//;end_internal
    [call_as(GetNextMessage)]
    HRESULT GetNextMessageRemote(                                           // Get the next message in the enumeration
            [in]        HENUMSTORE                  hEnum,                  // Handle to the enumeration received in GetFirstMessage
            [in]        DWORD                       dwFlags,                // MSGPROPS_xxx Flags
            [in,out]    LPMESSAGEPROPS              pProps);                // When function returns S_OK, contains message properties

    HRESULT GetMessageClose(
            [in]        HENUMSTORE                  hEnum);                 // Handle to the enumeration received in GetFirstMessage
}

cpp_quote("#endif // __LPSTOREFOLDER_DEFINED")

cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// Outlook Express Exported C API Functions")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#ifdef __cplusplus")
cpp_quote("extern \"C\" {")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// API Name Decoration")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("#if !defined(_MSOEAPI_)")
cpp_quote("#define MSOEAPI DECLSPEC_IMPORT HRESULT WINAPI")
cpp_quote("#define MSOEAPI_(_type_) DECLSPEC_IMPORT _type_ WINAPI")
cpp_quote("#else")
cpp_quote("#define MSOEAPI HRESULT WINAPI")
cpp_quote("#define MSOEAPI_(_type_) _type_ WINAPI")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("// Prototypes")
cpp_quote("//--------------------------------------------------------------------------")
cpp_quote("MSOEAPI CoStartOutlookExpress(")
cpp_quote("             /* IN */        DWORD               dwFlags,")
cpp_quote("             /* IN */        LPCSTR              pszCmdLine,")
cpp_quote("             /* IN */        INT                 nCmdShow);")
cpp_quote("")
cpp_quote("MSOEAPI CoCreateOutlookExpress(")
cpp_quote("             /* IN */        IUnknown            *pUnkOuter,")
cpp_quote("             /* OUT */       IUnknown            **ppUnknown);")
cpp_quote("")
cpp_quote("#ifdef __cplusplus")
cpp_quote("}")
cpp_quote("#endif")

//
// Windows Mail interfaces
//
cpp_quote("#if (_WIN32_OE >= 0x0700)")

    [
        object,
        uuid(DECAED7F-2DA8-4074-B62A-DB6D8C82C385),
        pointer_default(unique)
    ]
    interface IStoreNamespace2 : IStoreNamespace
    {
        typedef IStoreNamespace2 *LPSTORENAMESPACE2;

        //+---------------------------------------------------------------------
        // Methods
        //----------------------------------------------------------------------
        HRESULT GetMessageID(                                                   // Get the Message ID from a path
                [in]        LPCWSTR                     pszPath,                // Path being queried
                [out]       LPSTOREFOLDERID             pdwFolderId,            // Folder ID of the path, if it was found in the database
                [out]       LPMESSAGEID                 pdwMessageId);          // Message ID of the path, if it was found in the database

        HRESULT GetParentId(                                                    // Get folder's parent folder id
                [in]        STOREFOLDERID               dwFolderId,             // child folder id
                [out]       LPSTOREFOLDERID             pdwParentId);           // parent folder id

        HRESULT GetDirectoryW(                                                  // Get the location of the store (filepath)
                [in,out,size_is(cchMaxPath)] LPWSTR     pwszPath,               // Buffer to put path of store into
                [in]        DWORD                       cchMaxPath);            // in: byte count size of pszPath, out: char count size of pszPath

        HRESULT CreateFolderW(
                [in]        STOREFOLDERID               dwParentId,             // Parent of the new folder, can use FOLDERID_ROOT
                [in]        LPCWSTR                     pwszName,               // Name of new folder, must be less than MAX_FOLDER_NAME
                [in]        DWORD                       dwReserved,             // Reserved for future use
                [out]       LPSTOREFOLDERID             pdwFolderId);           // Handle to the new folder

        HRESULT RenameFolderW(
                [in]        STOREFOLDERID               dwFolderId,             // Folder to rename
                [in]        DWORD                       dwReserved,             // Reserved for future use
                [in]        LPCWSTR                     pwszNewName);           // New folder name, must be less than MAX_FOLDER_NAME
    }


    [
        object,
        uuid(5642F741-46B7-4A22-B496-F064E4C5F302),
        pointer_default(unique)
    ]
    interface IStoreFolder2 : IStoreFolder
    {
        typedef IStoreFolder2 *LPSTOREFOLDER2;
        //+---------------------------------------------------------------------
        // Methods
        //----------------------------------------------------------------------
        HRESULT GetMessagePath(                                                 // Get folder info for this folder
                [in]        MESSAGEID                   dwMessageId,            // Message ID being queried for
                [in,out,size_is(cchBufferSize)] LPWSTR  pszPath,                // Buffer in which to put the path of the message, if it exists
                [in]        DWORD                       cchBufferSize);         // Size of szBuffer
    }    

cpp_quote("#endif // (_WIN32_OE >= 0x0700)")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

cpp_quote("#endif // MSOEAPI_H")

