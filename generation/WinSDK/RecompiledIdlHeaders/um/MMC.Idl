//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmc.idl
//
//--------------------------------------------------------------------------

// mmc.idl : IDL source for mmc.exe
//

cpp_quote("#ifndef MMC_VER")
cpp_quote("#define MMC_VER 0x0210")
cpp_quote("#endif")

cpp_quote("#include <winapifamily.h>")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

import "basetsd.h";
import "oaidl.idl";


///////////////////////////////////////////////////////////////////////////////
/// Interfaces implemented by the Common Console's Node Manager

interface IConsole;
interface IHeaderCtrl;
interface IToolbar;
interface IImageList;
interface IResultData;
interface IConsoleNameSpace;
interface IPropertySheetProvider;
interface IPropertySheetCallback;
interface IContextMenuProvider;
interface IContextMenuCallback;
interface IControlbar;
interface IConsoleVerb;
interface IMenuButton;

cpp_quote("#if (MMC_VER >= 0x0110)")
interface IConsole2;
interface IHeaderCtrl2;
interface IConsoleNameSpace2;
interface IDisplayHelp;
interface IStringTable;
cpp_quote("#endif // MMC_VER >= 0x0110")

cpp_quote("#if (MMC_VER >= 0x0120)")
interface IColumnData;
cpp_quote("#endif // MMC_VER >= 0x0120")

cpp_quote("#if (MMC_VER >= 0x0200)")
interface IConsole3;
interface IConsolePower;
interface INodeProperties;
interface IResultData2;
cpp_quote("#endif // MMC_VER >= 0x0200")

///////////////////////////////////////////////////////////////////////////////
/// Interfaces implemented by the Snap-in server

interface IComponent;
interface IComponentData;
interface IExtendPropertySheet;
interface IExtendContextMenu;
interface IExtendControlbar;
interface IResultDataCompare;
interface ISnapinAbout;
interface IResultOwnerData;
interface ISnapinHelp;

cpp_quote("#if (MMC_VER >= 0x0110)")
interface IEnumTASK;
interface IExtendPropertySheet2;
interface ISnapinHelp2;
interface IExtendTaskPad;
interface IRequiredExtensions;
cpp_quote("#endif // MMC_VER >= 0x0110")

cpp_quote("#if (MMC_VER >= 0x0120)")
interface IResultDataCompareEx;
cpp_quote("#endif // MMC_VER >= 0x0120")

cpp_quote("#if (MMC_VER >= 0x0200)")
interface IComponent2;
interface IComponentData2;
interface IExtendView;
interface IViewExtensionCallback;
interface IConsolePowerSink;
interface IConsole3;
interface INodeProperties;
interface IResultData2;
cpp_quote("#endif // MMC_VER >= 0x0200")


///////////////////////////////////////////////////////////////////////////////
/// Type definitions

typedef IConsole*                   LPCONSOLE;
typedef IHeaderCtrl*                LPHEADERCTRL;
typedef IToolbar*                   LPTOOLBAR;
typedef IImageList*                 LPIMAGELIST;
typedef IResultData*                LPRESULTDATA;
typedef IConsoleNameSpace*          LPCONSOLENAMESPACE;
typedef IPropertySheetProvider*     LPPROPERTYSHEETPROVIDER;
typedef IPropertySheetCallback*     LPPROPERTYSHEETCALLBACK;
typedef IContextMenuProvider*       LPCONTEXTMENUPROVIDER;
typedef IContextMenuCallback*       LPCONTEXTMENUCALLBACK;
typedef IControlbar*                LPCONTROLBAR;
typedef IConsoleVerb*               LPCONSOLEVERB;
typedef IMenuButton*                LPMENUBUTTON;

cpp_quote("#if (MMC_VER >= 0x0110)")
typedef IConsole2*                  LPCONSOLE2;
typedef IHeaderCtrl2*               LPHEADERCTRL2;
typedef IConsoleNameSpace2*         LPCONSOLENAMESPACE2;
typedef IDisplayHelp*               LPDISPLAYHELP;
typedef IStringTable*               LPSTRINGTABLE;
cpp_quote("#endif // MMC_VER >= 0x0110")

cpp_quote("#if (MMC_VER >= 0x0120)")
typedef IColumnData*                LPCOLUMNDATA;
typedef IResultDataCompareEx*       LPRESULTDATACOMPAREEX;
cpp_quote("#endif // MMC_VER >= 0x0120")

typedef IComponent*                 LPCOMPONENT;
typedef IComponentData*             LPCOMPONENTDATA;
typedef IExtendPropertySheet*       LPEXTENDPROPERTYSHEET;
typedef IExtendContextMenu*         LPEXTENDCONTEXTMENU;
typedef IExtendControlbar*          LPEXTENDCONTROLBAR;
typedef IResultDataCompare*         LPRESULTDATACOMPARE;
typedef IResultOwnerData*           LPRESULTOWNERDATA;
typedef ISnapinAbout*               LPSNAPABOUT;
typedef ISnapinAbout*               LPSNAPINABOUT;
typedef ISnapinHelp*                LPSNAPHELP;
typedef ISnapinHelp*                LPSNAPINHELP;

cpp_quote("#if (MMC_VER >= 0x0110)")
typedef IEnumTASK*                  LPENUMTASK;
typedef IExtendPropertySheet2*      LPEXTENDPROPERTYSHEET2;
typedef ISnapinHelp2*               LPSNAPINHELP2;
typedef IExtendTaskPad*             LPEXTENDTASKPAD;
typedef IRequiredExtensions*        LPREQUIREDEXTENSIONS;
cpp_quote("#endif // MMC_VER >= 0x0110")


cpp_quote("#if (MMC_VER >= 0x0200)")
typedef IComponent2*                LPCOMPONENT2;
typedef IComponentData2*            LPCOMPONENTDATA2;
typedef IExtendView*                LPEXTENDVIEW;
typedef IViewExtensionCallback*     LPVIEWEXTENSIONCALLBACK;
typedef IConsolePower*              LPCONSOLEPOWER;
typedef IConsolePowerSink*          LPCONSOLEPOWERSINK;
typedef IConsole3*                  LPCONSOLE3;
typedef INodeProperties*            LPNODEPROPERTIES;
typedef IResultData2*               LPRESULTDATA2;
cpp_quote("#endif // MMC_VER >= 0x0200")


// typedefs for external types
typedef     BSTR*             PBSTR;

///////////////////////////////////////////////////////////////////////////////
// Published Common Console ListView constants

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVSICF_NOINVALIDATEALL  0x00000001
#define LVSICF_NOSCROLL         0x00000002

const long  MMCLV_AUTO = -1;
const long  MMCLV_NOPARAM = -2;
const long  MMCLV_NOICON = -1;

// If you add a view style please update the VIEW_TYPE in ndmgr.idl
const long  MMCLV_VIEWSTYLE_ICON = LVS_ICON;
const long  MMCLV_VIEWSTYLE_SMALLICON = LVS_SMALLICON;
const long  MMCLV_VIEWSTYLE_LIST = LVS_LIST;
const long  MMCLV_VIEWSTYLE_REPORT = LVS_REPORT;
const long  MMCLV_VIEWSTYLE_FILTERED = 0x0004;

const void* MMCLV_NOPTR = 0x0;
const long  MMCLV_UPDATE_NOINVALIDATEALL = LVSICF_NOINVALIDATEALL;
const long  MMCLV_UPDATE_NOSCROLL = LVSICF_NOSCROLL;

static LPOLESTR MMC_CALLBACK = (LPOLESTR)(-1);
cpp_quote("#if (MMC_VER >= 0x0120)")
cpp_quote("#define MMC_IMAGECALLBACK (-1)")
cpp_quote("#define MMC_TEXTCALLBACK  MMC_CALLBACK")
cpp_quote("#endif // MMC_VER >= 0x0120")

///////////////////////////////////////////////////////////////////////////////
// ResultData and Scope Data item structures.

typedef LONG_PTR     HSCOPEITEM;
typedef long        COMPONENTID;
typedef LONG_PTR     HRESULTITEM;

const DWORD RDI_STR     = 0x0002;
const DWORD RDI_IMAGE   = 0x0004;
const DWORD RDI_STATE   = 0x0008;
const DWORD RDI_PARAM   = 0x0010;
const DWORD RDI_INDEX   = 0x0020;
const DWORD RDI_INDENT  = 0x0040;

/*
 * Some view styles should be made available only to clients
 * that build with a certain MMC_VER level.  Ideally, we'd just put the
 * cpp_quote tests around the value definitions in the enumeration.
 * This doesn't work with MIDL, however, so we need to work around it.
 */
cpp_quote("typedef enum _MMC_RESULT_VIEW_STYLE      ")
cpp_quote("{                                        ")
cpp_quote("    MMC_SINGLESEL           = 0x0001,    ")
cpp_quote("    MMC_SHOWSELALWAYS       = 0x0002,    ")
cpp_quote("    MMC_NOSORTHEADER        = 0x0004,    ")
cpp_quote("#if (MMC_VER >= 0x0120)                  ")
cpp_quote("    MMC_ENSUREFOCUSVISIBLE  = 0x0008     ")
cpp_quote("#endif // MMC_VER >= 0x0120              ")
cpp_quote("} MMC_RESULT_VIEW_STYLE;                 ")

cpp_quote("#if 0")
typedef enum _MMC_RESULT_VIEW_STYLE
{
    _MMC_VIEW_STYLE__dummy_
} MMC_RESULT_VIEW_STYLE;
cpp_quote("#endif")


// List view with single select
const long MMC_VIEW_OPTIONS_NONE                          = 0x00000000;

// NO List view. Only custom views.
const long MMC_VIEW_OPTIONS_NOLISTVIEWS                   = 0x00000001;

// List view with multi select.
const long MMC_VIEW_OPTIONS_MULTISELECT                   = 0x00000002;

//List view with user owned data
const long MMC_VIEW_OPTIONS_OWNERDATALIST                 = 0x00000004;

//List view with filtering allowed
const long MMC_VIEW_OPTIONS_FILTERED                      = 0x00000008;

// Create new control (don't use cached)
const long MMC_VIEW_OPTIONS_CREATENEW                     = 0x00000010;

cpp_quote("#if (MMC_VER >= 0x0110)")
// Use font linking on result items (for multi-language support)
const long MMC_VIEW_OPTIONS_USEFONTLINKING                = 0x00000020;
cpp_quote("#endif // MMC_VER >= 0x0110")

cpp_quote("#if (MMC_VER >= 0x0120)")
// don't include scope items in the result list view
const long MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST = 0x00000040;
const long MMC_VIEW_OPTIONS_LEXICAL_SORT                  = 0x00000080;
cpp_quote("#endif // MMC_VER >= 0x0120")

// Property sheet options
const DWORD MMC_PSO_NOAPPLYNOW              = 0x00000001;
const DWORD MMC_PSO_HASHELP                 = 0x00000002;
const DWORD MMC_PSO_NEWWIZARDTYPE           = 0x00000004;
const DWORD MMC_PSO_NO_PROPTITLE            = 0x00000008;



// Type of controls that can be attached to the IControlbar
typedef enum  _MMC_CONTROL_TYPE
{
    TOOLBAR,
    MENUBUTTON,
    COMBOBOXBAR
} MMC_CONTROL_TYPE;


///////////////////////////////////////////////////////////////////////////////
// Console commands - These should be reviewed
//
/*
 * We need to make sure that some console commands are available
 * only to clients that build with a certain MMC_VER level.  Ideally, we'd just
 * put the cpp_quote tests around the value definitions in the enumeration.
 * This doesn't work with MIDL, however, so we need to work around it.
 */
cpp_quote("typedef enum _MMC_CONSOLE_VERB                               ")
cpp_quote("{                                                            ")
cpp_quote("    MMC_VERB_NONE            = 0x0000,                       ")
cpp_quote("    MMC_VERB_OPEN            = 0x8000,                       ")
cpp_quote("    MMC_VERB_COPY            = 0x8001,                       ")
cpp_quote("    MMC_VERB_PASTE           = 0x8002,                       ")
cpp_quote("    MMC_VERB_DELETE          = 0x8003,                       ")
cpp_quote("    MMC_VERB_PROPERTIES      = 0x8004,                       ")
cpp_quote("    MMC_VERB_RENAME          = 0x8005,                       ")
cpp_quote("    MMC_VERB_REFRESH         = 0x8006,                       ")
cpp_quote("    MMC_VERB_PRINT           = 0x8007,                       ")
cpp_quote("#if (MMC_VER >= 0x0110)                                      ")
cpp_quote("    MMC_VERB_CUT             = 0x8008,  // Used only to explicitly disable/hide")
cpp_quote("                                        // the cut verb, when copy & paste are enabled.")
cpp_quote("                                                             ")
cpp_quote("    // must be last                                          ")
cpp_quote("    MMC_VERB_MAX,                                            ")
cpp_quote("    MMC_VERB_FIRST           = MMC_VERB_OPEN,                ")
cpp_quote("    MMC_VERB_LAST            = MMC_VERB_MAX - 1              ")
cpp_quote("#endif // MMC_VER >= 0x0110                                  ")
cpp_quote("} MMC_CONSOLE_VERB;                                          ")

cpp_quote("#if 0")
typedef enum _MMC_CONSOLE_VERB
{
    MMC_VERB__dummy_
} MMC_CONSOLE_VERB;
cpp_quote("#endif")

// Structure to create buttons on the toolbar
cpp_quote("#include <pshpack8.h>")
typedef struct _MMCButton
{
    int      nBitmap;       // Offset into the bitmap list
    int      idCommand;     // Command ID return when the button is clicked
    BYTE     fsState;       // TBSTYLE_ENABLED ..etc
    BYTE     fsType;        // TBSTYLE_BUTTON || TBSTYLE_SEP
    LPOLESTR     lpButtonText;  // Text value for the Button
    LPOLESTR     lpTooltipText; // Text value for the tooltip

} MMCBUTTON;
cpp_quote("#include <poppack.h>")

typedef MMCBUTTON* LPMMCBUTTON;

typedef enum _MMC_BUTTON_STATE
{
    ENABLED         = 0x01,
    CHECKED         = 0x02,
    HIDDEN          = 0x04,
    INDETERMINATE   = 0x08,
    BUTTONPRESSED   = 0x10,

} MMC_BUTTON_STATE;

typedef struct _RESULTDATAITEM
{
    DWORD       mask;
    BOOL        bScopeItem;
    HRESULTITEM itemID;
    int         nIndex;
    int         nCol;
    LPOLESTR    str;
    int         nImage;
    UINT        nState;
    LPARAM      lParam;
    int         iIndent;
} RESULTDATAITEM;

typedef RESULTDATAITEM* LPRESULTDATAITEM;

// Find result item options
const DWORD RFI_PARTIAL = 0x0001;
const DWORD RFI_WRAP    = 0x0002;

typedef struct _RESULTFINDINFO
{
    LPOLESTR    psz;
    int         nStart;
    DWORD       dwOptions;
}
 RESULTFINDINFO;
typedef RESULTFINDINFO* LPRESULTFINDINFO;

//
// Sort Result Items options
//
const DWORD RSI_DESCENDING = 0x0001;
const DWORD RSI_NOSORTICON = 0x0002;

const DWORD SDI_STR         = 0x00002;
const DWORD SDI_IMAGE       = 0x00004;
const DWORD SDI_OPENIMAGE   = 0x00008;
const DWORD SDI_STATE       = 0x00010;
const DWORD SDI_PARAM       = 0x00020;
const DWORD SDI_CHILDREN    = 0x00040;

// The top 4 bit of the mask determines the relative position of this item,
// relative to the SCOPEDATAITEM::relativeID. By default it is the parent.

// For SDI_PARENT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the parent.
// As you can see by the SDI_PARENT value it is a no-op. Since by default
// SCOPEDATAITEM::relativeID is treated as the parents ID.
const DWORD SDI_PARENT      = 0x00000000;

// For SDI_PREVIOUS, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the previous sibling
const DWORD SDI_PREVIOUS    = 0x10000000;

// For SDI_NEXT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the next sibling.
const DWORD SDI_NEXT        = 0x20000000;

// For SDI_PARENT, bit 27 determines whether the item is to be inserted as the
// first child. By default this item will inserted as the last child.
const DWORD SDI_FIRST       = 0x08000000;


typedef struct _SCOPEDATAITEM
{
    DWORD       mask;
    LPOLESTR    displayname;
    int         nImage;
    int         nOpenImage;
    UINT        nState;
    int         cChildren;
    LPARAM      lParam;
    HSCOPEITEM  relativeID;
    HSCOPEITEM  ID;
} SCOPEDATAITEM;

typedef SCOPEDATAITEM* LPSCOPEDATAITEM;

typedef enum _MMC_SCOPE_ITEM_STATE
{
    MMC_SCOPE_ITEM_STATE_NORMAL = 0x0001,        // Not bold. To set or get.
    MMC_SCOPE_ITEM_STATE_BOLD = 0x0002,          // To set or get.
    MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = 0x0003,  // Only to get.

} MMC_SCOPE_ITEM_STATE;


typedef struct _CONTEXTMENUITEM
{
    LPWSTR      strName;
    LPWSTR      strStatusBarText;
    LONG        lCommandID;
    LONG        lInsertionPointID;
    LONG        fFlags;
    LONG        fSpecialFlags;
} CONTEXTMENUITEM;

typedef CONTEXTMENUITEM* LPCONTEXTMENUITEM;

//
// Console defined menu command IDs
//   The console reserves the negative numbers for predefined menu command
//   IDs which it sends to a snapin's IExtendContextMenu::Command method
//
typedef enum _MMC_MENU_COMMAND_IDS
{
    MMCC_STANDARD_VIEW_SELECT = -1
} MMC_MENU_COMMAND_IDS;



//IMenuButton data structure

typedef struct _MENUBUTTONDATA
{
    int      idCommand;
    int      x;
    int      y;
} MENUBUTTONDATA;

typedef MENUBUTTONDATA* LPMENUBUTTONDATA;


typedef LONG_PTR MMC_COOKIE;

//  For multi select the cookie passed to the snapins will be
//  MMC_MULTI_SELECT_COOKIE. The data object that will be returned
//  should provide the CCF_OBJECT_TYPES_IN_MULTI_SELECT clipboard
//  format.
const MMC_COOKIE MMC_MULTI_SELECT_COOKIE = -2;

// Special cookie value for requesting window properties data object
const MMC_COOKIE MMC_WINDOW_COOKIE = -3;

cpp_quote("#if (MMC_VER >= 0x0110)")
const MMC_COOKIE SPECIAL_COOKIE_MIN = -10;
const MMC_COOKIE SPECIAL_COOKIE_MAX = -1;


// Published filter constants
#define HDFT_ISSTRING       0x0000
#define HDFT_ISNUMBER       0x0001
#define HDFT_HASNOVALUE     0x8000

typedef enum _MMC_FILTER_TYPE
{
    MMC_STRING_FILTER = HDFT_ISSTRING,
    MMC_INT_FILTER    = HDFT_ISNUMBER,
    MMC_FILTER_NOVALUE= HDFT_HASNOVALUE
} MMC_FILTER_TYPE;


typedef struct _MMC_FILTERDATA
{
    LPOLESTR   pszText;         // text filter value
    INT        cchTextMax;      // max size of filter text
    LONG       lValue;          // numeric filter value
} MMC_FILTERDATA;


typedef enum _MMC_FILTER_CHANGE_CODE
{
    MFCC_DISABLE      = 0,
    MFCC_ENABLE       = 1,
    MFCC_VALUE_CHANGE = 2
} MMC_FILTER_CHANGE_CODE;

typedef struct _MMC_RESTORE_VIEW
{   // data from call to GetResultViewType
    DWORD dwSize;       // sizeof of this struct for versioning
    MMC_COOKIE cookie;  // user's cookie
    LPOLESTR pViewType; // URL or OCX or NULL
    long lViewOptions;  // MMC_VIEW_OPTIONS_*
} MMC_RESTORE_VIEW;

typedef struct _MMC_EXPANDSYNC_STRUCT
{
    BOOL        bHandled;       // did snap-in handle the notification?
    BOOL        bExpanding;     // TRUE=expanding, FALSE=contracting
    HSCOPEITEM  hItem;          // item that needs to be expanded
} MMC_EXPANDSYNC_STRUCT;
cpp_quote("#endif // MMC_VER >= 0x0110")


cpp_quote("#if (MMC_VER >= 0x0120)")
typedef struct _MMC_VISIBLE_COLUMNS
{
    INT  nVisibleColumns;       // number of items (visible columns) in the array.
    INT  rgVisibleCols[1];         // indices of visible columns.
} MMC_VISIBLE_COLUMNS;
cpp_quote("#endif // MMC_VER >= 0x0120")

/*
NOTIFICATIONS
=============

Notify(dataobject, event, arg, param);
    For all the MMC_NOTIFY_TYPE events,
    dataobject
        For single select:
            dataobject for cookie, can be NULL when dataobject is not required
        For multi select:
            Console supplied data object. Supports only one format (CCF_MULTI_SELECT_SNAPIN),
            which can be used to accquire an IUnknow to the primary snapin.
    event = one of the MMCN_NOTIFY_TYPEs
    arg and param depend on type, see below.

MMCN_ACTIVATE
    Is sent when a window is being activated or deactivated.
    arg = TRUE if window is activated, false otherwise.
    param = Not used.
    return = Not used.

MMCN_ADD_IMAGES
    Sent to IComponent to add images for the result pane. The primary snapin
        should add images for both folders and leaf items. Extension snapins
        should add only folder images.
    arg = ptr to result panes IImageList.
    param = HSCOPEITEM of selected/deselected item
    return = Not used.

MMCN_BTN_CLICK
    This message is sent when a user clicks on a button.
    arg   = When sent to ExtendControlbar it is the data object of currently selected,
            when sent to IComponent/IComponentData it is 0.
    param = CmdID of the button equal to a value of the MMC_COMMANDS enum type.
    return = Not used.

MMCN_CLICK
    Not used.

MMCN_DBLCLICK
    arg, param =  not used.
    return = S_FALSE to do the default action, if the default action is one of the standard verbs.

MMCN_EXPAND
    arg = TRUE => expand, FALSE => contract
    param = parents HSCOPEITEM.

MMCN_MINIMIZED
    Is sent when a window is being minimized or maximized.
    arg = TRUE if minimized, false otherwise.

MMCN_PROPERTY_CHANGE
    lpDataObject = NULL
    lParam = user object

MMCN_REMOVE_CHILDREN
    Informs the snapin to delete all the cookies it has added below.
    arg = HSCOPEITEM of the node whose children needs to be deleted.
    param = unused.
    return = unused.

MMCN_RENAME
    This notification is sent when an item needs to be renamed.
    arg = Not used.
    param = LPOLESTR for containing new name
    return = S_OK to allow rename and S_FALSE to disallow rename.

MMCN_SELECT
    If sent to IComponent::Notify:
        arg:
            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);
                bScope:     TRUE if an item the scope pane is selected,
                            FALSE if an item in the result pane is selected.
                bSelect:    TRUE if the item is selected,
                            FALSE if it is de-selected.
        param:
            Ignored.

    If sent to IExtendControlbar::ControlbarNotify:
        arg:
            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);
                bScope:     TRUE if an item the scope pane is selected,
                            FALSE if an item in the result pane is selected.
                bSelect:    TRUE if the item is selected,
                            FALSE if it is de-selected.
        param:
            LPDATAOBJECT pDataobject = (LPDATAOBJECT)param;
            pDataobject data object of item getting selected/de-selected.


MMCN_SHOW
    arg = TRUE if selecting, FALSE if deselecting
    param = HSCOPEITEM of selected/deselected item

MMCN_VIEW_CHANGE
    This message is sent to update all views of a change.
    arg = TRUE if Scope Item, FALSE if Result Item
    param = ptr to DataObject selected

MMCN_MENU_BTNCLICK
    This message is sent when a user clicks on a button.
    arg   = Data object of currently selected.
    param = Structure (LPMENUBUTTONDATA).

MMCN_SNAPINHELP
    This message is sent when the user requests help about the snapin.
    dataObject = NULL
    arg = 0
    param = 0

MMCN_CONTEXTHELP
    This message is sent when the user requests help about a selected item
    arg = 0
    param = 0

MMCN_DESELECT_ALL
    This message is sent when all items of an owner-data result pane
    are deselected.
    dataObject = NULL
    arg = 0
    param = 0

MMCN_COLUMN_CLICK
    This message is sent when the user clicks on a result listview column header.
    dataObject = NULL
    arg = Column number
    param = Sort option flags (RSI_xxx)
    return = not used.

MMCN_DELETE:
    Sent to inform the snapin that the item needs to be deleted. As a result of
    the user hitting the 'Delete' key or delete button.
    dataobject: dataobject of the selected item(s) provided by the snap-in.
    arg, param: unused.

MMCN_CUTORMOVE:
    dataobject: NULL.
    arg: pointer to a dataobject. See multi-selection below.
    param: unused.

MMCN_CANPASTE_OUTOFPROC
    dataobject: unused.
    arg:        unused
    param:      BOOL *, snapin sets to TRUE iff it handles dataobjects from another MMC process.
    Return:     S_OK if the dataobject can be handled, S_FALSE otherwise.

MMCN_QUERY_PASTE:
    dataobject: dataobject of the selected item provided by the snap-in.
    arg: dataobject of the item(s) provided by the source snap-in that needs to be pasted.
    param: flags (IsCopy the default action).
    Return S_OK if the data can be pasted, S_FALSE otherwise.

MMCN_PASTE:
    dataobject & arg: are same as for MMCN_QUERY_PASTE.
    param:
        NULL for move (as opposed to cut).
        For single item paste:
            BOOL* pPasted = (BOOL*)param;
            Set this to TRUE here if the item was successfully pasted.
        For multi-item paste:
            LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param;
            Use this to return a pointer to a dataobject consisting of the
            items successfully pasted. (see MMCN_CUTORMOVE below).

MMCN_FILTER_STATE:
    This message is sent when the user turns result view filtering on or off.
    dataobject = NULL
    arg = BOOL, True if filter turned on, Flase if filter turned off
    param = unused

MMCN_FILTER_CHANGE:
    This message is sent when the filter value for a result view column has been changed.
    dataobject= NULL
    arg = Filter change code (see MMC_FILTER_CHANGE_CODE enumeration)
    param = column number of changed value, if change code is MFCC_VALUE_CHANGE

MMCN_FILTER_CLICK:
    This message is sent when the filter button is clicked. The snap-in should display
    a UI for selecting the filter options.
    dataobject = NULL
    arg = Column number
    param = Pointer to filter button rect (*RECT)

MMCN_INITOCX:
    Sent to a snap-in when its custom OCX is initialized for the first time.
    param = The IUnknown to the OCX, the result pane. This is the same IUnknown you would get from IConsole::QueryResultView.

MMCN_PRINT:
    Sent to inform the snapin that the item needs to be printed. As a result of
    the user selecting the 'Print' button or menu item.
    dataobject: dataobject of the selected item(s) provided by the snap-in.
    arg, param: unused.

MMCN_PRELOAD:
    Sent when parent of snapin to be preloaded is selected.
    dataobject: dataobject of snapin root node
    arg: HSCOPEITEM of root node
    param: unused (0)

MMCN_LISTPAD:
    Sent when a TaskPad ListView is being attached or detached.
    dataobject: dataobject of selected node
    arg:  BOOL true when attaching, false when detaching
    param: unused (0)

MMCN_RESTORE_VIEW:
    Sent when user selects Back/Forward buttons
    dataobject: dataobject of selected node
    arg: MMC_RESTORE_VIEW struct
    param: BOOL *, snapin sets to TRUE iff it handles this notification

MMCN_EXPANDSYNC
    This notification is sent when nodes are being expanded during initialization.
    The snap-in should handle this synchrnonously, without spawning a
    thread to handle the expansion.
    arg = unused
    param: MMC_EXPANDSYNC_STRUCT*,
        snapin sets to MMC_EXPANDSYNC_STRUCT.bHandled to TRUE iff it
        handles this notification

MMCN_COLUMNS_CHANGED
    This notification is sent to IComponent::Notify when the user hides columns or
    makes columns visible in the list view using the columns dialog box accessed
    through the view menu.
    This notification tells which columns are visible.

    arg   = unused
    param = pointer to MMC_VISIBLE_COLUMNS.

*/

/*
 * We need to make sure that some notifications are available
 * only to clients that build with a certain MMC_VER level.  Ideally, we'd just
 * put the cpp_quote tests around the value definitions in the enumeration.
 * This doesn't work with MIDL, however, so we need to work around it.
 */
cpp_quote("typedef enum _MMC_NOTIFY_TYPE                                ")
cpp_quote("{                                                            ")
cpp_quote("    MMCN_ACTIVATE           = 0x8001,                        ")
cpp_quote("    MMCN_ADD_IMAGES         = 0x8002,                        ")
cpp_quote("    MMCN_BTN_CLICK          = 0x8003,                        ")
cpp_quote("    MMCN_CLICK              = 0x8004,   // NOT USED          ")
cpp_quote("    MMCN_COLUMN_CLICK       = 0x8005,                        ")
cpp_quote("    MMCN_CONTEXTMENU        = 0x8006,   // NOT USED          ")
cpp_quote("    MMCN_CUTORMOVE          = 0x8007,                        ")
cpp_quote("    MMCN_DBLCLICK           = 0x8008,                        ")
cpp_quote("    MMCN_DELETE             = 0x8009,                        ")
cpp_quote("    MMCN_DESELECT_ALL       = 0x800A,                        ")
cpp_quote("    MMCN_EXPAND             = 0x800B,                        ")
cpp_quote("    MMCN_HELP               = 0x800C,   // NOT USED          ")
cpp_quote("    MMCN_MENU_BTNCLICK      = 0x800D,                        ")
cpp_quote("    MMCN_MINIMIZED          = 0x800E,                        ")
cpp_quote("    MMCN_PASTE              = 0x800F,                        ")
cpp_quote("    MMCN_PROPERTY_CHANGE    = 0x8010,                        ")
cpp_quote("    MMCN_QUERY_PASTE        = 0x8011,                        ")
cpp_quote("    MMCN_REFRESH            = 0x8012,                        ")
cpp_quote("    MMCN_REMOVE_CHILDREN    = 0x8013,                        ")
cpp_quote("    MMCN_RENAME             = 0x8014,                        ")
cpp_quote("    MMCN_SELECT             = 0x8015,                        ")
cpp_quote("    MMCN_SHOW               = 0x8016,                        ")
cpp_quote("    MMCN_VIEW_CHANGE        = 0x8017,                        ")
cpp_quote("    MMCN_SNAPINHELP         = 0x8018,                        ")
cpp_quote("    MMCN_CONTEXTHELP        = 0x8019,                        ")
cpp_quote("    MMCN_INITOCX            = 0x801A,                        ")
cpp_quote("#if (MMC_VER >= 0x0110)                                      ")
cpp_quote("    MMCN_FILTER_CHANGE      = 0x801B,                        ")
cpp_quote("    MMCN_FILTERBTN_CLICK    = 0x801C,                        ")
cpp_quote("    MMCN_RESTORE_VIEW       = 0x801D,                        ")
cpp_quote("    MMCN_PRINT              = 0x801E,                        ")
cpp_quote("    MMCN_PRELOAD            = 0x801F,                        ")
cpp_quote("    MMCN_LISTPAD            = 0x8020,                        ")
cpp_quote("    MMCN_EXPANDSYNC         = 0x8021,                        ")
cpp_quote("#if (MMC_VER >= 0x0120)                                      ")
cpp_quote("    MMCN_COLUMNS_CHANGED    = 0x8022,                        ")
cpp_quote("#if (MMC_VER >= 0x0200)                                      ")
cpp_quote("    MMCN_CANPASTE_OUTOFPROC = 0x8023,                        ")
cpp_quote("#endif // MMC_VER >= 0x0200                                  ")
cpp_quote("#endif // MMC_VER >= 0x0120                                  ")
cpp_quote("#endif // MMC_VER >= 0x0110                                  ")
cpp_quote("} MMC_NOTIFY_TYPE;                                           ")

cpp_quote("#if 0")
typedef enum _MMC_NOTIFY_TYPE
{
    MMCN__dummy_
} MMC_NOTIFY_TYPE;
cpp_quote("#endif")

typedef enum _DATA_OBJECT_TYPES
{
    CCT_SCOPE            = 0x8000, // Data object while for scope pane context
    CCT_RESULT           = 0x8001, // Data object while for result pane context
    CCT_SNAPIN_MANAGER   = 0x8002, // Data object while for snap-in manager context

    CCT_UNINITIALIZED    = 0xFFFF, // Data object has an invalid type

} DATA_OBJECT_TYPES;


//New window option(s)

const unsigned long MMC_NW_OPTION_NONE          = 0x0000;

// No scope pane
const unsigned long MMC_NW_OPTION_NOSCOPEPANE   = 0x0001;

// No standard toolbars
const unsigned long MMC_NW_OPTION_NOTOOLBARS    = 0x0002;

// Use short window title
const unsigned long MMC_NW_OPTION_SHORTTITLE    = 0x0004;

// Snap-in provides window title
const unsigned long MMC_NW_OPTION_CUSTOMTITLE   = 0x0008;

// Do not save view to console doc file
const unsigned long MMC_NW_OPTION_NOPERSIST     = 0x0010;

// No action pane
const unsigned long MMC_NW_OPTION_NOACTIONPANE  = 0x0020;


///////////////////////////////////////////////////////////////////////////////
// Common Console clipboard formats
//

// Clipboard format for node type guid
const wchar_t* CCF_NODETYPE = L"CCF_NODETYPE";

// Clipboard format for string version of node type guid
const wchar_t* CCF_SZNODETYPE = L"CCF_SZNODETYPE";

// Clipboard format for name displayed in scope pane
const wchar_t* CCF_DISPLAY_NAME = L"CCF_DISPLAY_NAME";

// Clipboard format for the snapin's class id.
const wchar_t* CCF_SNAPIN_CLASSID = L"CCF_SNAPIN_CLASSID";

cpp_quote("#if (MMC_VER >= 0x0210)")
// Clipboard format for the snapin's class.  It could be eithera string
// representation of a CLSID or an AQN of a framework snap-in
const wchar_t* CCF_SNAPIN_CLASS = L"CCF_SNAPIN_CLASS";
cpp_quote("#endif // MMC_VER >= 0x0210")

// Clipboard format for window title (for window data object)
const wchar_t* CCF_WINDOW_TITLE = L"CCF_WINDOW_TITLE";

// This is the MMC supplied Multi-select data object.
const wchar_t* CCF_MMC_MULTISELECT_DATAOBJECT = L"CCF_MMC_MULTISELECT_DATAOBJECT";

// Clipboard format for the snapins multi selected dataobjects.
// If there are N snapins whose objects are selected in the result
// pane, these N dataobjects will be passed in a GloballAlloced
// memory. The first DWORD contains the number of snapins, this will
// be followed by N ptrs to the DataObjects.
typedef struct _SMMCDataObjects
{
    DWORD           count;
    LPDATAOBJECT    lpDataObject[1];

} SMMCDataObjects;
const wchar_t* CCF_MULTI_SELECT_SNAPINS = L"CCF_MULTI_SELECT_SNAPINS";

// Clipboard format for the array of GUIDs which constitutes the object
// types of all the currently selected result items put by the snapin.
typedef struct _SMMCObjectTypes
{
    DWORD   count;
    GUID    guid[1];

} SMMCObjectTypes;

const wchar_t* CCF_OBJECT_TYPES_IN_MULTI_SELECT = L"CCF_OBJECT_TYPES_IN_MULTI_SELECT";

cpp_quote("#if (MMC_VER >= 0x0110)")
// Clipboard format for dynamically extending the selected items'
// context menus, toolbars, and/or property pages.
// Same structure as MMCObjectTypes.
typedef SMMCObjectTypes SMMCDynamicExtensions;

const wchar_t* CCF_MMC_DYNAMIC_EXTENSIONS = L"CCF_MMC_DYNAMIC_EXTENSIONS";

// optional Clipboard format for when the snapin wants to be preloaded;
// the data for this format is a BOOL.
const wchar_t* CCF_SNAPIN_PRELOADS = L"CCF_SNAPIN_PRELOADS";


// clipboard format for custom dynamic node IDs
typedef struct _SNodeID
{
    DWORD   cBytes;
    BYTE    id[1];
} SNodeID;


cpp_quote("#if (MMC_VER >= 0x0120)")
// updated version
typedef struct _SNodeID2
{
    DWORD   dwFlags;
    DWORD   cBytes;
    BYTE    id[1];
} SNodeID2;

// used by the _SNodeID2 structure
const DWORD MMC_NODEID_SLOW_RETRIEVAL = 0x01;

const wchar_t* CCF_NODEID2 = L"CCF_NODEID2";
cpp_quote("#endif // MMC_VER >= 0x0120")


const wchar_t* CCF_NODEID  = L"CCF_NODEID";


cpp_quote("#if (MMC_VER >= 0x0120)")
// Clipboard format to identify a set of columns put by a node
// for persisting column information.
// Two or more nodes can use same column-set.

typedef struct _SColumnSetID
{
    DWORD   dwFlags;
    DWORD   cBytes;
    BYTE    id[1];
} SColumnSetID;

const wchar_t* CCF_COLUMN_SET_ID = L"CCF_COLUMN_SET_ID";
cpp_quote("#endif // MMC_VER >= 0x0120")
cpp_quote("#endif // MMC_VER >= 0x0110")


///////////////////////////////////////////////////////////////////////////////
// APIs exported in mmc.lib
//

cpp_quote("STDAPI MMCPropertyChangeNotify(LONG_PTR lNotifyHandle, LPARAM param);")
cpp_quote("#if (MMC_VER >= 0x0110)")
cpp_quote("#include <specstrings.h>")
cpp_quote("STDAPI MMCPropertyHelp(_In_ LPOLESTR pszHelpTopic);")
cpp_quote("#endif // MMC_VER >= 0x0110")
cpp_quote("STDAPI MMCFreeNotifyHandle(LONG_PTR lNotifyHandle);")
cpp_quote("// MMCPropPageCallback is only available in mmc.lib. See MMCAfxPropPageCallback if linking against mmcutil.lib.")
cpp_quote("STDAPI MMCPropPageCallback(void* vpsp);")
cpp_quote("EXTERN_C const CLSID CLSID_NodeManager;")

cpp_quote("#if (MMC_VER >= 0x0120)")
cpp_quote("EXTERN_C const CLSID CLSID_MessageView;")
cpp_quote("#endif // MMC_VER >= 0x0120")

cpp_quote("#if (MMC_VER >= 0x0210)")
cpp_quote("// Snap-in implemented callback responsible for calling AFX_MANAGE_STATE() for the snapin-in's module.")
cpp_quote("typedef void (STDAPICALLTYPE *PFNAfxManageStateCallback)();")
cpp_quote("// Sets up a PROPSHEETPAGE structure for calling the snap-in's PFNAfxManageStateCallback.")
cpp_quote("// MMCAfxPropPageCallback is available in both mmc.lib and mmcutil.lib.")
cpp_quote("// Returns:")
cpp_quote("// S_OK - success")
cpp_quote("// E_POINTER - vpsp or pfnCallback is null")
cpp_quote("// E_INVALIDARG - vpsp->pfnCallback must be the same for all property pages")
cpp_quote("// E_INVALIDARG - pfnManageStateCallback must be the same for all property pages")
cpp_quote("// E_UNEXPECTED - vpsp has already been passed to MMCAfxPropPageCallback")
cpp_quote("STDAPI MMCAfxPropPageCallback(void* vpsp, PFNAfxManageStateCallback pfnManageStateCallback);")
cpp_quote("#endif // MMC_VER >= 0x0210")


///////////////////////////////////////////////////////////////////////////////
// Special dataobjects
//
cpp_quote("#define DOBJ_NULL        (LPDATAOBJECT)   0")
cpp_quote("#define DOBJ_CUSTOMOCX   (LPDATAOBJECT)  -1")
cpp_quote("#define DOBJ_CUSTOMWEB   (LPDATAOBJECT)  -2")
cpp_quote("#if (MMC_VER >= 0x0110)")
cpp_quote("#if (MMC_VER >= 0x0120)")
cpp_quote("#define DOBJ_NOCONSOLE   (LPDATAOBJECT)  -3")
cpp_quote("#endif // MMC_VER >= 0x0120")
cpp_quote("#define SPECIAL_DOBJ_MIN                -10")
cpp_quote("#define SPECIAL_DOBJ_MAX                  0")
cpp_quote("#endif // MMC_VER >= 0x0110")

///////////////////////////////////////////////////////////////////////////////
// Macros
//
cpp_quote("#define IS_SPECIAL_DATAOBJECT(d) (((LONG_PTR)(d) >= SPECIAL_DOBJ_MIN)   && ((LONG_PTR)(d) <= SPECIAL_DOBJ_MAX))")
cpp_quote("#define IS_SPECIAL_COOKIE(c)     (((c)          >= SPECIAL_COOKIE_MIN) && ((c)          <= SPECIAL_COOKIE_MAX))")

///////////////////////////////////////////////////////////////////////////////
//  Interfaces
//
    [
        object,
        uuid(955AB28A-5218-11D0-A985-00C04FD8D565),
        helpstring("IComponentData Interface"),
        pointer_default(unique)
    ]
    interface IComponentData : IUnknown
    {
        [helpstring("Snap-in entry point. Can QI for IConsole & IConsoleNameSpace")]
        HRESULT Initialize([in] LPUNKNOWN pUnknown);

        [helpstring("Create a Componet for this ComponetData")]
        HRESULT CreateComponent([out] LPCOMPONENT* ppComponent);

        [helpstring("User actions")]
        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event,
                       [in] LPARAM arg, [in] LPARAM param);

        [helpstring("Release cookies associated with the children of a specific node")]
        HRESULT Destroy();

        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")]
        HRESULT QueryDataObject([in] MMC_COOKIE cookie, [in] DATA_OBJECT_TYPES type,
                                [out] LPDATAOBJECT* ppDataObject);

        [helpstring("Get display info for the name space item")]
        HRESULT GetDisplayInfo([in,out] SCOPEDATAITEM* pScopeDataItem);

        [helpstring("The snap-in's compare function for two data objects")]
        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB);
    };


    [
        object,
        uuid(43136EB2-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IComponent Interface"),
        pointer_default(unique)
    ]
    interface IComponent : IUnknown
    {
        [helpstring("Snap-in entry point")]
        HRESULT Initialize([in] LPCONSOLE lpConsole);

        [helpstring("User actions")]
        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event,
                       [in] LPARAM arg, [in] LPARAM param);

        [helpstring("Release cookies associated with the children of a specific node")]
        HRESULT Destroy([in] MMC_COOKIE cookie);

        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")]
        HRESULT QueryDataObject([in] MMC_COOKIE cookie, [in] DATA_OBJECT_TYPES type,
                                [out] LPDATAOBJECT* ppDataObject);

        [helpstring("Returns the result view type for the specified cookie")]
        HRESULT GetResultViewType([in] MMC_COOKIE cookie, [out] LPOLESTR* ppViewType,
                                  [out] long* pViewOptions);

        [helpstring("Get display info for the result item")]
        HRESULT GetDisplayInfo([in,out] RESULTDATAITEM*  pResultDataItem);

        [helpstring("The snap-in's compare function for two data objects")]
        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB);
    };


    [
        object,
        uuid(E8315A52-7A1A-11D0-A2D2-00C04FD909DD),
        helpstring("Compare interface for sorting result items"),
        pointer_default(unique)
    ]
    interface IResultDataCompare : IUnknown
    {
        [helpstring("Compare two cookies")]
        HRESULT Compare([in] LPARAM lUserParam,
            [in] MMC_COOKIE cookieA, [in] MMC_COOKIE cookieB, [in, out] int* pnResult);
    }


    [
        object,
        uuid(9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C),
        helpstring("Interface for owner data result pane list"),
        pointer_default(unique)
    ]
    interface IResultOwnerData : IUnknown
    {
        [helpstring("Find result item that matches string")]
        HRESULT FindItem([in] LPRESULTFINDINFO pFindInfo, [out] int* pnFoundIndex);

        [helpstring("Hint to cache result item data")]
        HRESULT CacheHint ([in] int nStartIndex, [in] int nEndIndex);

        [helpstring("Sort result items")]
        HRESULT SortItems([in] int nColumn, [in] DWORD dwSortOptions, [in] LPARAM lUserParam);
    }


    [
        object,
        uuid(43136EB1-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IConsole Interface"),
        pointer_default(unique)
    ]
    interface IConsole : IUnknown
    {
        [helpstring("Sets IConsoles header interface")]
        HRESULT SetHeader([in] LPHEADERCTRL pHeader);

        [helpstring("Sets IConsoles toolbar interface")]
        HRESULT SetToolbar([in] LPTOOLBAR pToolbar);

        [helpstring("Queries IConsoles user provided IUnknown")]
        HRESULT QueryResultView([out] LPUNKNOWN* pUnknown);

        [helpstring("Queries the IConsole provided image list for the scope pane.")]
        HRESULT QueryScopeImageList([out] LPIMAGELIST* ppImageList);

        [helpstring("Queries the IConsole provided image list for the result pane.")]
        HRESULT QueryResultImageList([out] LPIMAGELIST* ppImageList);

        [helpstring("Generates a notification to update view(s) because of content change")]
        HRESULT UpdateAllViews([in] LPDATAOBJECT lpDataObject,
                               [in] LPARAM data,
                               [in] LONG_PTR hint);

        [helpstring("Displays a message box")]
        HRESULT MessageBox([in] LPCWSTR lpszText, [in] LPCWSTR lpszTitle,
                           [in] UINT fuStyle, [out] int* piRetval);

        [helpstring("Query for the IConsoleVerb.")]
        HRESULT QueryConsoleVerb([out] LPCONSOLEVERB * ppConsoleVerb);

        [helpstring("Selects the given scope item.")]
        HRESULT SelectScopeItem([in] HSCOPEITEM hScopeItem);

        [helpstring("Returns handle to the main frame window.")]
        HRESULT GetMainWindow([out] HWND* phwnd);

        [helpstring("Create a new window rooted at the scope item specified by hScopeItem.")]
        HRESULT NewWindow([in] HSCOPEITEM hScopeItem, [in] unsigned long lOptions);

    };



    [
        object,
        uuid(43136EB3-D36C-11CF-ADBC-00AA00A80033),
        helpstring("INodeInit Interface"),
        pointer_default(unique)
    ]
    interface IHeaderCtrl : IUnknown
    {
        const int AUTO_WIDTH = -1;  // Column width is determined by the string length + padding
cpp_quote("#if (MMC_VER >= 0x0120)")
        const int HIDE_COLUMN = -4;  // Column will be hidden
cpp_quote("#endif // MMC_VER >= 0x0120")

        [helpstring("Add a column to a Default Result view")]
        HRESULT InsertColumn([in] int nCol, [in,] LPCWSTR title, [in] int nFormat, [in] int nWidth);

        [helpstring("Remove a column to a Default Result view")]
        HRESULT DeleteColumn([in] int nCol);

        [helpstring("Set a columns text")]
        HRESULT SetColumnText([in] int nCol, [in] LPCWSTR title);

        [helpstring("Gets a columns text")]
        HRESULT GetColumnText([in] int nCol, [out] LPOLESTR* pText);

        [helpstring("Set a columns width")]
        HRESULT SetColumnWidth([in] int nCol, [in] int nWidth);

        [helpstring("Gets a columns width")]
        HRESULT GetColumnWidth([in] int nCol, [out] int* pWidth);
    };

enum
{
///////////////////////////////////////////////////////////////////////////////
// The following bits in insertion point / submenu IDs are handled specially:
//
// CCM_INSERTIONPOINTID_MASK_SPECIAL:
//   Insertion points and submenus whose IDs contain any bit in
//   CCM_INSERTIONPOINTID_MASK_SPECIAL have special behavior.  Snap-Ins may use
//   the other bits as they see fit.
// CCM_INSERTIONPOINTID_MASK_SHARED:
//   Insertion points and submenus whose IDs contain CCM_INSERTIONPOINTID_MASK_SHARED
//   are shared between the creator of the context menu, the primary extension and
//   the third-party extension.  Any of these entities adding items to a shared
//   insertion point or submenu, add them to the same insertion point or submenu.
//   Only IContextMenuProvider may create insertion points or submenus with this bit
//   set, unless CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY is also set, in which case
//   only the primary extension may create them.
// CCM_INSERTIONPOINT_CREATE_PRIMARY:
//   Only the system may add insertion points or submenus for which CCM_INSERTIONPOINT_SHARED
//   is set and this bit is not set.  Only the primary extension may add insertion points
//   or submenus for which both bits are set.  This prevents insertion point ID conflicts
//   between insertion points and submenus created by IContextMenuProvider and those
//   created by the primary extension.
// CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY:
//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then
//   the primary extension may not add to this insertion point or submenu.
// CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY:
//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then
//   the third-party extensions may not add to this insertion point or submenu.
// CCM_INSERTIONPOINTID_MASK_RESERVED:
//   Insertion points and submenus may not be added with any of these bits set.
// CCM_INSERTIONPOINTID_MASK_FLAGINDEX:
//   This mask extracts the the index field from system insertion point IDs.
//   The index gives the bit position of the associated insertion allowed flag.

    CCM_INSERTIONPOINTID_MASK_SPECIAL        = 0xFFFF0000,
    CCM_INSERTIONPOINTID_MASK_SHARED         = 0x80000000,
    CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY = 0x40000000,
    CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY    = 0x20000000,
    CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY   = 0x10000000,
    CCM_INSERTIONPOINTID_MASK_RESERVED       = 0x0FFF0000,
    CCM_INSERTIONPOINTID_MASK_FLAGINDEX      = 0x0000001F,

///////////////////////////////////////////////////////////////////////////////
// Use these InsertionPointIDs to add items at the predefined insertion points:
//
// 0
//   This is interpreted the same as CCM_INSERTIONPOINTID_ROOT_MENU (see below).
// CCM_INSERTIONPOINTID_PRIMARY_TOP:
//   The primary extension may use this insertion point to add items to the top of
//   the main context menu.
// CCM_INSERTIONPOINTID_PRIMARY_NEW:
//   The primary extension may use this insertion point to add items to the top of
//   the Create New submenu.
// CCM_INSERTIONPOINTID_PRIMARY_TASK:
//   The primary extension may use this insertion point to add items to the top of
//   the Task submenu.
// CCM_INSERTIONPOINTID_PRIMARY_HELP:
//   The primary extension may use this insertion point to add items to the top of
//   the Help submenu.
// CCM_INSERTIONPOINTID_3RDPARTY_NEW:
//   Third-party extensions may use this insertion point to add items to the bottom of
//   the Create New submenu.
// CCM_INSERTIONPOINTID_3RDPARTY_TASK:
//   Third-party extensions may use this insertion point to add items to the bottom of
//   the Task submenu.
// CCM_INSERTIONPOINTID_ROOT_MENU:
//   IContextMenuProvider may use this insertion point to add items to the root menu.
//   Neither primary extensions nor third-party extension may add items to the root
//   menu except through insertion points added by IContextMenuProvider.
//
    CCM_INSERTIONPOINTID_PRIMARY_TOP   = 0xA0000000, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_NEW   = 0xA0000001, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_TASK  = 0xA0000002, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_VIEW  = 0xA0000003, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_HELP  = 0xA0000004, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_3RDPARTY_NEW  = 0x90000001, // SHARED and ADD_3RDPARTY
    CCM_INSERTIONPOINTID_3RDPARTY_TASK = 0x90000002, // SHARED and ADD_3RDPARTY
    CCM_INSERTIONPOINTID_ROOT_MENU     = 0x80000000  // SHARED
};

//
// Macro to derive an insertion allowed flag from an system insertion point ID
//
#define INSERTALLOWED_FLAG(insertionID) \
         (1L << (insertionID & CCM_INSERTIONPOINTID_MASK_FLAGINDEX))
enum
{
/////////////////////////////////////////////////////////////////////////////////////
// These flags give permission to insert menu items at the CCM_INSERTIONPOINTID_xxx
// insertion points define above. The bit position of each flag is derived from the
// index portion of the corresponding insertion point ID. They are passed to the
// snap-in's AddMenuItems method.

   CCM_INSERTIONALLOWED_TOP  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TOP),
   CCM_INSERTIONALLOWED_NEW  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_NEW),
   CCM_INSERTIONALLOWED_TASK = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TASK),
   CCM_INSERTIONALLOWED_VIEW = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_VIEW)
};


enum
{
///////////////////////////////////////////////////////////////////////////////
// The following bits in menu command IDs are handled specially:
//
// CCM_COMMANDID_MASK_RESERVED:
//   Items other than insertion points and submenus may not be added with any of
//   these bits set.
//
    CCM_COMMANDID_MASK_RESERVED       = 0xFFFF0000
};

enum
{
///////////////////////////////////////////////////////////////////////////////
// The following flags may be passed via AddMenuItem parameter fSpecialFlags:
//
// CCM_SPECIAL_SEPARATOR
//   Ignore all other parameters except lInsertionPointID.  Add a separator to the
//   end of the menu or the specified insertion point, except that
//   CCM_SPECIAL_SEPARATOR will never add a separator as the first or last item
//   in a menu/submenu, and if two or more consecutive CCM_SPECIAL_SEPARATORs are added,
//   only one appears in the menu.  Only IContextMenuProvider is permitted to add
//   separators, either special or otherwise, to menus created by IContextMenuProvider.
//
    CCM_SPECIAL_SEPARATOR         = 0x0001,
//
// CCM_SPECIAL_SUBMENU
//   If this submenu is empty, then it will be grayed and disabled.
//   This is only valid for MF_POPUP items.
//
    CCM_SPECIAL_SUBMENU           = 0x0002,
//
// CCM_SPECIAL_DEFAULT_ITEM
//   This should be the default menu item.  If more than one menu item specifies this flag,
//   the last one in each submenu takes precedence.
//
    CCM_SPECIAL_DEFAULT_ITEM      = 0x0004,
//
// CCM_SPECIAL_INSERTION_POINT
//   Ignore all other parameters except lCommandID and lInsertionPointID.  This creates
//   a new "insertion point" at the end of the insertion point or submenu identified by
//   lInsertionPointID (0 is the end of the main menu).  Subsequent calls may use
//   the lCommandID from this call as their lInsertionPointID, and insert their own
//   menu items, submenus or insertion points at this point in this menu.
//
    CCM_SPECIAL_INSERTION_POINT   = 0x0008,
//
// CCM_SPECIAL_TESTONLY
//   Perform the normal validation of the menu item parameters and return the appropriate
//   result code, but do not actually add the menu item.
//
    CCM_SPECIAL_TESTONLY          = 0x0010
};


    [
        object,
        uuid(43136EB7-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IContextMenuCallback Interface"),
        pointer_default(unique)
    ]
    interface IContextMenuCallback : IUnknown
    {
        // returns S_OK if the item was added
        // returns E_INVALIDARG if given a NULL pointer
        // returns E_INVALIDARG if an item already exists with this lCommandID
        // returns E_INVALIDARG if insertion point ID could not be found
        // returns E_INVALIDARG if command ID or insertion point ID is invalid
        // returns E_INVALIDARG if fFlags contains MF_OWNERDRAW or MF_BITMAP
        // returns E_INVALIDARG if an extension attempts to add an item where
        //   fFlags contains MF_SEPARATOR or fSpecialFlags contains CCM_SPECIAL_SEPARATOR
        //   except in submenus created by extensions
        // otherwise an unexpected error occurred
        [helpstring("Adds one item to context menu")]
        HRESULT AddItem([in] CONTEXTMENUITEM* pItem);
    };



    [
        object,
        uuid(43136EB6-D36C-11CF-ADBC-00AA00A80033),
        object,
        helpstring("IContextMenuProvider Interface"),
        pointer_default(unique)
    ]
    //
    // Note that this derives from IContextMenuCallback
    //
    interface IContextMenuProvider : IContextMenuCallback
    {
        // Methods
        // returns S_OK unless an unexpected error occurs
        [helpstring("Clear context menu")]
        HRESULT EmptyMenuList();

        // returns S_OK if successful
        // returns E_INVALIDARG on NULL parameter
        // passes through return code from IExtendContextMenu::AddMenuItems
        //   or from CoCreateInstance
        // otherwise an unexpected error occurred
        [helpstring("Allow the primary extension to add to bottom of context menu")]
        HRESULT AddPrimaryExtensionItems([in] LPUNKNOWN piExtension, [in] LPDATAOBJECT piDataObject);

        // returns S_OK if successful
        // returns E_INVALIDARG on NULL parameter
        // returns S_FALSE if context menu has already been extended
        // passes through return code from IExtendContextMenu::AddMenuItems
        //   or from CLSIDToString or CoCreateInstance
        // otherwise an unexpected error occurred
        [helpstring("Allow third-party extensions to add to bottom of context menu")]
        HRESULT AddThirdPartyExtensionItems([in] LPDATAOBJECT piDataObject);

        // returns S_OK unless an unexpected error occurs
        [helpstring("Display context menu")]
        HRESULT ShowContextMenu([in] HWND hwndParent, [in] long xPos, [in] long yPos, [out,retval] long* plSelected);
    };


    [
        object,
        uuid(4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0),
        helpstring("IExtendContextMenu Interface"),
        pointer_default(unique)
    ]
    interface IExtendContextMenu : IUnknown
    {
        [helpstring("Extension may add context menu items via callback interface")]
        HRESULT AddMenuItems([in] LPDATAOBJECT piDataObject,
                             [in] LPCONTEXTMENUCALLBACK piCallback,
                             [in,out] long *pInsertionAllowed);

        [helpstring("Extension context menu item was selected")]
        HRESULT Command([in] long lCommandID, [in] LPDATAOBJECT piDataObject);
    };


cpp_quote("#if (MMC_VER >= 0x0120)")
// specify change large or small icon only in ImageListSetIcon
cpp_quote("#define ILSIF_LEAVE_LARGE_ICON  0x40000000")
cpp_quote("#define ILSIF_LEAVE_SMALL_ICON  0x20000000")
cpp_quote("#define ILSIF_LEAVE_MASK        (ILSIF_LEAVE_LARGE_ICON | ILSIF_LEAVE_SMALL_ICON)")

cpp_quote("#define ILSI_LARGE_ICON(nLoc)   (nLoc | ILSIF_LEAVE_SMALL_ICON)")
cpp_quote("#define ILSI_SMALL_ICON(nLoc)   (nLoc | ILSIF_LEAVE_LARGE_ICON)")
cpp_quote("#endif // MMC_VER >= 0x0120")

    [
        object,
        uuid(43136EB8-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IImageList Interface"),
        pointer_default(unique)
    ]
    interface IImageList : IUnknown
    {
        [helpstring("Sets an Icon in the image list, creates it if it is not there.")]
        HRESULT ImageListSetIcon([in] LONG_PTR* pIcon, [in] long nLoc);

        [helpstring("Sets a strip in the image list, starting at nLoc using a pair of bitmaps.")]
        HRESULT ImageListSetStrip([in] LONG_PTR* pBMapSm,
            [in] LONG_PTR* pBMapLg,[in] long nStartLoc, [in] COLORREF cMask);
    };



    [
        object,
        uuid(31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6),
        helpstring("IResultData Interface"),
        pointer_default(unique)
    ]
    interface IResultData : IUnknown
    {
        [helpstring("Allows the snap-in to insert a single item.")]
        HRESULT InsertItem([in,out] LPRESULTDATAITEM item);

        [helpstring("Allows the snap-in to delete a single item.")]
        HRESULT DeleteItem([in] HRESULTITEM itemID, [in] int nCol);

        [helpstring("Allows the snap-in to find an item/subitem based on its user inserted lParam.")]
        HRESULT FindItemByLParam([in] LPARAM lParam, [out] HRESULTITEM *pItemID);

        [helpstring("Allows the snap-in to delete all the items.")]
        HRESULT DeleteAllRsltItems();

        [helpstring("Allows the snap-in to set a single item.")]
        HRESULT SetItem([in] LPRESULTDATAITEM item);

        [helpstring("Allows the snap-in to get a single item.")]
        HRESULT GetItem([in,out] LPRESULTDATAITEM item);

        [helpstring("Returns the lParam of the first item, which matches the given state.")]
        HRESULT GetNextItem([in,out] LPRESULTDATAITEM item);

        [helpstring("Allows the snap-in to modify the state of an item.")]
        HRESULT ModifyItemState([in] int nIndex, [in] HRESULTITEM itemID,
                                [in] UINT uAdd, [in] UINT uRemove);

        [helpstring("Allows the snap-in to set the result view style.")]
        HRESULT ModifyViewStyle([in] MMC_RESULT_VIEW_STYLE add,
                             [in] MMC_RESULT_VIEW_STYLE remove);

        [helpstring("Allows the snap-in to set the result view mode.")]
        HRESULT SetViewMode([in] long lViewMode);

        [helpstring("Allows the snap-in to get the result view mode.")]
        HRESULT GetViewMode([out] long* lViewMode);

        [helpstring("Allows the snap-in to update a single item.")]
        HRESULT UpdateItem([in] HRESULTITEM itemID);

        [helpstring("Sort all items in result pane")]
        HRESULT Sort([in] int nColumn, [in] DWORD dwSortOptions, [in] LPARAM lUserParam);

        [helpstring("Set the description bar text for the result view")]
        HRESULT SetDescBarText([in] LPOLESTR DescText);

        [helpstring("Set number of items in result pane list")]
        HRESULT SetItemCount([in] int nItemCount, [in] DWORD dwOptions);

    };


    [
        object,
        uuid(BEDEB620-F24D-11cf-8AFC-00AA003CA9F6),
        helpstring("IConsoleNameSpace Interface"),
        pointer_default(unique)
    ]
    interface IConsoleNameSpace : IUnknown
    {
        import "oaidl.idl";
        [helpstring("Allows the snap-in to insert a single item into the scope view.")]
        HRESULT InsertItem([in,out] LPSCOPEDATAITEM  item);

        [helpstring("Allows the snap-in to delete a single item from the scope view.")]
        HRESULT DeleteItem([in] HSCOPEITEM hItem, [in] long fDeleteThis);

        [helpstring("Allows the snap-in to set a single scope view item.")]
        HRESULT SetItem([in] LPSCOPEDATAITEM item);

        [helpstring("Allows the snap-in to get a single scope view item.")]
        HRESULT GetItem([in,out] LPSCOPEDATAITEM item);

        [helpstring("The handle of the child item if successful, otherwise NULL.")]
        HRESULT GetChildItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemChild,
                             [out] MMC_COOKIE* pCookie);

        [helpstring("The handle of the next item if successful, otherwise NULL.")]
        HRESULT GetNextItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemNext,
                            [out] MMC_COOKIE* pCookie);

        [helpstring("The handle of the parent item if successful, otherwise NULL.")]
        HRESULT GetParentItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemParent,
                              [out] MMC_COOKIE* pCookie);
    };


    [
        object,
        uuid(255F18CC-65DB-11D1-A7DC-00C04FD8D565),
        helpstring("IConsoleNameSpace2 Interface"),
        pointer_default(unique)
    ]
    interface IConsoleNameSpace2 : IConsoleNameSpace
    {
        [helpstring("Allows the snap-in to expand an item in the console namespace.")]
        HRESULT Expand([in] HSCOPEITEM hItem);

        [helpstring("Add a dynamic extension to a selected node")]
        HRESULT AddExtension([in] HSCOPEITEM hItem, [in] LPCLSID lpClsid);
    };


struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

    [
        local,
        object,
        uuid(85DE64DD-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IPropertySheetCallback Interface"),
        pointer_default(unique)
    ]
    interface IPropertySheetCallback : IUnknown
    {

        [helpstring("Snap-in uses this to add a page to a property sheet")]
        HRESULT AddPage([in] HPROPSHEETPAGE hPage);

        [helpstring("Snap-in uses this to remove a page from a property sheet")]
        HRESULT RemovePage([in] HPROPSHEETPAGE  hPage);
    };

    [
        object,
        uuid(85DE64DE-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IPropertySheetProvider Interface"),
        pointer_default(unique)
    ]
    interface IPropertySheetProvider : IUnknown
    {
        [helpstring("Creates a property sheet frame")]
        HRESULT CreatePropertySheet([in] LPCWSTR title, [in] boolean type,
                                    [in] MMC_COOKIE cookie, [in] LPDATAOBJECT pIDataObjectm,
                                    [in] DWORD dwOptions);

        [helpstring("Determine if the property sheet exists")]
        HRESULT FindPropertySheet([in] HSCOPEITEM hItem, [in] LPCOMPONENT lpComponent, [in] LPDATAOBJECT lpDataObject);

        [helpstring("Collects the pages from the primary snap-in")]
        HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);

        [helpstring("Collects the pages from the extension snap-in(s)")]
        HRESULT AddExtensionPages();

        [helpstring("Shows a property sheet frame parented to the HWND passed in")]
        HRESULT Show([in] LONG_PTR window, [in] int page);
    };

    [
        object,
        uuid(85DE64DC-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IExtendPropertySheet Interface"),
        pointer_default(unique)
    ]
    interface IExtendPropertySheet : IUnknown
    {
        [helpstring("Interface implemented by the snap-in to add pages to a sheet")]
        // handle - This handle must be saved in the property page object
        //          to notify the parent of changes in property using API
        //          MMCPropertyChangeNotify. The API MMCFreeNotifyHandle
        //          should be called just before the property page is
        //          destroyed to delete the handle.
        HRESULT CreatePropertyPages([in] LPPROPERTYSHEETCALLBACK lpProvider,
                                    [in] LONG_PTR handle,
                                    [in] LPDATAOBJECT lpIDataObject);

        [helpstring("Interface implemented by the snap-in to determine if this object needs pages")]
        HRESULT QueryPagesFor([in] LPDATAOBJECT lpDataObject);
    };



    [
        object,
        uuid(69FB811E-6C1C-11D0-A2CB-00C04FD909DD),
        helpstring("Control bar to hold toolbar and other controls"),
        pointer_default(unique)
    ]
    interface IControlbar : IUnknown
    {
        [helpstring("Create and return the control requested")]
        HRESULT Create([in] MMC_CONTROL_TYPE nType,
                       [in] LPEXTENDCONTROLBAR pExtendControlbar,
                       [out] LPUNKNOWN* ppUnknown);

        [helpstring("Associated the control to the control bar")]
        HRESULT Attach([in] MMC_CONTROL_TYPE nType, [in] LPUNKNOWN  lpUnknown);

        [helpstring("Break the association between the control and the control bar")]
        HRESULT Detach([in] LPUNKNOWN lpUnknown);
    };

    [
        object,
        uuid(49506520-6F40-11D0-A98B-00C04FD8D565),
        helpstring("IExtendControlbar Interface"),
        pointer_default(unique)
    ]
    interface IExtendControlbar : IUnknown
    {
        [helpstring("Extension may add toolbars via callback interface")]
        HRESULT SetControlbar([in] LPCONTROLBAR pControlbar);

        [helpstring("User actions")]
        HRESULT ControlbarNotify([in] MMC_NOTIFY_TYPE event,
                                 [in] LPARAM arg, [in] LPARAM param);
    };


    [
        object,
        uuid(43136EB9-D36C-11CF-ADBC-00AA00A80033),
        pointer_default(unique)
    ]
    interface IToolbar : IUnknown
    {
        [helpstring("Add and image to the toolbar")]
        HRESULT AddBitmap([in] int nImages, [in] HBITMAP hbmp, [in] int cxSize, [in] int cySize, [in] COLORREF crMask );

        [helpstring("Add an array of buttons to the toolbar")]
        HRESULT AddButtons([in] int nButtons, [in] LPMMCBUTTON lpButtons);

        [helpstring("Add a single button to the toolbar at position nIndex")]
        HRESULT InsertButton([in] int nIndex, [in] LPMMCBUTTON lpButton);

        [helpstring("Remove a button at the index")]
        HRESULT DeleteButton([in] int nIndex);

        [helpstring("Get an attribute of a button")]
        HRESULT GetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState);

        [helpstring("Set an attribute of a button")]
        HRESULT SetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [in] BOOL bState);
    };


    [
        object,
        uuid(E49F7A60-74AF-11D0-A286-00C04FD8FE93),
        pointer_default(unique)
    ]
    interface IConsoleVerb : IUnknown
    {
        [helpstring("Get verb state")]
        HRESULT GetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState);

        [helpstring("Set verb state")]
        HRESULT SetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [in] BOOL bState);

        [helpstring("Set default verb")]
        HRESULT SetDefaultVerb([in] MMC_CONSOLE_VERB eCmdID);

        [helpstring("Get default verb")]
        HRESULT GetDefaultVerb([out] MMC_CONSOLE_VERB* peCmdID);
    };


    [
        object,
        uuid(1245208C-A151-11D0-A7D7-00C04FD909DD),
        pointer_default(unique)
    ]
    interface ISnapinAbout : IUnknown
    {
        [helpstring("Text for the snap-in description box")]
        HRESULT GetSnapinDescription([out] LPOLESTR* lpDescription);

        [helpstring("Provider name")]
        HRESULT GetProvider([out] LPOLESTR* lpName);

        [helpstring("Version number for the snap-in")]
        HRESULT GetSnapinVersion([out] LPOLESTR* lpVersion);

        [helpstring("Main icon for about box")]
        HRESULT GetSnapinImage([out] HICON* hAppIcon);

        [helpstring("Static folder images for scope and result panes")]
        HRESULT GetStaticFolderImage([out] HBITMAP* hSmallImage,
                                     [out] HBITMAP* hSmallImageOpen,
                                     [out] HBITMAP* hLargeImage,
                                     [out] COLORREF* cMask);
    };


    [
        object,
        uuid(951ED750-D080-11d0-B197-000000000000),
        pointer_default(unique)
    ]
    interface IMenuButton : IUnknown
    {
        [helpstring("Adds a button")]
        HRESULT AddButton([in] int idCommand,[in] LPOLESTR lpButtonText,
                                             [in] LPOLESTR lpTooltipText);

        [helpstring("Set an attributes of a button")]
        HRESULT SetButton([in] int idCommand,[in] LPOLESTR lpButtonText,
                                             [in] LPOLESTR lpTooltipText);

        [helpstring("Set the state of a button")]
        HRESULT SetButtonState([in] int idCommand,
                               [in] MMC_BUTTON_STATE nState,
                               [in] BOOL bState);
    };


    [
        object,
        uuid(A6B15ACE-DF59-11D0-A7DD-00C04FD909DD),
        pointer_default(unique)
    ]
    interface ISnapinHelp : IUnknown
    {
        [helpstring("Get the compiled help file (.chm) from a snap-in to merge")]
        HRESULT GetHelpTopic([out] LPOLESTR* lpCompiledHelpFile);

    };


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.1 changes
////
cpp_quote("#if (MMC_VER >= 0x0110)")

    [
        object,
        uuid(B7A87232-4A51-11D1-A7EA-00C04FD909DD),
        helpstring("IExtendPropertySheet2 Interface, adds support for Wizard 97 specification"),
        pointer_default(unique)
    ]
    interface IExtendPropertySheet2 : IExtendPropertySheet
    {
        [helpstring("Interface implemented by the snap-in, to get the watermark and text for Wizard 97 style")]
        HRESULT GetWatermarks([in]  LPDATAOBJECT lpIDataObject,
                              [out] HBITMAP* lphWatermark,
                              [out] HBITMAP* lphHeader,
                              [out] HPALETTE* lphPalette,
                              [out] BOOL* bStretch);
    };

    [
        object,
        uuid(9757abb8-1b32-11d1-a7ce-00c04fd8d565),
        helpstring("IHeaderCtrl2 Interface, adds filter support"),
        pointer_default(unique)
    ]
    interface IHeaderCtrl2 : IHeaderCtrl
    {
        [helpstring("Sets the time out for filter change notification")]
        HRESULT SetChangeTimeOut([in] unsigned long uTimeout);

        [helpstring("Set filter data")]
        HRESULT SetColumnFilter([in] UINT nColumn, [in] DWORD dwType, [in] MMC_FILTERDATA* pFilterData);

        [helpstring("Get filter data")]
        HRESULT GetColumnFilter([in] UINT nColumn, [in,out] LPDWORD pdwType, [in, out] MMC_FILTERDATA* pFilterData);
    };


    [
        object,
        uuid(4861A010-20F9-11d2-A510-00C04FB6DD2C),
        helpstring("ISnapinHelp2 Interface, adds linked topics support"),
        pointer_default(unique)
    ]
    interface ISnapinHelp2 : ISnapinHelp
    {
        [helpstring("Get additional topic files to merge into help collection")]
        HRESULT GetLinkedTopics([out] LPOLESTR* lpCompiledHelpFiles);
    };

///////////////////////////////////////////////////////////////////////////////
////
////            Task Pad

typedef enum _MMC_TASK_DISPLAY_TYPE
{
    MMC_TASK_DISPLAY_UNINITIALIZED = 0,
    MMC_TASK_DISPLAY_TYPE_SYMBOL,           // fontname, EOT, symbols
    MMC_TASK_DISPLAY_TYPE_VANILLA_GIF,      // (GIF) index 0 is transparent
    MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF,    // (GIF) index 1 is transparent
    MMC_TASK_DISPLAY_TYPE_BITMAP            // non-transparent raster
} MMC_TASK_DISPLAY_TYPE;

typedef struct _MMC_TASK_DISPLAY_SYMBOL
{
    LPOLESTR szFontFamilyName;  // name of font family
    LPOLESTR szURLtoEOT;        // "res://"-type URL to EOT file
    LPOLESTR szSymbolString;    // 1 or more symbol characters
} MMC_TASK_DISPLAY_SYMBOL;

typedef struct _MMC_TASK_DISPLAY_BITMAP
{
    LPOLESTR szMouseOverBitmap;     // Note: URLs must be fully-qualified
    LPOLESTR szMouseOffBitmap;      // ("res://..." type) URLs
} MMC_TASK_DISPLAY_BITMAP;

typedef struct _MMC_TASK_DISPLAY_OBJECT
{
    MMC_TASK_DISPLAY_TYPE eDisplayType;
    [switch_type(MMC_TASK_DISPLAY_TYPE), switch_is((MMC_TASK_DISPLAY_TYPE)eDisplayType)]
    union {
    [case(MMC_TASK_DISPLAY_TYPE_BITMAP,MMC_TASK_DISPLAY_TYPE_VANILLA_GIF,MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF)]
        MMC_TASK_DISPLAY_BITMAP uBitmap;
    [case(MMC_TASK_DISPLAY_TYPE_SYMBOL)]
        MMC_TASK_DISPLAY_SYMBOL uSymbol;
    [default];
    };
} MMC_TASK_DISPLAY_OBJECT;

typedef enum _MMC_ACTION_TYPE
{
    MMC_ACTION_UNINITIALIZED = -1,
    MMC_ACTION_ID,
    MMC_ACTION_LINK,
    MMC_ACTION_SCRIPT,
} MMC_ACTION_TYPE;

typedef struct _MMC_TASK
{
    MMC_TASK_DISPLAY_OBJECT sDisplayObject;
    LPOLESTR szText;
    LPOLESTR szHelpString;
    MMC_ACTION_TYPE eActionType;    // from enum above
    union
    {
        LONG_PTR nCommandID;            // command id (unique number)
        LPOLESTR szActionURL;       // either link or scriptlet
        LPOLESTR szScript;          // raw script code
    };
} MMC_TASK;

typedef struct _MMC_LISTPAD_INFO
{
    LPOLESTR szTitle;           // title for ListView in TaskPad
    LPOLESTR szButtonText;      // text  for ListView in TaskPad
    LONG_PTR nCommandID;            // command id (unique number)
} MMC_LISTPAD_INFO;

typedef DWORD MMC_STRING_ID;


    [
        local,
        object,
        uuid(338698b1-5a02-11d1-9fec-00600832db4a),
        helpstring("Implemented by the snapins that want to add tasks"),
        pointer_default(unique)
    ]
    interface IEnumTASK : IUnknown
    {
        HRESULT Next(
                   [in] ULONG celt,
                   [out, size_is(celt), length_is(*pceltFetched)] MMC_TASK *rgelt,
                   [out] ULONG *pceltFetched);
        HRESULT Skip([in] ULONG celt);
        HRESULT Reset();
        HRESULT Clone([out] IEnumTASK **ppenum);

        // Skip and Clone are not called
        // Next will be called 1 at a time (i.e. celt will always be 1)
        // Reset will be called
    };



    [
        local,
        object,
        uuid(8dee6511-554d-11d1-9fea-00600832db4a),
        helpstring("Interface to be supported by those snapins that support taskpads"),
        pointer_default(unique)
    ]
    interface IExtendTaskPad : IUnknown
    {
        // called from script via CIC
        [helpstring("Notify.")]
        HRESULT TaskNotify([in] IDataObject* pdo, [in] VARIANT* arg, [in] VARIANT* param);

        [helpstring("Tasks to be inserted in the task pad.")]
        HRESULT EnumTasks([in] IDataObject * pdo, [in,string] LPOLESTR szTaskGroup,
                          [out] IEnumTASK** ppEnumTASK);

        // support for default taskpad
        [helpstring("Title for the default task pad.")]
        HRESULT GetTitle([in,string] LPOLESTR pszGroup, [out,string] LPOLESTR * pszTitle);

        [helpstring("Descriptive Text for the default task pad.")]
        HRESULT GetDescriptiveText([in,string] LPOLESTR pszGroup, [out,string] LPOLESTR * pszDescriptiveText);

        [helpstring("Background for the default task pad.")]
        HRESULT GetBackground([in,string] LPOLESTR pszGroup, [out] MMC_TASK_DISPLAY_OBJECT * pTDO);

//      [helpstring("Branding for the default task pad.")]
//      HRESULT GetBranding([in,string] LPOLESTR pszGroup, [out] MMC_TASK_DISPLAY_OBJECT * pTDO);

        [helpstring("Get ListPad Info.")]
        HRESULT GetListPadInfo ([in,string] LPOLESTR pszGroup, [out] MMC_LISTPAD_INFO * lpListPadInfo);
    };


    [
        object,
        uuid(103D842A-AA63-11D1-A7E1-00C04FD8D565),
        helpstring("IConsole2 Interface"),
        pointer_default(unique)
    ]
    interface IConsole2 : IConsole
    {
        [helpstring("Allows the snap-in to expand/collapse a scope item in the corresponding view. Should be called only by the IConsole associated with a IComponent.")]
        HRESULT Expand([in] HSCOPEITEM hItem, [in] BOOL bExpand);

        [helpstring("Determines if the user prefers taskpad views by default.")]
        HRESULT IsTaskpadViewPreferred();

        [helpstring("Allows the snap-in to change the text on the status bar.")]
        HRESULT SetStatusText ([in, string] LPOLESTR pszStatusText);
    };


    [
        object,
        uuid(cc593830-b926-11d1-8063-0000f875a9ce),
        helpstring("IDisplayHelp Interface"),
        pointer_default(unique)
    ]
    interface IDisplayHelp : IUnknown
    {
        [helpstring("Allows the snap-in to display a help topic.")]
        HRESULT ShowTopic([in] LPOLESTR pszHelpTopic);
    };


    [
        local,
        object,
        uuid(72782D7A-A4A0-11d1-AF0F-00C04FB6DD2C),
        helpstring("Interface for specifying required snap-in extensions"),
        pointer_default(unique)
    ]
    interface IRequiredExtensions : IUnknown
    {
        [helpstring("Enable all extensions")]
        HRESULT EnableAllExtensions();

        [helpstring("Get first required extension")]
        HRESULT GetFirstExtension([out] LPCLSID pExtCLSID);

        [helpstring("Get next required extension")]
        HRESULT GetNextExtension([out] LPCLSID pExtCLSID);
    };


    [
        object,
        uuid(DE40B7A4-0F65-11d2-8E25-00C04F8ECD78),
        helpstring("Interface for accessing strings in a console file"),
        pointer_default(unique)
    ]
    interface IStringTable : IUnknown
    {
        [helpstring("Add a string to the snap-in's string table")]
        HRESULT AddString (
            [in]  LPCOLESTR      pszAdd,    // string to add to the string table
            [out] MMC_STRING_ID* pStringID  // ID of added string
        );

        [helpstring("Retrieves a string from the snap-in's string table")]
        HRESULT GetString (
            [in]  MMC_STRING_ID StringID,   // ID of string
            [in]  ULONG         cchBuffer,  // number of characters in lpBuffer
            [out, size_is(cchBuffer)]
                  LPOLESTR      lpBuffer,   // string corresponding to wStringID
            [out] ULONG*        pcchOut     // number of characters written to lpBuffer
        );

        [helpstring("Retrieves the length of a string in the snap-in's string table")]
        HRESULT GetStringLength (
            [in]  MMC_STRING_ID StringID,   // ID of string
            [out] ULONG*        pcchString  // number of characters in string, not including terminator
        );

        [helpstring("Delete a string from the snap-in's string table")]
        HRESULT DeleteString (
            [in]  MMC_STRING_ID StringID    // ID of string to delete
        );

        [helpstring("Delete all strings from the snap-in's string table")]
        HRESULT DeleteAllStrings ();

        [helpstring("Find a string in the snap-in's string table")]
        HRESULT FindString (
            [in]  LPCOLESTR pszFind,        // string to find in the string table
            [out] MMC_STRING_ID* pStringID  // ID of string, if found
        );

        [helpstring("Returns an enumerator into a snap-in's string table")]
        HRESULT Enumerate (
            [out] IEnumString** ppEnum      // string enumerator
        );
    };
cpp_quote("#endif // MMC_VER >= 0x0110")


cpp_quote("#if (MMC_VER >= 0x0120)")
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.2 changes
////

// Column Flags
const DWORD HDI_HIDDEN         = 0x0001;       // Column is hidden.

// Per Column data.
typedef struct _MMC_COLUMN_DATA
{
    int       nColIndex;       // Column index
    DWORD     dwFlags;         // Column flags
    int       nWidth;          // Column width
    ULONG_PTR ulReserved;      // For future use
} MMC_COLUMN_DATA;


// Column-Set data.
typedef struct _MMC_COLUMN_SET_DATA
{
    int              cbSize;      // Size of this struct.
    int              nNumCols;    // Number of columns
    MMC_COLUMN_DATA* pColData;    // Array of column data
} MMC_COLUMN_SET_DATA;

// Sort data.
typedef struct _MMC_SORT_DATA
{
    int       nColIndex;       // Column index
    DWORD     dwSortOptions;   // Column sort options
    ULONG_PTR ulReserved;      // For future use
} MMC_SORT_DATA;


// Column sort data.
typedef struct _MMC_SORT_SET_DATA
{
    int              cbSize;      // Size of this struct.
    int              nNumItems;   // Number of items in the array below.
    MMC_SORT_DATA*   pSortData;   // Array of column data
} MMC_SORT_SET_DATA;

    [
        object,
        uuid(547C1354-024D-11d3-A707-00C04F8EF4CB),
        helpstring("Interface for accessing persisted view data."),
        pointer_default(unique)
    ]
    interface IColumnData : IUnknown
    {
        [helpstring("Change the persisted column data for a ColumnSet ID")]
        HRESULT SetColumnConfigData(
            [in] SColumnSetID* pColID,
            [in] MMC_COLUMN_SET_DATA* pColSetData
            );

        [helpstring("Retrieve the persisted column data for a ColumnSet ID")]
        HRESULT GetColumnConfigData(
            [in]  SColumnSetID* pColID,
            [out] MMC_COLUMN_SET_DATA** ppColSetData
            );

        [helpstring("Change the persisted column sort data for a ColumnSet ID")]
        HRESULT SetColumnSortData(
            [in] SColumnSetID* pColID,
            [in] MMC_SORT_SET_DATA* pColSortData
            );

        [helpstring("Retrieve the persisted column sort data for a ColumnSet ID")]
        HRESULT GetColumnSortData(
            [in]  SColumnSetID* pColID,
            [out] MMC_SORT_SET_DATA** ppColSortData
            );
    };

    [
        object,
        uuid(80F94174-FCCC-11d2-B991-00C04F8ECD78),
        helpstring("Interface for displaying an informational message in the result pane"),
        pointer_default(unique)
    ]
    interface IMessageView : IUnknown
    {
        [helpstring("Change the title for the result pane message")]
        HRESULT SetTitleText(
            [in] LPCOLESTR pszTitleText
            );

        [helpstring("Change the text for the result pane message")]
        HRESULT SetBodyText(
            [in] LPCOLESTR pszBodyText
            );

        typedef enum tagIconIdentifier
        {
            Icon_None        =     0,
            Icon_Error       = 32513,
            Icon_Question    = 32514,
            Icon_Warning     = 32515,
            Icon_Information = 32516,

            Icon_First       = Icon_Error,
            Icon_Last        = Icon_Information,
        } IconIdentifier;

        [helpstring("Change the icon for the result pane message")]
        HRESULT SetIcon(
            [in] IconIdentifier id
            );

        [helpstring("Clears the title, text, and icon of the result pane message")]
        HRESULT Clear();
    };


    typedef struct _RDCITEMHDR
    {
        DWORD       dwFlags;        // scope item or result item?
        MMC_COOKIE  cookie;
        LPARAM      lpReserved;
    } RDITEMHDR;

    const DWORD RDCI_ScopeItem = 0x80000000;

    typedef struct _RDCOMPARE
    {
        DWORD       cbSize;         // size of this structure
        DWORD       dwFlags;        // reserved, always 0
        int         nColumn;        // column we're sorting on, maps to in value of
                                    //   IResultDataCompare::Compare's pnResult param
        LPARAM      lUserParam;     // IResultDataCompare::Compare's lUserParam param
        RDITEMHDR*  prdch1;         // first item to compare
        RDITEMHDR*  prdch2;         // second item to compare
    } RDCOMPARE;


    [
        object,
        uuid(96933476-0251-11d3-AEB0-00C04F8ECD78),
        helpstring("Compare interface for sorting items in the result pane"),
        pointer_default(unique)
    ]
    interface IResultDataCompareEx : IUnknown
    {
        [helpstring("Compare items in the result pane")]
        HRESULT Compare([in] RDCOMPARE* prdc, [out] int* pnResult);
    }

cpp_quote("#endif // MMC_VER >= 0x0120")


cpp_quote("#if (MMC_VER >= 0x0200)")
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 2.0 changes
////

typedef enum _MMC_VIEW_TYPE
{
   MMC_VIEW_TYPE_LIST,
   MMC_VIEW_TYPE_HTML,
   MMC_VIEW_TYPE_OCX

} MMC_VIEW_TYPE;

// dwMiscOptions
const DWORD RVTI_MISC_OPTIONS_NOLISTVIEWS                      = 0x0001;

// dwListOptions - similar to MMC_VIEW_OPTIONS
const DWORD RVTI_LIST_OPTIONS_NONE                             = 0x0000;
const DWORD RVTI_LIST_OPTIONS_OWNERDATALIST                    = 0x0002;
const DWORD RVTI_LIST_OPTIONS_MULTISELECT                      = 0x0004;
const DWORD RVTI_LIST_OPTIONS_FILTERED                         = 0x0008;
const DWORD RVTI_LIST_OPTIONS_USEFONTLINKING                   = 0x0020;
const DWORD RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST    = 0x0040;
const DWORD RVTI_LIST_OPTIONS_LEXICAL_SORT                     = 0x0080;
const DWORD RVTI_LIST_OPTIONS_ALLOWPASTE                       = 0x0100;

// dwHTMLOptions
const DWORD RVTI_HTML_OPTIONS_NONE                             = 0x0000;
const DWORD RVTI_HTML_OPTIONS_NOLISTVIEW                       = 0x0001;

// dwOCXOptions
const DWORD RVTI_OCX_OPTIONS_NONE                              = 0x0000;
const DWORD RVTI_OCX_OPTIONS_NOLISTVIEW                        = 0x0001;
const DWORD RVTI_OCX_OPTIONS_CACHE_OCX                         = 0x0002;

typedef struct _RESULT_VIEW_TYPE_INFO
{
    LPOLESTR      pstrPersistableViewDescription;
    MMC_VIEW_TYPE eViewType;
    DWORD         dwMiscOptions;

    [switch_type(MMC_VIEW_TYPE), switch_is((MMC_VIEW_TYPE)eViewType)]
    union
    {

    [case(MMC_VIEW_TYPE_LIST)]
        DWORD dwListOptions;

    [case(MMC_VIEW_TYPE_HTML)]
        struct
        {
            DWORD       dwHTMLOptions; // must be zero for future expansion.
            LPOLESTR    pstrURL;
        };

    [case(MMC_VIEW_TYPE_OCX)]
        struct
        {
            DWORD       dwOCXOptions;
            LPUNKNOWN   pUnkControl;
        };

    [default];
    };
} RESULT_VIEW_TYPE_INFO, *PRESULT_VIEW_TYPE_INFO;



//#######################################################################
//#######################################################################
//
//  Clipboard formats used by the built-in view extension
//
//#######################################################################
//#######################################################################

const wchar_t* CCF_DESCRIPTION  = L"CCF_DESCRIPTION";    // text only
const wchar_t* CCF_HTML_DETAILS = L"CCF_HTML_DETAILS";   // interpreted as HTML


//#######################################################################
//#######################################################################
//
//  struct CONTEXTMENUITEM2: Adds a language independent name.
//
//#######################################################################
//#######################################################################
typedef struct _CONTEXTMENUITEM2
{
    LPWSTR      strName;
    LPWSTR      strStatusBarText;
    LONG        lCommandID;
    LONG        lInsertionPointID;
    LONG        fFlags;
    LONG        fSpecialFlags;
    LPWSTR      strLanguageIndependentName;
} CONTEXTMENUITEM2;

typedef CONTEXTMENUITEM2* LPCONTEXTMENUITEM2;

 //#######################################################################
 //#######################################################################
 //
 //  struct MMC_EXT_VIEW_DATA: definition of a view supplied by a view extension
 //
 //#######################################################################
 //#######################################################################
typedef struct _MMC_EXT_VIEW_DATA
{
    GUID        viewID;             // GUID used to describe the view. Used to restore a view.
    LPCOLESTR   pszURL;             // URL describing extension page
    LPCOLESTR   pszViewTitle;       // title of the view extension
    LPCOLESTR   pszTooltipText;     // tooltip for the tab
    BOOL        bReplacesDefaultView;  // TRUE == no "Normal" tab
} MMC_EXT_VIEW_DATA, *PMMC_EXT_VIEW_DATA;


 //#######################################################################
 //#######################################################################
 //
 //  MMCN_QUERY_PASTE flags: The param is used as out parameter which
 //                          can define below flags.
 //
 //#######################################################################
 //#######################################################################
const DWORD MMC_DEFAULT_OPERATION_COPY           = 0x0001;

    //#######################################################################
    //#######################################################################
    //
    //  The IComponentData2 interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(CCA0F2D2-82DE-41B5-BF47-3B2076273D5C),
        helpstring("IComponentData2 Interface"),
        pointer_default(unique)
    ]
    interface IComponentData2 : IComponentData
    {
        [helpstring("Returns a Dispatch interface which may be used to perform actions for the specified cookie.")]
        HRESULT QueryDispatch([in] MMC_COOKIE cookie, [in] DATA_OBJECT_TYPES type,
                            [out] LPDISPATCH* ppDispatch);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IComponent2 interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(79A2D615-4A10-4ED4-8C65-8633F9335095),
        helpstring("IComponent2 Interface"),
        pointer_default(unique)
    ]
    interface IComponent2 : IComponent
    {
        [helpstring("Returns a Dispatch interface which may be used to perform actions for the specified cookie.")]
        HRESULT QueryDispatch([in] MMC_COOKIE cookie, [in] DATA_OBJECT_TYPES type,
                        [out] LPDISPATCH* ppDispatch);

        [helpstring("Gets the result view type. Supersedes the GetResultViewType method.")]
        HRESULT GetResultViewType2([in] MMC_COOKIE cookie, [in, out] PRESULT_VIEW_TYPE_INFO pResultViewType);

        [helpstring("Restores the result view. Supersedes the MMCN_RESTORE notification")]
        HRESULT RestoreResultView([in] MMC_COOKIE cookie, [in] PRESULT_VIEW_TYPE_INFO pResultViewType);
    };


    //#######################################################################
    //#######################################################################
    //
    //  The IContextMenuCallback2 interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(E178BC0E-2ED0-4b5e-8097-42C9087E8B33),
        helpstring("IContextMenuCallback2 Interface"),
        pointer_default(unique)
    ]
    interface IContextMenuCallback2 : IUnknown
    {
        // returns S_OK if the item was added
        // returns E_INVALIDARG if given a NULL pointer
        // returns E_INVALIDARG if an item already exists with this lCommandID
        // returns E_INVALIDARG if insertion point ID could not be found
        // returns E_INVALIDARG if command ID or insertion point ID is invalid
        // returns E_INVALIDARG if fFlags contains MF_OWNERDRAW or MF_BITMAP
        // returns E_INVALIDARG if an extension attempts to add an item where
        //   fFlags contains MF_SEPARATOR or fSpecialFlags contains CCM_SPECIAL_SEPARATOR
        //   except in submenus created by extensions
        // otherwise an unexpected error occurred
        [helpstring("Adds one item to context menu")]
        HRESULT AddItem([in] CONTEXTMENUITEM2* pItem);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IMMCVersion interface
    //
    //#######################################################################
    //#######################################################################
    [
        uuid(A8D2C5FE-CDCB-4b9d-BDE5-A27343FF54BC),
        helpstring("IMMCVersionInfo Interface"),
    ]
    interface IMMCVersionInfo : IUnknown
    {
       [helpstring("Returns the version information about the installed version of MMC")]
       HRESULT GetMMCVersion([out] long * pVersionMajor, [out] long * pVersionMinor);
    }

    //#######################################################################
    //#######################################################################
    //
    //  The MMCVersion type library
    //
    //#######################################################################
    //#######################################################################
   [
       uuid(9EECDD85-B715-4188-8A72-61159ABDB8C4),
       version(1.0),
       helpstring("MMCVersion Type Library")
   ]
   library MMCVersionLib
   {
       importlib("stdole2.tlb");

       [
          helpstring("MMCVersionInfo coclass"),
          uuid(D6FEDB1D-CF21-4bd9-AF3B-C5468E9C6684)
       ]
       coclass MMCVersionInfo
       {
           [default] interface IMMCVersionInfo;
       };

       [
          helpstring("ConsolePower coclass"),
          uuid(f0285374-dff1-11d3-b433-00c04f8ecd78)
       ]
       coclass ConsolePower
       {
           [default] interface IConsolePower;
       };
   };

    //#######################################################################
    //#######################################################################
    //
    //  The IExtendView interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(89995CEE-D2ED-4c0e-AE5E-DF7E76F3FA53),
        helpstring("IExtendView Interface"),
        pointer_default(unique)
    ]
    interface IExtendView : IUnknown
    {
        [helpstring("Returns the view extension's information")]
        HRESULT GetViews (
            [in]  LPDATAOBJECT              pDataObject,
            [in]  LPVIEWEXTENSIONCALLBACK   pViewExtensionCallback);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IViewExtensionCallback interface
    //
    //#######################################################################
    //#######################################################################
   [
       object,
       uuid(34DD928A-7599-41E5-9F5E-D6BC3062C2DA),
       helpstring("IViewExtensionCallback Interface"),
       pointer_default(unique)
   ]
   interface IViewExtensionCallback : IUnknown
   {
        [helpstring("Adds a view to the result pane")]
        HRESULT AddView([in] PMMC_EXT_VIEW_DATA pExtViewData);
   }

    //#######################################################################
    //#######################################################################
    //
    //  The IConsolePower interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(1cfbdd0e-62ca-49ce-a3af-dbb2de61b068),
        helpstring("IConsolePower Interface"),
        pointer_default(unique)
    ]
    interface IConsolePower : IUnknown
    {
        [helpstring("Sets the execution state for the current thread")]
        HRESULT SetExecutionState ([in] DWORD dwAdd, [in] DWORD dwRemove);

        [helpstring("Resets the given idle timer(s)")]
        HRESULT ResetIdleTimer ([in] DWORD dwFlags);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IConsolePowerSink interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(3333759f-fe4f-4975-b143-fec0a5dd6d65),
        helpstring("IConsolePowerSink Interface"),
        pointer_default(unique)
    ]
    interface IConsolePowerSink : IUnknown
    {
        [helpstring("Handler for WM_POWERBROADCAST notification")]
        HRESULT OnPowerBroadcast (
            [in]  UINT     nEvent,      // power-management event
            [in]  LPARAM   lParam,      // event-specific data
            [out] LRESULT* plReturn);   // event-specific return code
    };


    //#######################################################################
    //#######################################################################
    //
    //  The INodeProperties interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(15BC4D24-A522-4406-AA55-0749537A6865),
        helpstring("INodeProperties Interface"),
        pointer_default(unique)
    ]
    interface INodeProperties : IUnknown
    {
        [helpstring("Returns text-only properties for a node")]
        HRESULT GetProperty([in] LPDATAOBJECT pDataObject, [in] BSTR szPropertyName, [out] PBSTR pbstrProperty);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IConsole3 interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(4F85EFDB-D0E1-498c-8D4A-D010DFDD404F),
        helpstring("IConsole3 Interface"),
        pointer_default(unique)
    ]
    interface IConsole3 : IConsole2
    {
        [helpstring("Puts the specified scope item into rename mode.")]
        HRESULT RenameScopeItem([in] HSCOPEITEM hScopeItem);
    };

    //#######################################################################
    //#######################################################################
    //
    //  The IResultData2 interface
    //
    //#######################################################################
    //#######################################################################
    [
        object,
        uuid(0F36E0EB-A7F1-4a81-BE5A-9247F7DE4B1B),
        helpstring("IResultData2 Interface"),
        pointer_default(unique)
    ]
    interface IResultData2 : IResultData
    {
        [helpstring("Puts the specified result item into rename mode.")]
        HRESULT RenameResultItem([in] HRESULTITEM itemID);
    };

cpp_quote("#endif // MMC_VER >= 0x0200")

cpp_quote("#if (MMC_VER >= 0x0210)")
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 2.1 changes
////

//
// The snap-in can now use some reserved bits in the nState field of
// SCOPEDATAITEM and RESULTDATAITEM
// to set an overlay image to use when displaying the item.  Only these standard
// overlays are available due to limitations in Win32.
//
typedef enum _MMC_ITEM_OVERLAY
{
    MMC_ITEM_OVERLAY_NONE = 0,          // no image
    MMC_ITEM_OVERLAY_ERROR = 1,         // standard error icon  red circle with white X
    MMC_ITEM_OVERLAY_WARNING = 2,       // standard warning icon.  yellow triangle
    MMC_ITEM_OVERLAY_INFO = 3,          // standard info icon.  circle with 'i' in it.
    MMC_ITEM_OVERLAY_BUSY = 4,          // standard wait icon.  hour glass
    MMC_ITEM_OVERLAY_UNAVAILABLE = 5,   // standard offline icon.  Same as busy in messenger
    MMC_ITEM_OVERLAY_SHORTCUT = 6,      // standard shortcut icon
    MMC_ITEM_OVERLAY_RUNNING = 7,       // standard 'play' icon
    MMC_ITEM_OVERLAY_PAUSED = 8,        // standard 'pause' icon
    MMC_ITEM_OVERLAY_STOPPED = 9,       // standard 'stop' icon
    MMC_ITEM_OVERLAY_COMPLETE = 10      // green check.
} MMC_ITEM_OVERLAY;

const DWORD MMC_ITEM_OVERLAY_STATE_MASK = 0x0F00;
const DWORD MMC_ITEM_OVERLAY_STATE_SHIFT = 8;

cpp_quote("#define MMC_OVERLAY_ITEM_INDEX_TO_ITEM_STATE(i) (((i) << MMC_ITEM_OVERLAY_STATE_SHIFT) & MMC_ITEM_OVERLAY_STATE_MASK)")
cpp_quote("#define MMC_OVERLAY_ITEM_INDEX_FROM_ITEM_STATE(state) (((state) & MMC_ITEM_OVERLAY_STATE_MASK) >> MMC_ITEM_OVERLAY_STATE_SHIFT)")

//
// Bit mask to use on the nState field of SCOPEDATAITEM and RESULTDATAITEM
// to read the legacy state information they contain.  For both, this has
// several reserved bits.
//
const DWORD MMC_ITEM_STATE_MASK = 0x00FF;



cpp_quote("#endif // MMC_VER >= 0x0210")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

