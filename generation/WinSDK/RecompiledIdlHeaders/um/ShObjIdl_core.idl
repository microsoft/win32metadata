//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//

cpp_quote("#include <winapifamily.h>")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")


import "objidl.idl";
import "shtypes.idl";
import "servprov.idl";
import "comcat.idl";        // for IEnumGUID
import "propsys.idl";
import "ObjectArray.idl";

cpp_quote("#include <sherrors.h>")

cpp_quote("#ifndef SHSTDAPI")
cpp_quote("#if defined(_SHELL32_)")
cpp_quote("#define SHSTDAPI          STDAPI")
cpp_quote("#define SHSTDAPI_(type)   STDAPI_(type)")
cpp_quote("#else")
cpp_quote("#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE")
cpp_quote("#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE")
cpp_quote("#endif")
cpp_quote("#endif // SHSTDAPI")

cpp_quote("//")
cpp_quote("// IContextMenu interface")
cpp_quote("//")
cpp_quote("// [OverView]")
cpp_quote("//")
cpp_quote("//  The shell uses the IContextMenu interface in following three cases.")
cpp_quote("//")
cpp_quote("// case-1: The shell is loading context menu extensions.")
cpp_quote("//")
cpp_quote("//   When the user clicks the right mouse button on an item within the shell's")
cpp_quote("//  name space (i.g., file, directory, server, work-group, etc.), it creates")
cpp_quote("//  the default context menu for its type, then loads context menu extensions")
cpp_quote("//  that are registered for that type (and its base type) so that they can")
cpp_quote("//  add extra menu items. Those context menu extensions are registered at")
cpp_quote("//  HKCR\{ProgID}\shellex\ContextMenuHandlers.")
cpp_quote("//")
cpp_quote("// case-2: The shell is retrieving a context menu of sub-folders in extended")
cpp_quote("//   name-space.")
cpp_quote("//")
cpp_quote("//   When the explorer's name space is extended by name space extensions,")
cpp_quote("//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu")
cpp_quote("//  objects when it creates context menus for folders under those extended")
cpp_quote("//  name spaces.")
cpp_quote("//")
cpp_quote("// case-3: The shell is loading non-default drag and drop handler for directories.")
cpp_quote("//")
cpp_quote("//   When the user performed a non-default drag and drop onto one of file")
cpp_quote("//  system folders (i.e., directories), it loads shell extensions that are")
cpp_quote("//  registered at HKCR\{ProgID}\DragDropHandlers.")
cpp_quote("//")
cpp_quote("//")
cpp_quote("// [Member functions]")
cpp_quote("//")
cpp_quote("//")
cpp_quote("// IContextMenu::QueryContextMenu")
cpp_quote("//")
cpp_quote("//   This member function may insert one or more menuitems to the specified")
cpp_quote("//  menu (hmenu) at the specified location (indexMenu which is never be -1).")
cpp_quote("//  The IDs of those menuitem must be in the specified range (idCmdFirst and")
cpp_quote("//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the")
cpp_quote("//  'code' field (low word) of the scode.")
cpp_quote("//")
cpp_quote("//   The uFlags specify the context. It may have one or more of following")
cpp_quote("//  flags.")
cpp_quote("//")
cpp_quote("//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default")
cpp_quote("//   action (typically by double-clicking, case 1 and 2 only). Context menu")
cpp_quote("//   extensions (case 1) should not add any menu items, and returns S_OK.")
cpp_quote("//")
cpp_quote("//  CMF_VERBSONLY: The explorer passes this flag if it is constructing")
cpp_quote("//   a context menu for a short-cut object (case 1 and case 2 only). If this")
cpp_quote("//   flag is passed, it should not add any menu-items that is not appropriate")
cpp_quote("//   from a short-cut.")
cpp_quote("//    A good example is the Delete menuitem, which confuses the user")
cpp_quote("//   because it is not clear whether it deletes the link source item or the")
cpp_quote("//   link itself.")
cpp_quote("//")
cpp_quote("//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane")
cpp_quote("//   (case 1 and 2 only). Context menu extensions should ignore this flag.")
cpp_quote("//")
cpp_quote("//   High word (16-bit) are reserved for context specific communications")
cpp_quote("//  and the rest of flags (13-bit) are reserved by the system.")
cpp_quote("//")
cpp_quote("//")
cpp_quote("// IContextMenu::InvokeCommand")
cpp_quote("//")
cpp_quote("//   This member is called when the user has selected one of menuitems that")
cpp_quote("//  are inserted by previous QueryContextMenu member. In this case, the")
cpp_quote("//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -")
cpp_quote("//  idCmdFirst).")
cpp_quote("//")
cpp_quote("//   This member function may also be called programmatically. In such a case,")
cpp_quote("//  lpici->lpVerb specifies the canonical name of the command to be invoked,")
cpp_quote("//  which is typically retrieved by GetCommandString member previously.")
cpp_quote("//")
cpp_quote("//  Parameters in lpci:")
cpp_quote("//    cbSize -- Specifies the size of this structure (sizeof(*lpci))")
cpp_quote("//    hwnd   -- Specifies the owner window for any message/dialog box.")
cpp_quote("//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.")
cpp_quote("//    lpVerb -- Specifies the command to be invoked.")
cpp_quote("//    lpParameters -- Parameters (optional)")
cpp_quote("//    lpDirectory  -- Working directory (optional)")
cpp_quote("//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).")
cpp_quote("//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).")
cpp_quote("//    hIcon -- Specifies the icon (optional).")
cpp_quote("//    hMonitor -- Specifies the default monitor (optional).")
cpp_quote("//")
cpp_quote("//")
cpp_quote("// IContextMenu::GetCommandString")
cpp_quote("//")
cpp_quote("//   This member function is called by the explorer either to get the")
cpp_quote("//  canonical (language independent) command name (uFlags == GCS_VERB) or")
cpp_quote("//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.")
cpp_quote("//  The retrieved canonical string may be passed to its InvokeCommand")
cpp_quote("//  member function to invoke a command programmatically. The explorer")
cpp_quote("//  displays the help texts in its status bar; therefore, the length of")
cpp_quote("//  the help text should be reasonably short (<40 characters).")
cpp_quote("//")
cpp_quote("//  Parameters:")
cpp_quote("//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)")
cpp_quote("//   uFlags -- Either GCS_VERB or GCS_HELPTEXT")
cpp_quote("//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)")
cpp_quote("//   pszName -- Specifies the string buffer.")
cpp_quote("//   cchMax -- Specifies the size of the string buffer.")
cpp_quote("//")
cpp_quote("")
cpp_quote("// QueryContextMenu uFlags")
cpp_quote("#define CMF_NORMAL              0x00000000")
cpp_quote("#define CMF_DEFAULTONLY         0x00000001")
cpp_quote("#define CMF_VERBSONLY           0x00000002")
cpp_quote("#define CMF_EXPLORE             0x00000004")
cpp_quote("#define CMF_NOVERBS             0x00000008")
cpp_quote("#define CMF_CANRENAME           0x00000010")
cpp_quote("#define CMF_NODEFAULT           0x00000020")
cpp_quote("#if (NTDDI_VERSION < NTDDI_VISTA)")
cpp_quote("#define CMF_INCLUDESTATIC       0x00000040")      // deprecated - do not use
cpp_quote("#endif")
cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define CMF_ITEMMENU            0x00000080")
cpp_quote("#endif")
cpp_quote("#define CMF_EXTENDEDVERBS       0x00000100")      // rarely used verbs
cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define CMF_DISABLEDVERBS       0x00000200")
cpp_quote("#endif")
cpp_quote("#define CMF_ASYNCVERBSTATE      0x00000400")      // the verb state can be evaluated asynchronously
cpp_quote("#define CMF_OPTIMIZEFORINVOKE   0x00000800")      // Context menu handlers that do not support invoking verb via canonical verb names (lpVerb)
                                                             // can avoid the work in their QueryContextMenu implementation when this flag is present
cpp_quote("#define CMF_SYNCCASCADEMENU     0x00001000")      // Populate the cascade menu synchronously
cpp_quote("#define CMF_DONOTPICKDEFAULT    0x00002000")      // Tell the context menu to not pick default verb if none is explicitly specified
cpp_quote("#define CMF_RESERVED            0xffff0000")      // View specific
cpp_quote("")
cpp_quote("// GetCommandString uFlags")
cpp_quote("#define GCS_VERBA        0x00000000     // canonical verb")
cpp_quote("#define GCS_HELPTEXTA    0x00000001     // help text (for status bar)")
cpp_quote("#define GCS_VALIDATEA    0x00000002     // validate command exists")
cpp_quote("#define GCS_VERBW        0x00000004     // canonical verb (unicode)")
cpp_quote("#define GCS_HELPTEXTW    0x00000005     // help text (unicode version)")
cpp_quote("#define GCS_VALIDATEW    0x00000006     // validate command exists (unicode)")
cpp_quote("#define GCS_VERBICONW    0x00000014     // icon string (unicode)")
cpp_quote("#define GCS_UNICODE      0x00000004     // for bit testing - Unicode string")
cpp_quote("")
cpp_quote("#ifdef UNICODE")
cpp_quote("#define GCS_VERB        GCS_VERBW")
cpp_quote("#define GCS_HELPTEXT    GCS_HELPTEXTW")
cpp_quote("#define GCS_VALIDATE    GCS_VALIDATEW")
cpp_quote("#else")
cpp_quote("#define GCS_VERB        GCS_VERBA")
cpp_quote("#define GCS_HELPTEXT    GCS_HELPTEXTA")
cpp_quote("#define GCS_VALIDATE    GCS_VALIDATEA")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("#define CMDSTR_NEWFOLDERA   \"NewFolder\"")
cpp_quote("#define CMDSTR_VIEWLISTA    \"ViewList\"")
cpp_quote("#define CMDSTR_VIEWDETAILSA \"ViewDetails\"")
cpp_quote("#define CMDSTR_NEWFOLDERW   L\"NewFolder\"")
cpp_quote("#define CMDSTR_VIEWLISTW    L\"ViewList\"")
cpp_quote("#define CMDSTR_VIEWDETAILSW L\"ViewDetails\"")
cpp_quote("")
cpp_quote("#ifdef UNICODE")
cpp_quote("#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW")
cpp_quote("#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW")
cpp_quote("#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW")
cpp_quote("#else")
cpp_quote("#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA")
cpp_quote("#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA")
cpp_quote("#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA")
cpp_quote("#endif")
cpp_quote("")
cpp_quote("#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY")
cpp_quote("#define CMIC_MASK_ICON          SEE_MASK_ICON") //  not used
cpp_quote("#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI")
cpp_quote("#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE")
cpp_quote("#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE")
cpp_quote("#if (NTDDI_VERSION < NTDDI_VISTA)")
cpp_quote("#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME")
cpp_quote("#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE")
cpp_quote("#endif  // NTDDI_VISTA")
cpp_quote("#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM")
cpp_quote("#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK")
cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define CMIC_MASK_NOASYNC       SEE_MASK_NOASYNC")
cpp_quote("#endif")
cpp_quote("#define CMIC_MASK_SHIFT_DOWN    0x10000000")
cpp_quote("#define CMIC_MASK_CONTROL_DOWN  0x40000000")
cpp_quote("#define CMIC_MASK_FLAG_LOG_USAGE SEE_MASK_FLAG_LOG_USAGE")
cpp_quote("#define CMIC_MASK_NOZONECHECKS  SEE_MASK_NOZONECHECKS")
cpp_quote("#define CMIC_MASK_PTINVOKE      0x20000000")
cpp_quote("#include <pshpack8.h>")
cpp_quote("")

// HMONITOR
cpp_quote("#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)")
cpp_quote("#define HMONITOR_DECLARED")
cpp_quote("DECLARE_HANDLE(HMONITOR);")
cpp_quote("#endif")

//NOTE: When SEE_MASK_HMONITOR is set, hIcon is treated as hMonitor
typedef struct _CMINVOKECOMMANDINFO
{
    DWORD cbSize;        // sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API
    DWORD dwHotKey;
    HANDLE hIcon;
} CMINVOKECOMMANDINFO;

typedef CMINVOKECOMMANDINFO *LPCMINVOKECOMMANDINFO;
typedef const CMINVOKECOMMANDINFO *PCCMINVOKECOMMANDINFO;

typedef struct _CMINVOKECOMMANDINFOEX
{
    DWORD cbSize;            // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;             // any combination of CMIC_MASK_*
    HWND hwnd;               // might be NULL (indicating no owner window)
    LPCSTR lpVerb;           // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters;     // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;      // might be NULL (indicating no specific directory)
    int nShow;               // one of SW_ values for ShowWindow() API
    DWORD dwHotKey;
    HANDLE hIcon;
    LPCSTR lpTitle;         // For CreateProcess-StartupInfo.lpTitle
    LPCWSTR lpVerbW;        // Unicode verb (for those who can use it)
    LPCWSTR lpParametersW;  // Unicode parameters (for those who can use it)
    LPCWSTR lpDirectoryW;   // Unicode directory (for those who can use it)
    LPCWSTR lpTitleW;       // Unicode title (for those who can use it)
    POINT   ptInvoke;       // Point where it's invoked
} CMINVOKECOMMANDINFOEX;

typedef CMINVOKECOMMANDINFOEX *LPCMINVOKECOMMANDINFOEX;
typedef const CMINVOKECOMMANDINFOEX *PCCMINVOKECOMMANDINFOEX;

cpp_quote("#include <poppack.h>")

// IContextMenu
[
    local,
    uuid(000214e4-0000-0000-c000-000000000046), // IID_IContextMenu
    pointer_default(unique),
]
interface IContextMenu : IUnknown
{
    HRESULT QueryContextMenu(
        [in, annotation("_In_")] HMENU hmenu,
        [in, annotation("_In_")] UINT indexMenu,
        [in, annotation("_In_")] UINT idCmdFirst,
        [in, annotation("_In_")] UINT idCmdLast,
        [in, annotation("_In_")] UINT uFlags);

    HRESULT InvokeCommand([in, annotation("_In_")] CMINVOKECOMMANDINFO *pici);

    HRESULT GetCommandString(
        [in, annotation("_In_")] UINT_PTR idCmd,
        [in, annotation("_In_")] UINT uType,
        [in, annotation("_Reserved_")] UINT * pReserved,
        [out, annotation("_Out_writes_bytes_((uType & GCS_UNICODE) ? (cchMax * sizeof(wchar_t)) : cchMax) _When_(!(uType & (GCS_VALIDATEA | GCS_VALIDATEW)), _Null_terminated_)")] CHAR* pszName,
        [in, annotation("_In_")] UINT cchMax);
}

typedef IContextMenu *LPCONTEXTMENU;

// IContextMenu2
[
    local,
    uuid(000214f4-0000-0000-c000-000000000046), // IID_IContextMenu2
    pointer_default(unique),
]
interface IContextMenu2 : IContextMenu
{
    HRESULT HandleMenuMsg(
        [in, annotation("_In_")] UINT uMsg,
        [in, annotation("_In_")] WPARAM wParam,
        [in, annotation("_In_")] LPARAM lParam);
}

typedef IContextMenu2 * LPCONTEXTMENU2;

// IContextMenu3
[
    local,
    uuid(BCFCE0A0-EC17-11d0-8D10-00A0C90F2719), // IID_IContextMenu3
    pointer_default(unique),
]
interface IContextMenu3 : IContextMenu2
{
    HRESULT HandleMenuMsg2(
        [in, annotation("_In_")] UINT uMsg,
        [in, annotation("_In_")] WPARAM wParam,
        [in, annotation("_In_")] LPARAM lParam,
        [out, annotation("_Out_opt_")] LRESULT* plResult);
}

typedef IContextMenu3 * LPCONTEXTMENU3;

// IExecuteCommand
[
    uuid(7F9185B0-CB92-43c5-80A9-92277A4F7B54),
    object,
    pointer_default(unique)
]
interface IExecuteCommand : IUnknown
{
    // key state values MK_CONTROL & MK_SHIFT
    HRESULT SetKeyState([in] DWORD grfKeyState);

    // for context menu invokes this comes from CMINVOKECOMMANDINFO.lpParameters
    HRESULT SetParameters([in, string] LPCWSTR pszParameters);

    // default Position = center of default monitor
    HRESULT SetPosition([in] POINT pt);

    // default = SW_NORMAL
    HRESULT SetShowWindow([in] int nShow);

    // default = FALSE
    HRESULT SetNoShowUI([in] BOOL fNoShowUI);

    // default Directory = GetCurrentDirectory()
    HRESULT SetDirectory([in, string] LPCWSTR pszDirectory);

    // this is where the work happens!
    HRESULT Execute();
}

// IPersistFolder
[
    object,
    uuid(000214EA-0000-0000-C000-000000000046),  // IID_IPersistFolder
    pointer_default(unique),
]
interface IPersistFolder : IPersist
{
    // IShellFolder::BindToObject when it is initializing a shell folder object.")
    // called when the explorer is initializing a shell folder object.
    // pidl -- Specifies the absolute location of the folder
    HRESULT Initialize([in] PCIDLIST_ABSOLUTE pidl);
}

typedef IPersistFolder *LPPERSISTFOLDER;

// IRunnableTask
//
//  object that implement IRunnable must be *free threaded*. It is used for creating
//  objects to be asynchronously executed on a background thread by a task
//  scheduler.  The task scheduler is free to call any method on the
//  IRunnable task on any thread as it sees fit (i.e. a task scheduler is not
//  guaranteed to only have a single background worker thread, nor is it
//  restricted to not call the IRunnableTask methods on the original queuing
//  thread).
//
// Note:
//
//  The Run() member is called by the scheduler to start the task executing.
//  If the task supports being suspended and has been signalled to do so
//  (via receiving a call from the scheduler to Suspend()), it should return
//  from Run() with a value of E_PENDING.  The task will then be held and
//  resumed by the scheduler at a later time by receiving a call to Resume()
//  (assuming it's not destroyed for some reason first).

// IRunnableTask convenient state values
cpp_quote("#define IRTIR_TASK_NOT_RUNNING   0")
cpp_quote("#define IRTIR_TASK_RUNNING       1")
cpp_quote("#define IRTIR_TASK_SUSPENDED     2")
cpp_quote("#define IRTIR_TASK_PENDING       3")
cpp_quote("#define IRTIR_TASK_FINISHED      4")

[
    uuid(85788d00-6807-11d0-b810-00c04fd706ec), // IID_IRunnableTask
    object,
    local
]
interface IRunnableTask : IUnknown
{
    HRESULT Run();

    HRESULT Kill([in, annotation("_In_")] BOOL bWait);

    HRESULT Suspend();

    HRESULT Resume();

    ULONG IsRunning();
}

// IShellTaskScheduler::AddTask()/RemoveTasks()/CountTasks() default arguments
cpp_quote("#define TOID_NULL                    GUID_NULL")
cpp_quote("#define ITSAT_DEFAULT_LPARAM         ((DWORD_PTR)-1)")

// IShellTaskScheduler::AddTask() priorities
// This depends on the cooperation of tasks currently under execution.
// New tasks will be inserted in the queue in priority order. If a task
// of a low priority is currently under execution when a higher priority
// task is added, the scheduler will attempt to suspend the task
// currently under execution. It will be resumed when the other tasks
// have been completed.
cpp_quote("#define ITSAT_DEFAULT_PRIORITY       0x10000000")
cpp_quote("#define ITSAT_MAX_PRIORITY           0x7fffffff")
cpp_quote("#define ITSAT_MIN_PRIORITY           0x00000000")

// IShellTaskScheduler::Status() flags
cpp_quote("#define ITSSFLAG_COMPLETE_ON_DESTROY 0x0000 // wait for the current task to complete before deleting the scheduler")
cpp_quote("#define ITSSFLAG_KILL_ON_DESTROY     0x0001 // kill the current task (if there is one) when the task scheduler is deleted")
cpp_quote("#define ITSSFLAG_FLAGS_MASK          0x0003")

// IShellTaskScheduler::Status() timeouts
cpp_quote("#define ITSS_THREAD_DESTROY_DEFAULT_TIMEOUT  (10*1000)       // default milliseconds until a sleeping worker thread is released")
cpp_quote("#define ITSS_THREAD_TERMINATE_TIMEOUT        (INFINITE)      // set sleeping worker threads to never be released")
cpp_quote("#define ITSS_THREAD_TIMEOUT_NO_CHANGE        (INFINITE - 1)  // no change to the thread timeout")

// interface for interacting with and controlling a task scheduler.
// This interface is free-threaded (since queued tasks can
// interact with the scheduler as well as the main execution
// thread on which the task scheduler was created).
[
    uuid(6CCB7BE0-6807-11d0-B810-00C04FD706EC),
    object,
    local
]
interface IShellTaskScheduler : IUnknown
{
    // Adds Tasks to the scheduler's background queue. The TASKOWNERID allow particular types
    // of tasks to be grouped so that they can be counted or removed. The lParam allows the task
    // to be associated with a particular item (for example an item in a listview).  Thus, all
    // tasks owned by a particular item can be accessed by passing a non default value for this
    // parameter (i.e. to RemoveTasks()).
    HRESULT AddTask(
        [in, annotation("_In_")] IRunnableTask *prt,
        [in, annotation("_In_")] REFTASKOWNERID rtoid,
        [in, annotation("_In_")] DWORD_PTR lParam,
        [in, annotation("_In_")] DWORD dwPriority);

    // Removes tasks from the scheduler's queue. These can be sepcified in terms of their TASKOWNERID
    // or their LPARAM, or both, or neither (TOID_NULL && ITSAT_DEFAULT_LPARAM results in all tasks being
    // removed). If a task that matches is currently running and ITaskScheduler::Status() has been
    // passeed ITSSFLAG_KILL_ON_DESTROY then the scheduler will attempt to kill the current task. The
    // fWaitIfRunning parameter is then passed to IRunnableTask::Kill().
    HRESULT RemoveTasks(
        [in, annotation("_In_")] REFTASKOWNERID rtoid,
        [in, annotation("_In_")] DWORD_PTR lParam,
        [in, annotation("_In_")] BOOL bWaitIfRunning);

    // returns the count of tasks in the queue depending upon the TASKOWNERID and the LPARAM passed.
    // pass TOID_NULL to count all tasks in the queue
    UINT CountTasks([in, annotation("_In_")] REFTASKOWNERID rtoid);

    // This sets the ReleaseStatus for the current task and the background thread timeout. When
    // ITaskScheduler::RemoveTasks() is called and there is a task currently running that matches
    // ITSSFLAG_COMPLETE_ON_DESTROY will cause TRUE to be passed to the task's IRunnableTask::Kill().
    // The dwThreadTimeout parameter if not set to the default will cause the background thread to
    // die if no new tasks have been added to the queue in the timeout period. The Thread will be
    // recreated when the next new task is added.
    HRESULT Status(
        [in, annotation("_In_")] DWORD dwReleaseStatus,
        [in, annotation("_In_")] DWORD dwThreadTimeout);
}

cpp_quote("#define SID_ShellTaskScheduler IID_IShellTaskScheduler")

// IPersistFolder2
[
    object,
    uuid(1AC3D9F0-175C-11d1-95BE-00609797EA4F),  // IID_IPersistFolder2
    pointer_default(unique),
]
interface IPersistFolder2 : IPersistFolder
{
    HRESULT GetCurFolder([out] PIDLIST_ABSOLUTE *ppidl);
}

cpp_quote("#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY")

// DESCRIPTION: PERSIST_FOLDER_TARGET_INFO
//    This stucture is used for Folder Shortcuts which allow the shell to
// have a file system folder act like another area in the name space.
// One of pidlTargetFolder, szTargetParsingName, or csidl needs to
// specify the destination name space.
//
// pidlTargetFolder: This is a full pidl to the target folder.  Can be NULL in the IPersistFolder3::InitializeEx()
//                   call but not in the GetFolderTargetInfo() return structure.
// szTargetParsingName: Empty string if not specified. Ortherwise, it is the parsible name
//                       to the target.  This name can be parsed by IShellFolder::
//                       ParsedName() from the desktop.
// szNetworkProvider: Can be an empty string.  If not empty, it specifies the type of network
//                    provider that will be used when binding to the target.  This is used
//                    for performance optimizations for the WNet APIs.
// dwAttributes: -1 if not known.  These are the SFGAO_ flags for IShellFolder::GetAttributesOf()
// csidl: This is -1 if it's not used.  This can be used instead of pidlTargetFolder or
//        szTargetParsingName to indicate the TargetFolder.  See the list of CSIDL_ folders
//        below.  CSIDL_FLAG_PFTI_TRACKTARGET means that the IShellFolder's target folder
//        should change if the user changes the target of the underlying CSIDL value.
//        You can also pass CSIDL_FLAG_CREATE to indicate that the target folder
//        should be created if it does not exist.  No other CSIDL_FLAG_* values are supported.

cpp_quote("#include <pshpack8.h>")

#ifndef MAX_PATH
#define MAX_PATH 260
#endif

typedef struct _PERSIST_FOLDER_TARGET_INFO
{
    PIDLIST_ABSOLUTE pidlTargetFolder;              // pidl for the folder we want to intiailize
    WCHAR            szTargetParsingName[MAX_PATH]; // optional parsing name for the target
    WCHAR            szNetworkProvider[MAX_PATH];   // optional network provider
    DWORD            dwAttributes;                  // optional FILE_ATTRIBUTES_ flags (-1 if not used)
    int              csidl;                         // optional folder index (SHGetFolderPath()) -1 if not used
} PERSIST_FOLDER_TARGET_INFO;

cpp_quote("#include <poppack.h>")


// DESCRIPTION: IPersistFolder3
//    This interface is implemented by an IShellFolder object that wants non-default
// handling of Folder Shortcuts.  In general, shell name space extensions should use
// pidlRoot (the alias pidl) as their location in the name space and pass it to public
// APIs, such as ShellExecute().  The one exception is that pidlTarget should be used
// when sending ChangeNotifies or registering to listen for change notifies
// (see SFVM_GETNOTIFY).
//
// InitializeEx: This method initializes an IShellFolder and specifies where
//               it is rooted in the name space.
//      pbc: May be NULL.
//      pidlRoot: This is the same parameter as IPersistFolder::Initialize(). Caller allocates
//                and frees this parameter.
//      ppfti: May be NULL, in which case this is the same as a call to IPersistFolder::Initialize().
//             Otherwise this is a Folder Shortcut and this structure specifies the target
//             folder and it's attributes.
// GetFolderTargetInfo: This is used by the caller to find information about
//             the folder shortcut.  This structure may not be initialized by the caller,
//             so the callee needs to initialize every member.  The callee allocates
//             pidlTargetFolder and the caller will free it.  Filling in pidlTargetFolder is
//             ALWAYS required.
[
    object,
    uuid(CEF04FDF-FE72-11d2-87A5-00C04F6837CF),  // IID_IPersistFolder3
    pointer_default(unique),
]
interface IPersistFolder3 : IPersistFolder2
{
    HRESULT InitializeEx(
        [in, unique] IBindCtx *pbc,
        [in] PCIDLIST_ABSOLUTE pidlRoot,
        [in, unique] const PERSIST_FOLDER_TARGET_INFO *ppfti);

    HRESULT GetFolderTargetInfo([out] PERSIST_FOLDER_TARGET_INFO *ppfti);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)")

[
    object,
    uuid(1079acfc-29bd-11d3-8e0d-00c04f6837d5),  // IID_IPersistIDList
    pointer_default(unique),
]
interface IPersistIDList : IPersist
{
    // sets or gets a fully qualifed idlist for an object
    HRESULT SetIDList([in] PCIDLIST_ABSOLUTE pidl);

    HRESULT GetIDList([out] PIDLIST_ABSOLUTE *ppidl);
}

cpp_quote("#endif  // NTDDI_WINXP|| (_WIN32_IE >= _WIN32_IE_IE70)")

[
    uuid(000214F2-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IEnumIDList : IUnknown
{
    [local] HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched), annotation("_Out_writes_to_(celt, *pceltFetched)")] PITEMID_CHILD *rgelt,
        [out, annotation("_Out_opt_ _Deref_out_range_(0, celt)")] ULONG *pceltFetched);

    [call_as(Next)] HRESULT RemoteNext([in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] PITEMID_CHILD *rgelt,
        [out] ULONG* pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumIDList **ppenum);
}

typedef IEnumIDList *LPENUMIDLIST;

[
    uuid(d0191542-7954-4908-bc06-b2360bbe45ba),
    object,
    pointer_default(unique)
]
interface IEnumFullIDList : IUnknown
{
    [local]
    HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched), annotation("_Out_writes_to_(celt, *pceltFetched)")] PIDLIST_ABSOLUTE *rgelt,
        [out, annotation("_Out_opt_ _Deref_out_range_(0, celt)")] ULONG *pceltFetched);

    [call_as(Next)]
    HRESULT RemoteNext(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] PIDLIST_ABSOLUTE *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumFullIDList **ppenum);
}

// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
[v1_enum] enum _SHGDNF
{
    SHGDN_NORMAL             = 0x0000,  // default (display purpose)
    SHGDN_INFOLDER           = 0x0001,  // displayed under a folder (relative)
    SHGDN_FOREDITING         = 0x1000,  // for in-place editing
    SHGDN_FORADDRESSBAR      = 0x4000,  // UI friendly parsing name (remove ugly stuff)
    SHGDN_FORPARSING         = 0x8000,  // parsing name for ParseDisplayName()
};
typedef DWORD SHGDNF;

// IShellFolder::EnumObjects grfFlags bits
[v1_enum] enum _SHCONTF
{
    SHCONTF_CHECKING_FOR_CHILDREN   = 0x00000010,   // hint that client is checking if (what) child items the folder contains - not all details (e.g. short file name) are needed
    SHCONTF_FOLDERS                 = 0x00000020,   // only want folders enumerated (SFGAO_FOLDER)
    SHCONTF_NONFOLDERS              = 0x00000040,   // include non folders (items without SFGAO_FOLDER)
    SHCONTF_INCLUDEHIDDEN           = 0x00000080,   // show items normally hidden (items with SFGAO_HIDDEN)
    SHCONTF_INIT_ON_FIRST_NEXT      = 0x00000100,   // DEFUNCT - this is always assumed
    SHCONTF_NETPRINTERSRCH          = 0x00000200,   // hint that client is looking for printers
    SHCONTF_SHAREABLE               = 0x00000400,   // hint that client is looking sharable resources (local drives or hidden root shares)
    SHCONTF_STORAGE                 = 0x00000800,   // include all items with accessible storage and their ancestors including hidden items
    SHCONTF_NAVIGATION_ENUM         = 0x00001000,   // mark child folders to indicate that they should provide a "navigation" enumeration by default
    SHCONTF_FASTITEMS               = 0x00002000,   // hint that client is only interested in items that can be enumerated quickly
    SHCONTF_FLATLIST                = 0x00004000,   // enumerate items as flat list even if folder is stacked
    SHCONTF_ENABLE_ASYNC            = 0x00008000,   // inform enumerator that client is listening for change notifications so enumerator does not need to be complete, items can be reported via change notifications
    SHCONTF_INCLUDESUPERHIDDEN      = 0x00010000,   // show system items that are hidden
};
typedef DWORD SHCONTF;


// IShellFolder::CompareIDs lParam flags
// *these should only be used if the folder supports IShellFolder2*
//
// SHCIDS_ALLFIELDS
//
// only be used in conjunction with SHCIDS_CANONCALONLY or column 0.
// This flag requests that the folder test for *pidl identity*, that is
// "are these pidls logically the same". This implies that cached fields
// in the pidl that would distinguish them should be tested.
// Without this flag, you are comparing the *object* s the pidls refer to.
//
// SHCIDS_CANONICALONLY
//
// This indicates that the sort should be *the most efficient sort possible*, the implication
// being that the result will not be displayed to the UI: the SHCIDS_COLUMNMASK portion
// of the lParam can be ignored. (Before we had SHCIDS_CANONICALONLY
// we assumed column 0 was the "efficient" sort column.)
//
//

cpp_quote("#define SHCIDS_ALLFIELDS        0x80000000L")
cpp_quote("#define SHCIDS_CANONICALONLY    0x10000000L")
cpp_quote("#define SHCIDS_BITMASK          0xFFFF0000L")
cpp_quote("#define SHCIDS_COLUMNMASK       0x0000FFFFL")

// IShellFolder::GetAttributesOf flags
// SFGAO_CANLINK: If this bit is set on an item in the shell folder, a
//            'Create Shortcut' menu item will be added to the File
//            menu and context menus for the item.  If the user selects
//            that command, your IContextMenu::InvokeCommand() will be called
//            with 'link'.
//                 That flag will also be used to determine if 'Create Shortcut'
//            should be added when the item in your folder is dragged to another
//            folder.
cpp_quote("#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied    (0x1)")
cpp_quote("#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved     (0x2)")
cpp_quote("#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked    (0x4)")
cpp_quote("#define SFGAO_STORAGE           0x00000008L     // supports BindToObject(IID_IStorage)")
cpp_quote("#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed")
cpp_quote("#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted")
cpp_quote("#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets")
//         unused                          0x00000080
cpp_quote("#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target")
cpp_quote("#define SFGAO_CAPABILITYMASK    0x00000177L")
//         unused                          0x00000200
//         unused                          0x00000400
cpp_quote("#define SFGAO_PLACEHOLDER       0x00000800L     // File or folder is not fully present and recalled on open or access")
cpp_quote("#define SFGAO_SYSTEM            0x00001000L     // System object")
cpp_quote("#define SFGAO_ENCRYPTED         0x00002000L     // Object is encrypted (use alt color)")
cpp_quote("#define SFGAO_ISSLOW            0x00004000L     // 'Slow' object")
cpp_quote("#define SFGAO_GHOSTED           0x00008000L     // Ghosted icon")
cpp_quote("#define SFGAO_LINK              0x00010000L     // Shortcut (link)")
cpp_quote("#define SFGAO_SHARE             0x00020000L     // Shared")
cpp_quote("#define SFGAO_READONLY          0x00040000L     // Read-only")
cpp_quote("#define SFGAO_HIDDEN            0x00080000L     // Hidden object")
cpp_quote("#define SFGAO_DISPLAYATTRMASK   0x000FC000L")
cpp_quote("#define SFGAO_FILESYSANCESTOR   0x10000000L     // May contain children with SFGAO_FILESYSTEM")
cpp_quote("#define SFGAO_FOLDER            0x20000000L     // Support BindToObject(IID_IShellFolder)")
cpp_quote("#define SFGAO_FILESYSTEM        0x40000000L     // Is a win32 file system object (file/folder/root)")
cpp_quote("#define SFGAO_HASSUBFOLDER      0x80000000L     // May contain children with SFGAO_FOLDER (may be slow)")
cpp_quote("#define SFGAO_CONTENTSMASK      0x80000000L")
cpp_quote("#define SFGAO_VALIDATE          0x01000000L     // Invalidate cached information (may be slow)")
cpp_quote("#define SFGAO_REMOVABLE         0x02000000L     // Is this removeable media?")
cpp_quote("#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)")
cpp_quote("#define SFGAO_BROWSABLE         0x08000000L     // Supports IShellFolder, but only implements CreateViewObject() (non-folder view)")
cpp_quote("#define SFGAO_NONENUMERATED     0x00100000L     // Is a non-enumerated object (should be hidden)")
cpp_quote("#define SFGAO_NEWCONTENT        0x00200000L     // Should show bold in explorer tree")
cpp_quote("#define SFGAO_CANMONIKER        0x00400000L     // Obsolete")
cpp_quote("#define SFGAO_HASSTORAGE        0x00400000L     // Obsolete")
cpp_quote("#define SFGAO_STREAM            0x00400000L     // Supports BindToObject(IID_IStream)")
cpp_quote("#define SFGAO_STORAGEANCESTOR   0x00800000L     // May contain children with SFGAO_STORAGE or SFGAO_STREAM")
cpp_quote("#define SFGAO_STORAGECAPMASK    0x70C50008L     // For determining storage capabilities, ie for open/save semantics")
cpp_quote("#define SFGAO_PKEYSFGAOMASK     0x81044000L     // Attributes that are masked out for PKEY_SFGAOFlags because they are considered to cause slow calculations or lack context (SFGAO_VALIDATE | SFGAO_ISSLOW | SFGAO_HASSUBFOLDER and others)")

typedef ULONG SFGAOF;

typedef [v1_enum] enum SYNC_TRANSFER_STATUS
{
    STS_NONE                   = 0x00000000,  // No sync activity
    STS_NEEDSUPLOAD            = 0x00000001,  // The file is pending upload
    STS_NEEDSDOWNLOAD          = 0x00000002,  // The file is pending download
    STS_TRANSFERRING           = 0x00000004,  // The file is currently transferring (up or down)
    STS_PAUSED                 = 0x00000008,  // The current transfer is paused
    STS_HASERROR               = 0x00000010,  // An error was encountered on the last sync
    STS_FETCHING_METADATA      = 0x00000020,  // Sync engine is fetching metadata from cloud.  Only found on the root folder.
    STS_USER_REQUESTED_REFRESH = 0x00000040,  // Sync engine is performing a user-requested refresh.  Only found on the root folder.
    STS_HASWARNING             = 0x00000080,  // An error was encountered on the last sync
    STS_EXCLUDED               = 0x00000100,  // The file won't be synced by the sync engine
    STS_INCOMPLETE             = 0x00000200,  // The reported state may be missing states due to indexing delays
    STS_PLACEHOLDER_IFEMPTY    = 0x00000400,  // If the folder is empty, treat it as a dehydrated item (placeholder)
} SYNC_TRANSFER_STATUS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SYNC_TRANSFER_STATUS)")

typedef [v1_enum] enum STORAGE_PROVIDER_FILE_FLAGS
{
    SPFF_NONE                       = 0x00000000,
    SPFF_DOWNLOAD_BY_DEFAULT        = 0x00000001,   // Sync engine intends to download new files by default when specified on a parent folder
    SPFF_CREATED_ON_THIS_DEVICE     = 0x00000002,   // Sync engine identifies this file or folder as locally created
} STORAGE_PROVIDER_FILE_FLAGS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(STORAGE_PROVIDER_FILE_FLAGS)")

// Specifies the states a placeholder file can have.
// Retrieve this value using PKEY_FilePlaceholderStatus (System.FilePlaceholderStatus)
typedef [v1_enum] enum PLACEHOLDER_STATES
{
    PS_NONE                            = 0x00000000,
    PS_MARKED_FOR_OFFLINE_AVAILABILITY = 0x00000001, // may already be or eventually will be available offline.
    PS_FULL_PRIMARY_STREAM_AVAILABLE   = 0x00000002, // The primary stream has been made fully available.
    PS_CREATE_FILE_ACCESSIBLE          = 0x00000004, // (deprecated, same as PS_FULL_PRIMARY_STREAM_AVAILABLE)
    PS_CLOUDFILE_PLACEHOLDER           = 0x00000008, // Placeholder was created by the cloud files api
    // Bitmask for default value set that can be returned for local files
    PS_DEFAULT                         = PS_MARKED_FOR_OFFLINE_AVAILABILITY | PS_FULL_PRIMARY_STREAM_AVAILABLE | PS_CREATE_FILE_ACCESSIBLE,

    // Bitmask for all valid status flags
    PS_ALL                             = PS_MARKED_FOR_OFFLINE_AVAILABILITY | PS_FULL_PRIMARY_STREAM_AVAILABLE | PS_CREATE_FILE_ACCESSIBLE | PS_CLOUDFILE_PLACEHOLDER,
} PLACEHOLDER_STATES;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(PLACEHOLDER_STATES)")

// To associate an application as a conflict resolution handler for a file, update the following key in that file's
// extrinsic named property store.  To update the key, bind through GPS_EXTRINSICPROPERTIES and use the INamedPropertyStore
// interface to set the key to the CLSID of the out of proc com object implementing IFileSyncMergeHandler.

cpp_quote("#define CONFLICT_RESOLUTION_CLSID_KEY L\"ConflictResolutionCLSID\"")

typedef [v1_enum] enum MERGE_UPDATE_STATUS
{
    MUS_COMPLETE,
    MUS_USERINPUTNEEDED,
    MUS_FAILED,
} MERGE_UPDATE_STATUS;

// Handlers that implement this interface must also register the component category value CATID_FilePlaceholderMergeHandler.
[
    uuid(d97b5aac-c792-433c-975d-35c4eadc7a9d),
    object,
    pointer_default(unique)
]
interface IFileSyncMergeHandler : IUnknown
{
    HRESULT Merge([in, string] LPCWSTR localFilePath, [in, string] LPCWSTR serverFilePath, [out, retval] MERGE_UPDATE_STATUS *updateStatus);
    HRESULT ShowResolveConflictUIAsync([in] LPCWSTR localFilePath, [in] HMONITOR monitorToDisplayOn);
}

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to CFolderShortcut, IShellLink::Resolve will be invoked on the shortcut
// during the bind operation. This will result in slowness for shortcuts pointing to network paths.
cpp_quote("#define STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE   L\"Force Folder Shortcut Resolve\"")

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to CFSFolder, CFSFolder::_CheckDriveRestriction will not check to see
// if the drive it is on is restricted by SHRestriction(REST_NOVIEWONDRIVE) when someone tries
// to CreateViewObject() on it. This is utilized when this folder is being used as a CD burning staging area
// folder, and is not meant to be restricted because of this policy being applied to the drive that
// the staging area folder happens to reside on. This policy is NOT a security policy, and thus this
// is not a security breach. This flag is only sent by the CD folder when creating the IShellFolder for
// the staging area part of the merged folder view, and thus this parameter's existence will not prevent
// the policy from being implemented correctly when the CD drive itself has the group policy applied to it.
cpp_quote("#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L\"Avoid Drive Restriction Policy\"")

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to CFSFolder, CFSFolder::_CheckDriveRestriction will not check to see
// if the drive it is on is restricted by SHRestriction(REST_NOVIEWONDRIVE) when someone tries
// to CreateViewObject() on it. This is utilized when this folder is being used as a CD burning staging area
// folder, and is not meant to be restricted because of this policy being applied to the drive that
// the staging area folder happens to reside on. This policy is NOT a security policy, and thus this
// is not a security breach. This flag is only sent by the CD folder when creating the IShellFolder for
// the staging area part of the merged folder view, and thus this parameter's existence will not prevent
// the policy from being implemented correctly when the CD drive itself has the group policy applied to it.
cpp_quote("#define STR_AVOID_DRIVE_RESTRICTION_POLICY   L\"Avoid Drive Restriction Policy\"")

//      passed to ISF::ParseDisplayName() or ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * IPersist must be supported by the ObjectParam
// the CLSID returned by IPersist::GetCLSID() should be skipped
// in the binding process. used to avoid loops or to allow delegation to
// base name space functionality. see SHSkipJunction()
cpp_quote("#define STR_SKIP_BINDING_CLSID      L\"Skip Binding CLSID\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// instructing to prefer folder support for URLs.  specifically used by the common
// dialog to make it use the DAV NP when parsing http: URLs.
cpp_quote("#define STR_PARSE_PREFER_FOLDER_BROWSING     L\"Parse Prefer Folder Browsing\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// instructing to fail parsing relative paths.  only succeeds for fully qualified paths/urls.
// * no interface support required on object param
//
//      eg. even if "file.txt" is a child of the desktop, it will still fail
//  but it will succeed for "C:\Documents and Settings\Username\Desktop\file.txt"
cpp_quote("#define STR_DONT_PARSE_RELATIVE              L\"Don't Parse Relative\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// to try translate from a full file system pidl to a alias to that pidl, if available.
// * no interface support required on object param
//
//      eg.  if you pass the following path "C:\Documents and Settings\Username\Desktop\file.txt"
// if TRANSLATE is SET result is: [file.txt] (the alias for the desktop being an empty pidl)
// if TRANSLATE is NOT SET result is: [CLSID_MyComputer][c:\][Documents and Settings][Username][Desktop][file.txt].
cpp_quote("#define STR_PARSE_TRANSLATE_ALIASES          L\"Parse Translate Aliases\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// to disable the cache of network resources when parsing a name.  The cache is still
// populated with the results of the parse, however we skip the initial query.
cpp_quote("#define STR_PARSE_SKIP_NET_CACHE             L\"Skip Net Resource Cache\"")

// * no interface support required on object param
// instructing to allow shell: parsing to non-SFGAO_FOLDER objects.
// Safe to set this for strings an end-user types, but do not set this in any binding
// path where untrusted callers control the contents of the string
cpp_quote("#define STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS     L\"Parse Shell Protocol To File Objects\"")

cpp_quote("#if (_WIN32_IE >= 0x0700)")
//      passed to IPersistFolder3->Initialize() via IBindCtx::RegisterObjectParam()
// Instructs the folder to track the location of the CLSID.  Currently dbfolder uses this to track the pivot of the
// regitem folder that aggregates it.
cpp_quote("#define STR_TRACK_CLSID                      L\"Track the CLSID\"")

//      passed to IPersistHistory::LoadHistory() to enable loading the history from a stream
// for an internal navigaton.  An internal navigation is a navigation within the same view.
cpp_quote("#define STR_INTERNAL_NAVIGATE                L\"Internal Navigation\"")

//      used to passed parsed properties to IShellFolder::ParseDisplayName for a delegate namespace.
//  the namespace can use this instead of attempting to parse the name itself
cpp_quote("#define STR_PARSE_PROPERTYSTORE             L\"DelegateNamedProperties\"")

//      passed to IShellFolder::ParseDisplayName() via IBindCtx::RegisterObjectParam()
// instructing to not fail parsing filenames with invalid characters.
// Meaningful only in conjunction with STR_FILE_SYS_BIND_DATA
// * no interface support required on object param
cpp_quote("#define STR_NO_VALIDATE_FILENAME_CHARS      L\"NoValidateFilenameChars\"")

// passed to ISF::BindToObject via IBindCtx::RegisterObjectParam()
// registered object must either implement ICreateObject or ISafeCreateObject
cpp_quote("#define STR_BIND_DELEGATE_CREATE_OBJECT L\"Delegate Object Creation\"")

cpp_quote("#define STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS   L\"Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING\"")
cpp_quote("#define STR_PARSE_PREFER_WEB_BROWSING   L\"Do not bind to Internet shell folder handlers\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// Instructs folders that manipulate network paths to show the network diagnostics UI when they
// encounter diagnosable failures.  If diagnosis succeeds, then the folder will try to parse the
// path again.  If parsing fails even after diagnosis, an appropriate error value will be returned.
// * no interface support required on object param
cpp_quote("#define STR_PARSE_SHOW_NET_DIAGNOSTICS_UI  L\"Show network diagnostics UI\"")

// deprecated
cpp_quote("#define STR_PARSE_DONT_REQUIRE_VALIDATED_URLS  L\"Do not require validated URLs\"")

// This should be used when STR_PARSE_PREFER_FOLDER_BROWSING is included in the BindCtx
// and the client desires the Internet shell folder handlers to generate an IDList for any valid URL
// if a DAV-type folder cannot be created for the given URL.  Specifically used by the common dialog
// to support opening files on the internet.
// This does not ensure that the URL actually exists.  It only checks the syntax of the URL and
// that it has a registered protocol handler.
// * no interface support required on object param
cpp_quote("#define STR_INTERNETFOLDER_PARSE_ONLY_URLMON_BINDABLE  L\"Validate URL\"")

cpp_quote("#endif // _WIN32_IE >= 0x0700")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")

// passed to BIND_OPTS.dwTickCountDeadline to indicate that use of the stream can be interrupted
// if other clients are trying to access the file in an incompatible manner
cpp_quote("#define BIND_INTERRUPTABLE 0xFFFFFFFF")

cpp_quote("#endif // NTDDI_WIN8")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN7)")

// Passed to IShellFolder::ParseDisplayName along with STR_FILE_SYS_BIND_DATA. This forces simple
// parsing while also probing for desktop.ini files along the path to get a localized name string
// if there's any. The advantage is not probing for folders along the path. A folder might be a
// server or a share, so it may be very expensive. On the other hand, desktop.inis are cached in
// at least some locations, so it will be as cheap or cheaper than probling for folders attribs and
// then probing for desktop.ini if hte folder is read only.
cpp_quote("#define STR_BIND_FOLDERS_READ_ONLY L\"Folders As Read Only\"")

// Passed to IShellFolder::ParseDisplayName with an FOLDER_ENUM_MODE value to control
// the enumeration mode of the parsed item.  The FOLDER_ENUM_MODE is passed in the bind
// context via an object that implements IObjectWithFolderEnumMode.
//
// Items with different enumeration modes compare canonically (SHCIDS_CANONICALONLY) different
// because they enumerate different sets of items.
//
// If an item doesn't support the enumeration mode value (because it isn't a folder or it doesn't
// provide the enumeration mode) then it is created in the default enumeration mode.
cpp_quote("#define STR_BIND_FOLDER_ENUM_MODE L\"Folder Enum Mode\"")

typedef [v1_enum] enum FOLDER_ENUM_MODE
{
    FEM_VIEWRESULT    = 0, // main enumeration mode. default enumeration for a folder view, etc.
    FEM_NAVIGATION    = 1, // alternate enumeration mode for navigating folder's content. default enumeration for a navigation pane, etc.
} FOLDER_ENUM_MODE;

[
    uuid(6a9d9026-0e6e-464c-b000-42ecc07de673),
    object,
    pointer_default(unique)
]
interface IObjectWithFolderEnumMode : IUnknown
{
    HRESULT SetMode([in] FOLDER_ENUM_MODE feMode);
    HRESULT GetMode([out] FOLDER_ENUM_MODE *pfeMode);
}

// Passed to IShellFolder::ParseDisplayName
// The IDList returned should be bound to the provided Progid's association handler.
cpp_quote("#define STR_PARSE_WITH_EXPLICIT_PROGID L\"ExplicitProgid\"")

// pass to IShellFolder::ParseDisplayName
// The IDList returned should be bound to the provided Application's association handler.
cpp_quote("#define STR_PARSE_WITH_EXPLICIT_ASSOCAPP L\"ExplicitAssociationApp\"")

// returned from IShellFolder::ParseDisplayName
// The returned IDList was bound to the Progid specified with STR_PARSE_WITH_EXPLICIT_PROGID or the application specified
// with STR_PARSE_WITH_EXPLICIT_ASSOCAPP.  When absent, the Progid or Application was not bound into the IDList.
cpp_quote("#define STR_PARSE_EXPLICIT_ASSOCIATION_SUCCESSFUL L\"ExplicitAssociationSuccessful\"")


// IShellFolder IBindCtx parameter: "ParseAndCreateItem"
//
// The IUnknown for this is accessed through IBindCtx::RegisterObjectParam/GetObjectParam.
//
// Data sources should support this bind context parameter in their IShellFolder::ParseDisplayName
// implementations, in order to optimize the behavior of SHCreateItemFromParsingName().  Normally,
// SHCreateItemFromParsingName must perform two binds to the name that is parsed: one to parse via
// IShellFolder::ParseDisplayName(), and a subsequent bind to create the ShellItem.
// Supporting this bind context parameter in the data source avoids the second bind.  It does so
// because the first bind (during ParseDisplayName) will create the ShellItem at the same time and
// stash it away via IParseAndCreateItem::SetItem.  SHCreateItemFromParsingName() then uses that ShellItem
// instead of creating one via SHCreateItemFromIDList().
//
// This parameter applies to the last element of the name that is parsed (c:\folder\file.txt,
// data applies to file.txt).

cpp_quote("#define STR_PARSE_AND_CREATE_ITEM    L\"ParseAndCreateItem\"")

// This bind context parameter is a property bag (IPropertyBag) used to pass
// VARIANT values in the bind context.
cpp_quote("#define STR_PROPERTYBAG_PARAM   L\"SHBindCtxPropertyBag\"")

// This bind context parameter enables passing the SHCONTF value to
// IShellFolder::EnumObjects() when calling IShellItem::BindToHandler(..., BHID_EnumItems, ...).
// This is stored as a DWORD in the STR_PROPERTYBAG_PARAM property bag.
cpp_quote("#define STR_ENUM_ITEMS_FLAGS    L\"SHCONTF\"")

// This bind context parameter enables passing the STORAGEITEM_CREATION_FLAGS value to
// IShellItem::BindToHandler(..., BHID_StorageItem, ...).
// This is stored as a DWORD in the STR_PROPERTYBAG_PARAM property bag.
cpp_quote("#define STR_STORAGEITEM_CREATION_FLAGS    L\"SHGETSTORAGEITEM\"")

interface IShellItem;

[
    object,
    uuid(67efed0e-e827-4408-b493-78f3982b685c),
    pointer_default(unique),
    local
]
interface IParseAndCreateItem : IUnknown
{
    HRESULT SetItem([in] IShellItem *psi);
    HRESULT GetItem([in] REFIID riid, [out, iid_is(riid)] void **ppv);      // Returns IShellItem
}

// IShellFolder IBindCtx parameter: "ItemCacheContext"
//
// The IUnknown for this is accessed through IBindCtx::RegisterObjectParam/GetObjectParam.
// The implementation should be a separate BindContext object.
//
// Data sources should support this bind context parameter in their IShellFolder::ParseDisplayName
// and IPersistFolder3::InitializeEx implementations, in order to cache expensive
// helper objects that can live across instantiations of shell items (instead of re-creating these
// internal objects each time a shell item is created).
//
// A caller must opt-in to this behavior by providing this bind context parameter when calling
// SHCreateItemFromParsingName(), to optimize the behavior of binding to multiple parsing
// names in succession.  The lifetime of this object should span across multiple instances
// of shell items and their individual bind contexts.

cpp_quote("#define STR_ITEM_CACHE_CONTEXT       L\"ItemCacheContext\"")

cpp_quote("#endif // NTDDI_VERSION >= NTDDI_WIN7")

interface IShellFolder;
[
    uuid(000214E6-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]

interface IShellFolder : IUnknown
{
midl_pragma warning (disable: 2495) // annotation is allowed on local interface and local methods only

    HRESULT ParseDisplayName(
        [in, unique] HWND hwnd,
        [in, unique] IBindCtx *pbc,
        [in, string] LPWSTR pszDisplayName,
        [in, out, unique, annotation("_Reserved_")] ULONG *pchEaten,
        [out] PIDLIST_RELATIVE *ppidl,
        [in, out, unique] ULONG *pdwAttributes);

midl_pragma warning (default: 2495)

    HRESULT EnumObjects(
        [in, unique] HWND hwnd,
        [in] SHCONTF grfFlags,
        [out] IEnumIDList **ppenumIDList);

    // returns an instance of a sub-folder which is specified by the IDList (pidl).
    // IShellFolder or derived interfaces
    HRESULT BindToObject(
        [in] PCUIDLIST_RELATIVE pidl,
        [in, unique] IBindCtx *pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // produces the same result as BindToObject()
    HRESULT BindToStorage(
        [in] PCUIDLIST_RELATIVE pidl,
        [in, unique] IBindCtx *pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // compares two IDLists and returns the result. The shell
    // explorer always passes 0 as lParam, which indicates 'sort by name'.
    // It should return 0 (as CODE of the scode), if two id indicates the
    // same object; negative value if pidl1 should be placed before pidl2;
    // positive value if pidl2 should be placed before pidl1.
    // use the macro ResultFromShort() to extract the result comparison
    // it deals with the casting and type conversion issues for you
    HRESULT CompareIDs(
        [in] LPARAM lParam,
        [in] PCUIDLIST_RELATIVE pidl1,
        [in] PCUIDLIST_RELATIVE pidl2);

    // creates a view object of the folder itself. The view
    // object is a difference instance from the shell folder object.
    // 'hwndOwner' can be used  as the owner window of its dialog box or
    // menu during the lifetime of the view object.
    // This member function should always create a new
    // instance which has only one reference count. The explorer may create
    // more than one instances of view object from one shell folder object
    // and treat them as separate instances.
    // returns IShellView derived interface
    HRESULT CreateViewObject(
        [in, unique] HWND hwndOwner,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // returns the attributes of specified objects in that
    // folder. 'cidl' and 'apidl' specifies objects. 'apidl' contains only
    // simple IDLists. The explorer initializes *prgfInOut with a set of
    // flags to be evaluated. The shell folder may optimize the operation
    // by not returning unspecified flags.
    HRESULT GetAttributesOf(
        [in] UINT cidl,
        [in, size_is(cidl), unique] PCUITEMID_CHILD_ARRAY apidl,
        [in, out] SFGAOF * rgfInOut);

midl_pragma warning (disable: 2495) // annotation is allowed on local interface and local methods only

    // creates a UI object to be used for specified objects.
    // The shell explorer passes either IID_IDataObject (for transfer operation)
    // or IID_IContextMenu (for context menu operation) as riid
    // and many other interfaces
    HRESULT GetUIObjectOf(
        [in, unique] HWND hwndOwner,
        [in] UINT cidl,
        [in, size_is(cidl), unique] PCUITEMID_CHILD_ARRAY apidl,
        [in] REFIID riid,
        [in, out, unique, annotation("_Reserved_")] UINT * rgfReserved,
        [out, iid_is(riid)] void **ppv);

midl_pragma warning (default: 2495)

    // returns the display name of the specified object.
    // If the ID contains the display name (in the locale character set),
    // it returns the offset to the name. Otherwise, it returns a pointer
    // to the display name string (UNICODE), which is allocated by the
    // task allocator, or fills in a buffer.
    // use the helper APIS StrRetToStr() or StrRetToBuf() to deal with the different
    // forms of the STRRET structure
    HRESULT GetDisplayNameOf(
        [in, unique] PCUITEMID_CHILD pidl,
        [in] SHGDNF uFlags,
        [out] STRRET *pName);

    // sets the display name of the specified object.
    // If it changes the ID as well, it returns the new ID which is
    // alocated by the task allocator.
    [local]
    HRESULT SetNameOf(
        [in, unique, annotation("_In_opt_")] HWND hwnd,
        [in, annotation("_In_")] PCUITEMID_CHILD pidl,
        [in, string, annotation("_In_")] LPCWSTR pszName,
        [in, annotation("_In_")] SHGDNF uFlags,
        [out, annotation("_Outptr_opt_")] PITEMID_CHILD *ppidlOut);

    [call_as(SetNameOf)]
    HRESULT RemoteSetNameOf(
        [in, unique] HWND hwnd,
        [in] PCUITEMID_CHILD pidl,
        [in, string] LPCWSTR pszName,
        [in] SHGDNF uFlags,
        [out] PITEMID_CHILD *ppidlOut);
}
typedef IShellFolder * LPSHELLFOLDER;


typedef struct EXTRASEARCH
{
    GUID    guidSearch;
    WCHAR   wszFriendlyName[80];
    WCHAR   wszUrl[2084];
} EXTRASEARCH, *LPEXTRASEARCH;

[
    uuid(0E700BE1-9DB6-11d1-A1CE-00C04FD75D13),
    object,
    pointer_default(unique)
]
interface IEnumExtraSearch : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] EXTRASEARCH *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumExtraSearch **ppenum);
}
typedef IEnumExtraSearch *LPENUMEXTRASEARCH;

// IShellFolder2::GetDefaultColumnState values

[
    uuid(93F2F68C-1D1B-11d3-A30E-00C04F79ABD1),
    object,
    pointer_default(unique)
]
interface IShellFolder2 : IShellFolder
{
    // Returns the guid of the search that is to be invoked when user clicks on the search toolbar button
    HRESULT GetDefaultSearchGUID([out] GUID *pguid);

    // gives an enumerator of the searches to be added to the search menu
    HRESULT EnumSearches([out] IEnumExtraSearch **ppenum);

    HRESULT GetDefaultColumn(
        [in] DWORD dwRes,
        [out] ULONG *pSort,
        [out] ULONG *pDisplay);

    // return SHCOLSTATE_ values
    HRESULT GetDefaultColumnState(
        [in] UINT iColumn,
        [out] SHCOLSTATEF *pcsFlags);

    // PCUITEMID_CHILD should have been annotated as [in].
    // Changing the annotation will break compatibility, but GetDetailsEx should never be called with a null pidl.
    HRESULT GetDetailsEx(
        [in, unique] PCUITEMID_CHILD pidl,
        [in] const SHCOLUMNID *pscid,
        [out] VARIANT *pv);

    HRESULT GetDetailsOf(
        [in, unique] PCUITEMID_CHILD pidl,
        [in] UINT iColumn,
        [out] SHELLDETAILS *psd);

    HRESULT MapColumnToSCID(
        [in] UINT iColumn,
        [out] SHCOLUMNID *pscid);
}

typedef [v1_enum] enum FOLDERFLAGS
{
    // XP flags
    FWF_NONE =                  0x00000000,
    FWF_AUTOARRANGE =           0x00000001,
    FWF_ABBREVIATEDNAMES =      0x00000002,     // not supported
    FWF_SNAPTOGRID =            0x00000004,
    FWF_OWNERDATA =             0x00000008,     // not supported
    FWF_BESTFITWINDOW =         0x00000010,
    FWF_DESKTOP =               0x00000020,     // implies NOCLIENTEDGE/NOSCROLL
    FWF_SINGLESEL =             0x00000040,
    FWF_NOSUBFOLDERS =          0x00000080,
    FWF_TRANSPARENT =           0x00000100,
    FWF_NOCLIENTEDGE =          0x00000200,     // not supported, this is always assumed to be true
    FWF_NOSCROLL =              0x00000400,
    FWF_ALIGNLEFT =             0x00000800,
    FWF_NOICONS =               0x00001000,
    FWF_SHOWSELALWAYS =         0x00002000,
    FWF_NOVISIBLE =             0x00004000,
    FWF_SINGLECLICKACTIVATE =   0x00008000,     // not supported
    FWF_NOWEBVIEW =             0x00010000,     // not supported
    FWF_HIDEFILENAMES =         0x00020000,
    FWF_CHECKSELECT =           0x00040000,     // check boxes with 2 modes { unchecked, SVSI_CHECK }

    // Vista Flags
    FWF_NOENUMREFRESH =         0x00080000,
    FWF_NOGROUPING =            0x00100000,
    FWF_FULLROWSELECT =         0x00200000,
    FWF_NOFILTERS =             0x00400000,
    FWF_NOCOLUMNHEADER =        0x00800000,     // don't show column header
    FWF_NOHEADERINALLVIEWS =    0x01000000,     // don't show column header if not in details mode
    FWF_EXTENDEDTILES =         0x02000000,
    FWF_TRICHECKSELECT =        0x04000000,     // checks boxes have 3 modes { unchecked, SVSI_CHECK, SVSI_CHECK2 }
    FWF_AUTOCHECKSELECT =       0x08000000,     // check boxes to change item selection state
    FWF_NOBROWSERVIEWSTATE =    0x10000000,
    FWF_SUBSETGROUPS =          0x20000000,
    FWF_USESEARCHFOLDER =       0x40000000,     // Use the search folder for stacking and searching
    FWF_ALLOWRTLREADING =       0x80000000,     // Do not use WS_EX_RTLREADING when WS_EX_LAYOUTRTL is set (thereby keeping RTL reading)
} FOLDERFLAGS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(FOLDERFLAGS)")  // some bits are flags, others are not

typedef [v1_enum] enum FOLDERVIEWMODE
{
    FVM_AUTO =             -1,
    FVM_FIRST =             1,
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    FVM_THUMBNAIL =         5,
    FVM_TILE =              6,
    FVM_THUMBSTRIP =        7,
    FVM_CONTENT =           8,
    FVM_LAST =              8,
} FOLDERVIEWMODE;

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

typedef [v1_enum] enum FOLDERLOGICALVIEWMODE
{
    FLVM_UNSPECIFIED =     -1,
    FLVM_FIRST =            1,
    FLVM_DETAILS =          1,
    FLVM_TILES =            2,
    FLVM_ICONS =            3,
    FLVM_LIST =             4,
    FLVM_CONTENT =          5,
    FLVM_LAST =             5,
} FOLDERLOGICALVIEWMODE;

cpp_quote("#endif  // NTDDI_VISTA")

typedef struct FOLDERSETTINGS
{
    UINT /* FOLDERVIEWMODE */ ViewMode;     // View mode
    UINT /* FOLDERFLAGS */ fFlags;          // View options
} FOLDERSETTINGS;

typedef FOLDERSETTINGS *LPFOLDERSETTINGS;
typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;
typedef FOLDERSETTINGS *PFOLDERSETTINGS;

//
// IShellView::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellView::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellView::TranslateAccelerator(lpmsg)
//
//   Similar to IOleInPlaceActiveObject::TranlateAccelerator. The explorer
//  calls this function BEFORE any other translation. Returning S_OK
//  indicates that the message was translated (eaten) and should not be
//  translated or dispatched by the explorer.
//
//
// IShellView::EnableModeless(fEnable)
//   Similar to IOleInPlaceActiveObject::EnableModeless.
//
//
// IShellView::UIActivate(uState)
//
//   The explorer calls this member function whenever the activation
//  state of the view window is changed by a certain event that is
//  NOT caused by the shell view itself.
//
//   SVUIA_DEACTIVATE will be passed when the explorer is about to
//  destroy the shell view window; the shell view is supposed to remove
//  all the extended UIs (typically merged menu and modeless popup windows).
//
//   SVUIA_ACTIVATE_NOFOCUS will be passsed when the shell view is losing
//  the input focus or the shell view has been just created without the
//  input focus; the shell view is supposed to set menuitems appropriate
//  for non-focused state (no selection specific items should be added).
//
//   SVUIA_ACTIVATE_FOCUS will be passed when the explorer has just
//  created the view window with the input focus; the shell view is
//  supposed to set menuitems appropriate for focused state.
//
//   SVUIA_INPLACEACTIVATE(new) will be passed when the shell view is opened
//  within an ActiveX control, which is not a UI active. In this case,
//  the shell view should not merge menus or put toolbas. To be compatible
//  with Win95 client, we don't pass this value unless the view supports
//  IShellView2.
//
//   The shell view should not change focus within this member function.
//  The shell view should not hook the WM_KILLFOCUS message to remerge
//  menuitems. However, the shell view typically hook the WM_SETFOCUS
//  message, and re-merge the menu after calling IShellBrowser::
//  OnViewWindowActivated.
//
//   One of the ACTIVATE / INPLACEACTIVATE messages will be sent when
//  the view window becomes the currently displayed view.  On Win95 systems,
//  this will happen immediately after the CreateViewWindow call.  On IE4, Win98,
//  and NT5 systems this may happen when the view reports it is ready (if the
//  IShellView supports async creation).  This can be used as a hint as to when
//  to make your view window visible.  Note: the Win95/Win98/NT4 common dialogs
//  do not send either of these on creation.
//
//
// IShellView::Refresh()
//
//   The explorer calls this member when the view needs to refresh its
//  contents (such as when the user hits F5 key).
//
//
// IShellView::CreateViewWindow
//
//   This member creates the view window (right-pane of the explorer or the
//  client window of the folder window).
//
//
// IShellView::DestroyViewWindow
//
//   This member destroys the view window.
//
//
// IShellView::GetCurrentInfo
//
//   This member returns the folder settings.
//
//
// IShellView::AddPropertySHeetPages
//
//   The explorer calls this member when it is opening the option property
//  sheet. This allows the view to add additional pages to it.
//
//
// IShellView::SaveViewState()
//
//   The explorer calls this member when the shell view is supposed to
//  store its view settings. The shell view is supposed to get a view
//  stream by calling IShellBrowser::GetViewStateStream and store the
//  current view state into that stream.
//
//
// IShellView::SelectItem(pidlItem, uFlags)
//
//   The explorer calls this member to change the selection state of
//  item(s) within the shell view window.  If pidlItem is NULL and uFlags
//  is SVSI_DESELECTOTHERS, all items should be deselected.

typedef [v1_enum] enum _SVSIF // Shell View Select Item Flags (SVSIF)
{
    SVSI_DESELECT        = 0x00000000,
    SVSI_SELECT          = 0x00000001,
    SVSI_EDIT            = 0x00000003,  // includes SVSI_SELECT
    SVSI_DESELECTOTHERS  = 0x00000004,
    SVSI_ENSUREVISIBLE   = 0x00000008,
    SVSI_FOCUSED         = 0x00000010,
    SVSI_TRANSLATEPT     = 0x00000020,
    SVSI_SELECTIONMARK   = 0x00000040,
    SVSI_POSITIONITEM    = 0x00000080,
    SVSI_CHECK           = 0x00000100,
    SVSI_CHECK2          = 0x00000200,
    SVSI_KEYBOARDSELECT  = 0x00000401,  // includes SVSI_SELECT
    SVSI_NOTAKEFOCUS     = 0x40000000,
} _SVSIF;

cpp_quote("#define SVSI_NOSTATECHANGE   ((UINT)0x80000000) // work around the use of the high bit that results in 4245: signed/unsigned mismatch")

typedef UINT SVSIF; // Shell View Select Item Flags (SVSIF), values from _SVSIF

typedef [v1_enum] enum _SVGIO // Shell View Get Item Object flags (SVGIO), used with IShellView::GetItemObject() and other methods
{
    SVGIO_BACKGROUND        = 0x00000000,   // riid == IID_IDispatch -> view automation object, implements supports connection point container for DIID_DShellFolderViewEvents
                                            // riid == IID_IContextMenu -> backgroud context menu object
                                            // riid == IID_IPersistHistory -> persist history object for the view
    SVGIO_SELECTION         = 0x00000001,   // the selected items in the view
    SVGIO_ALLVIEW           = 0x00000002,   // all of the items in the view
    SVGIO_CHECKED           = 0x00000003,   // if the view is in check select mode the checked items
    SVGIO_TYPE_MASK         = 0x0000000F,   // mask for above values
    SVGIO_FLAG_VIEWORDER    = 0x80000000,   // request items in view order
} _SVGIO;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(_SVGIO)")

typedef int SVGIO; // Shell View Get Item Object flags (SVGIO), values from _SVGIO

// uState values for IShellView::UIActivate
typedef [v1_enum] enum SVUIA_STATUS
{
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} SVUIA_STATUS;

//  this is to handle name collisions
cpp_quote("#ifdef _FIX_ENABLEMODELESS_CONFLICT")
cpp_quote("#define    EnableModeless EnableModelessSV")
cpp_quote("#endif")

//
//  this is so that all the implementations still get the function pointer.
//  and midl wont complain about the data type
//
cpp_quote("#ifdef _NEVER_")
typedef LPARAM LPFNSVADDPROPSHEETPAGE;
cpp_quote("#else //!_NEVER_")
cpp_quote("#include <prsht.h>")
cpp_quote("typedef LPFNADDPROPSHEETPAGE LPFNSVADDPROPSHEETPAGE;")
cpp_quote("#endif //_NEVER_")

interface IShellBrowser;

[
    uuid(000214E3-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellView : IOleWindow
{
    HRESULT TranslateAccelerator([in] MSG *pmsg);

    HRESULT EnableModeless([in] BOOL fEnable);

    HRESULT UIActivate([in] UINT /* SVUIA_STATUS */ uState);

    HRESULT Refresh();

    HRESULT CreateViewWindow(
        [in, unique] IShellView *psvPrevious,
        [in] LPCFOLDERSETTINGS pfs,
        [in] IShellBrowser *psb,
        [in] RECT *prcView,
        [out] HWND *phWnd);

    HRESULT DestroyViewWindow();

    HRESULT GetCurrentInfo([out] LPFOLDERSETTINGS pfs);

    [local] HRESULT AddPropertySheetPages(
        [in, annotation("_In_")] DWORD dwReserved,
        [in, annotation("_In_")] LPFNSVADDPROPSHEETPAGE pfn,
        [in, annotation("_In_")] LPARAM lparam);

    HRESULT SaveViewState();

    HRESULT SelectItem(
        [in, unique] PCUITEMID_CHILD pidlItem,
        [in] SVSIF uFlags);

    HRESULT GetItemObject(
        [in] UINT /* SVGIO */ uItem,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

typedef IShellView *LPSHELLVIEW;
}

[
    uuid(88E39E80-3578-11CF-AE69-08002B2E1262),
    object,
    pointer_default(unique)
]
interface IShellView2 :  IShellView
{
typedef GUID SHELLVIEWID;

cpp_quote("#define SV2GV_CURRENTVIEW ((UINT)-1)")
cpp_quote("#define SV2GV_DEFAULTVIEW ((UINT)-2)")
//
//  NOTE if the cbSize param is ever updated,")
//  then there will have to be custom [wire_marshal]")
//  implementation to support it")
//
cpp_quote("#include <pshpack8.h>")
typedef struct _SV2CVW2_PARAMS
{
    DWORD cbSize;

    IShellView *psvPrev;
    LPCFOLDERSETTINGS pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    SHELLVIEWID const *pvid;
    HWND hwndView;

} SV2CVW2_PARAMS, *LPSV2CVW2_PARAMS;

cpp_quote("#include <poppack.h>")   // Return to byte packing

    HRESULT GetView(
        [in, out] SHELLVIEWID* pvid,
        [in] ULONG uView);

    HRESULT CreateViewWindow2(
        [in] LPSV2CVW2_PARAMS lpParams);

    HRESULT HandleRename(
        [in, unique] PCUITEMID_CHILD pidlNew);

    HRESULT SelectAndPositionItem(
        [in, unique] PCUITEMID_CHILD pidlItem,
        [in] UINT /* SVSIF */ uFlags,
        [in, unique] POINT *ppt);
}

//  this is to handle name collisions
cpp_quote("#ifdef _FIX_ENABLEMODELESS_CONFLICT")
cpp_quote("#undef    EnableModeless ")
cpp_quote("#endif")

[
    uuid(cde725b0-ccc9-4519-917e-325d72fab4ce),
    object,
    pointer_default(unique)
]
interface IFolderView : IUnknown
{
    HRESULT GetCurrentViewMode([out] UINT /* FOLDERVIEWMODE */ *pViewMode);

    HRESULT SetCurrentViewMode([in] UINT /* FOLDERVIEWMODE */ ViewMode);

    // the folder for the view, returns IShellFolder and related interfaces
    // also supports IShellItemArray that returns an array with a single item for the folder
    HRESULT GetFolder(
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT Item(
        [in] int iItemIndex,
        [out] PITEMID_CHILD *ppidl);

    // get the count of items for selection, total, etc
    HRESULT ItemCount(
        [in] UINT /* SVGIO */ uFlags,
        [out] int *pcItems);

    // get the items in the view in the form of IShellItemArray, IDataObject, etc
    HRESULT Items(
        [in] UINT /* SVGIO */ uFlags,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetSelectionMarkedItem([out] int *piItem);

    HRESULT GetFocusedItem([out] int *piItem);

    HRESULT GetItemPosition(
        [in] PCUITEMID_CHILD pidl,
        [out] POINT* ppt);

    HRESULT GetSpacing([in, out, unique] POINT* ppt);

    HRESULT GetDefaultSpacing([out] POINT* ppt);

    // returns S_OK if AutoArrange is on, S_FALSE if off
    HRESULT GetAutoArrange();

    // like IShellView::SelectItem() by index, SVSI_ flags
    HRESULT SelectItem(
        [in] int iItem,
        [in] DWORD /* SVSIF */ dwFlags);

    HRESULT SelectAndPositionItems(
        [in] UINT cidl,
        [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,
        [disable_consistency_check, in, unique, size_is(cidl)] POINT* apt,
        [in] DWORD /* SVSIF */ dwFlags);
}
cpp_quote("#define SID_SFolderView IID_IFolderView    // folder view, usually IFolderView")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#ifndef NO_SHOBJIDL_SORTDIRECTION")
[v1_enum] enum tagSORTDIRECTION
{
    SORT_DESCENDING = -1,
    SORT_ASCENDING = 1
};
cpp_quote("#endif  // NO_SHOBJIDL_SORTDIRECTION")
typedef int SORTDIRECTION;

typedef struct SORTCOLUMN
{
    PROPERTYKEY   propkey;
    SORTDIRECTION direction;
} SORTCOLUMN;

typedef [v1_enum] enum FVTEXTTYPE
{
    FVST_EMPTYTEXT  = 0,
} FVTEXTTYPE;

interface IShellItemArray;

typedef HRESULT DEPRECATED_HRESULT;
cpp_quote("#if defined(__cplusplus)")
cpp_quote("#define DEPRECATED_HRESULT HRESULT DECLSPEC_DEPRECATED")
cpp_quote("#endif")

[
    uuid(1af3a467-214f-4298-908e-06b03e0b39f9),
    object,
    pointer_default(unique)
]
interface IFolderView2 : IFolderView
{
    // Sets the group by property and starts a grouping operation
    HRESULT SetGroupBy(
        [in] REFPROPERTYKEY key,
        [in] BOOL fAscending);

    [local]
    HRESULT GetGroupBy(
        [out, annotation("_Out_")] PROPERTYKEY* pkey,
        [out, annotation("_Out_opt_")] BOOL *pfAscending);

    [call_as(GetGroupBy)]
    HRESULT RemoteGetGroupBy(
        [out] PROPERTYKEY* pkey,
        [out] BOOL *pfAscending);

    // Setting and Getting per item view properties is not possible for Libraries or Search results views.
    // Consider using existing item properties instead.
    DEPRECATED_HRESULT SetViewProperty(
        [in] PCUITEMID_CHILD pidl,
        [in] REFPROPERTYKEY propkey,
        [in] REFPROPVARIANT propvar);

    // Setting and Getting per item view properties is not possible for Libraries or Search results views.
    // Consider using existing item properties instead.
    DEPRECATED_HRESULT GetViewProperty(
        [in] PCUITEMID_CHILD pidl,
        [in] REFPROPERTYKEY propkey,
        [out] PROPVARIANT *ppropvar);

    // Setting per item Tile view properties is not possible for Libraries or Search results views.
    // Consider setting property lists for your item types instead (see PKEY_PropList_TileInfo)
    DEPRECATED_HRESULT SetTileViewProperties(
        [in] PCUITEMID_CHILD pidl,
        [in, string] LPCWSTR pszPropList);

    // Setting per item Extended Tile view properties is not possible for Libraries or Search results views.
    // Consider setting property lists for your item types instead (see PKEY_PropList_ExtendedTileInfo)
    DEPRECATED_HRESULT SetExtendedTileViewProperties(
        [in] PCUITEMID_CHILD pidl,
        [in, string] LPCWSTR pszPropList);

    HRESULT SetText(
        [in] FVTEXTTYPE iType,
        [in] LPCWSTR pwszText);

    HRESULT SetCurrentFolderFlags(
        [in] DWORD /* FOLDERFLAGS */ dwMask,
        [in] DWORD /* FOLDERFLAGS */ dwFlags);

    HRESULT GetCurrentFolderFlags([out] DWORD /* FOLDERFLAGS */ *pdwFlags);

    HRESULT GetSortColumnCount([out] int *pcColumns);

    // Sets the sort by property and starts a sort operation
    HRESULT SetSortColumns(
        [in, size_is(cColumns)] const SORTCOLUMN *rgSortColumns,
        [in] int cColumns);

    HRESULT GetSortColumns(
        [out, size_is(cColumns)] SORTCOLUMN *rgSortColumns,
        [in] int cColumns);

    // return IShellItem for an item based on its index
    HRESULT GetItem(
        [in] int iItem,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetVisibleItem(
        [in] int iStart,
        [in] BOOL fPrevious,
        [out] int *piItem);

    HRESULT GetSelectedItem(
        [in] int iStart,
        [out] int *piItem);

    HRESULT GetSelection(
        [in] BOOL fNoneImpliesFolder,
        [out] IShellItemArray **ppsia);

    // Gets the selection state including check state.  Same as the flags for IFolderView::SelectAndPositionItems
    HRESULT GetSelectionState(
        [in] PCUITEMID_CHILD pidl,
        [out] DWORD /* SVSIF */ *pdwFlags);

    // If pszVerb is NULL, then the default verb is invoked.
    HRESULT InvokeVerbOnSelection([in, unique, string] LPCSTR pszVerb);

    // Sets default icon size if iImageSize == -1
    HRESULT SetViewModeAndIconSize(
        [in] FOLDERVIEWMODE uViewMode,
        [in] int iImageSize);

    HRESULT GetViewModeAndIconSize(
        [out] FOLDERVIEWMODE *puViewMode,
        [out] int *piImageSize);

    HRESULT SetGroupSubsetCount([in] UINT cVisibleRows);

    HRESULT GetGroupSubsetCount([out] UINT *pcVisibleRows);

    HRESULT SetRedraw([in] BOOL fRedrawOn);

    // S_OK means this view sourced the current drag drop or cut/paste operation (used by drop target objects)
    HRESULT IsMoveInSameFolder();

    HRESULT DoRename();
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

[
    uuid(ae8c987d-8797-4ed3-be72-2a47dd938db0),
    object
]
interface IFolderViewSettings : IUnknown
{
    // GetColumnPropertyList - returns IPropertyDescriptionList.  Ordered list of columns that must correspond to column enumerated
    // via ISF::GetDetailsOf. Any column from ISF::GetDetailsOf not included in this list will be marked SHCOLSTATE_SECONDARYUI
    // (or maintain SHCOLSTATE_HIDDEN)
    HRESULT GetColumnPropertyList(
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetGroupByProperty(
        [out] PROPERTYKEY *pkey,
        [out] BOOL *pfGroupAscending);

    HRESULT GetViewMode(
        [out] FOLDERLOGICALVIEWMODE *plvm);

    HRESULT GetIconSize(
        [out] UINT *puIconSize);

    HRESULT GetFolderFlags(
        [out] FOLDERFLAGS *pfolderMask,
        [out] FOLDERFLAGS *pfolderFlags);

    HRESULT GetSortColumns(
        [out, size_is(cColumnsIn), length_is(*pcColumnsOut)] SORTCOLUMN *rgSortColumns,
        [in] UINT cColumnsIn,
        [out] UINT *pcColumnsOut);

    HRESULT GetGroupSubsetCount([out] UINT *pcVisibleRows);
}

[
    object,
    uuid(6e0f9881-42a8-4f2a-97f8-8af4e026d92d),
    pointer_default(unique)
]
interface IInitializeNetworkFolder : IUnknown
{
    HRESULT Initialize(
        [in, unique] PCIDLIST_ABSOLUTE pidl,
        [in, unique] PCIDLIST_ABSOLUTE pidlTarget,
        [in] UINT uDisplayType,                     // RESOURCEDISPLAYTYPE_ values
        [in, unique, string] LPCWSTR pszResName,    // server or server share name
        [in, unique, string] LPCWSTR pszProvider);  // network provider name
}

[
    object,
    uuid(CEB38218-C971-47BB-A703-F0BC99CCDB81),
    pointer_default(unique)
]
interface INetworkFolderInternal : IUnknown
{
    HRESULT GetResourceDisplayType([out] UINT* displayType);
    HRESULT GetIDList([out] PIDLIST_ABSOLUTE* idList);
    HRESULT GetProvider(
        [in] UINT itemIdCount,
        [in, size_is(itemIdCount), unique] PCUITEMID_CHILD_ARRAY itemIds,
        [in] UINT providerMaxLength,
        [out, size_is(providerMaxLength)] LPWSTR provider);
}

cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

[
    object,
    uuid(196bf9a5-b346-4ef0-aa1e-5dcdb76768b1),
    pointer_default(unique)
]
interface IPreviewHandlerVisuals : IUnknown
{
    HRESULT SetBackgroundColor([in] COLORREF color);

    HRESULT SetFont([in] const LOGFONTW *plf);

    HRESULT SetTextColor([in] COLORREF color);
}

cpp_quote("#endif  // _WIN32_IE_IE70")

//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(PCUITEMID_CHILD pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

cpp_quote("#define CDBOSC_SETFOCUS     0x00000000")
cpp_quote("#define CDBOSC_KILLFOCUS    0x00000001")
cpp_quote("#define CDBOSC_SELCHANGE    0x00000002")
cpp_quote("#define CDBOSC_RENAME       0x00000003")
cpp_quote("#define CDBOSC_STATECHANGE  0x00000004")

[
    uuid(000214F1-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface ICommDlgBrowser : IUnknown
{
    HRESULT OnDefaultCommand([in] IShellView *ppshv);

    HRESULT OnStateChange(
        [in] IShellView *ppshv,
        [in] ULONG uChange);

    HRESULT IncludeObject(
        [in, unique] IShellView *ppshv,
        [in] PCUITEMID_CHILD pidl);
}

typedef ICommDlgBrowser * LPCOMMDLGBROWSER;

// This is for frames that may host an ExplorerBrowser (which implements ICommDlgBrowser3), and yet need to implement
// some ICommDlgBrowser methods themselves.  ExplorerBrowser will do some default processing if necessary, and then
// allow responders to SID_SExplorerBrowserFrame to provide additional processing of these calls, when appropriate.
cpp_quote("#define SID_SExplorerBrowserFrame IID_ICommDlgBrowser")

//-------------------------------------------------------------------------
// ICommDlgBrowser2 interface
//
// Member functions:
//
//  ICommDlgBrowser2::Notify(IShellView *pshv, DWORD dwNotfyType)
//   Called when the view is wants to notify common dialog when an event
//  occurrs.
//
//  CDB2N_CONTEXTMENU_START indicates the context menu has started.
//  CDB2N_CONTEXTMENU_DONE  indicates the context menu has completed.
//
//  ICommDlgBrowser2::GetDefaultMenuText(IShellView *pshv,
//                                      WCHAR *pszText, INT cchMax)
//   Called when the view wants to get the default context menu text.
//  pszText points to buffer and cchMax specifies the size of the
//  buffer in characters.  The browser on return has filled the buffer
//  with the default context menu text.  The Shell will call this method
//  with at least a buffer size of MAX_PATH.  The browser should return
//  S_OK if it returned a new default menu text, S_FALSE to let the view
//  to use the normal default menu text.
//
//  ICommDlgBrowser2::GetViewFlags(DWORD *pdwFlags)
//     Called when the view wants to determine  if special customization needs to
//    be done for the common dialog browser. For example View calls this function to
//    determin if all files(hidden and system)needs to be shown. If the GetViewFlags returns a DWORD with
//    CDB2GVF_SHOWALLFILES  flag set then it will show all the files.
//-------------------------------------------------------------------------

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN2K)")

cpp_quote("#define CDB2N_CONTEXTMENU_DONE  0x00000001")
cpp_quote("#define CDB2N_CONTEXTMENU_START 0x00000002")

//GetViewFlags
cpp_quote("#define CDB2GVF_SHOWALLFILES        0x00000001")
cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define CDB2GVF_ISFILESAVE          0x00000002 // is file save, else file open")
cpp_quote("#define CDB2GVF_ALLOWPREVIEWPANE    0x00000004")
cpp_quote("#define CDB2GVF_NOSELECTVERB        0x00000008")
cpp_quote("#define CDB2GVF_NOINCLUDEITEM       0x00000010")
cpp_quote("#define CDB2GVF_ISFOLDERPICKER      0x00000020")
cpp_quote("#define CDB2GVF_ADDSHIELD           0x00000040   // when CDB2GVF_NOSELECTVERB is not specified this flag controls the display of a LUA shield on the Select menu item")
cpp_quote("#endif  // NTDDI_VISTA")

[
    uuid(10339516-2894-11d2-9039-00C04F8EEB3E),
    object,
    pointer_default(unique)
]
interface ICommDlgBrowser2 : ICommDlgBrowser
{
    HRESULT Notify(
        [in] IShellView *ppshv,
        [in] DWORD dwNotifyType);

    HRESULT GetDefaultMenuText(
        [in] IShellView *ppshv,
        [out, string, size_is(cchMax)] LPWSTR pszText,
        [in] int cchMax);

    // returns CDB2GVF_XXX values to control the behavior of the view when in common dialog mode
    HRESULT GetViewFlags([out] DWORD *pdwFlags);
}

typedef ICommDlgBrowser2 * LPCOMMDLGBROWSER2;

cpp_quote("#endif  // NTDDI_WIN2K")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

//--------------------------------------------------------------------------
//
// Interface:   IColumnManager
//
// IColumnManager is an interfaced provided by defview to
// allow the manipulation of columns in details view.
//

typedef [v1_enum] enum CM_MASK
{
    CM_MASK_WIDTH           = 0x00000001,
    CM_MASK_DEFAULTWIDTH    = 0x00000002,
    CM_MASK_IDEALWIDTH      = 0x00000004,
    CM_MASK_NAME            = 0x00000008,
    CM_MASK_STATE           = 0x00000010,
} CM_MASK;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CM_MASK)")

typedef [v1_enum] enum CM_STATE
{
    CM_STATE_NONE               = 0x00000000,
    CM_STATE_VISIBLE            = 0x00000001,  // The column is visible
    CM_STATE_FIXEDWIDTH         = 0x00000002,  // Can't resize the column
    CM_STATE_NOSORTBYFOLDERNESS = 0x00000004,  // Do not sort folders seperately
    CM_STATE_ALWAYSVISIBLE      = 0x00000008,  // readonly. column cannot be hidden
} CM_STATE;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CM_STATE)")

typedef [v1_enum] enum CM_ENUM_FLAGS
{
    CM_ENUM_ALL          = 0x00000001,
    CM_ENUM_VISIBLE      = 0x00000002,
} CM_ENUM_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CM_ENUM_FLAGS)")

typedef [v1_enum] enum CM_SET_WIDTH_VALUE
{
    CM_WIDTH_USEDEFAULT  = -1,
    CM_WIDTH_AUTOSIZE    = -2,
} CM_SET_WIDTH_VALUE;

#define MAX_COLUMN_NAME_LEN 80

typedef struct CM_COLUMNINFO
{
    DWORD cbSize;  // size in bytes of struct
    DWORD dwMask;  // CM_MASK
    DWORD dwState; // CM_STATE
    UINT uWidth;   // CM_MASK_WIDTH, for SetColumnInfo it can be a CM_SET_WIDTH_VALUE
    UINT uDefaultWidth; // CM_MASK_DEFAULTWIDTH
    UINT uIdealWidth; // CM_MASK_IDEALWIDTH
    WCHAR wszName[MAX_COLUMN_NAME_LEN];
} CM_COLUMNINFO;

[
    uuid(d8ec27bb-3f3b-4042-b10a-4acfd924d453),
    object,
    pointer_default(unique)
]
interface IColumnManager : IUnknown
{
    // NOTE: These methods only accept physical pixel values.
    HRESULT SetColumnInfo(
        [in] REFPROPERTYKEY propkey,
        [in] const CM_COLUMNINFO *pcmci);

    HRESULT GetColumnInfo(
        [in] REFPROPERTYKEY propkey,
        [in, out] CM_COLUMNINFO *pcmci);

    HRESULT GetColumnCount(
        [in] CM_ENUM_FLAGS dwFlags,
        [out] UINT *puCount);

    HRESULT GetColumns(
        [in] CM_ENUM_FLAGS dwFlags,
        [out, size_is(cColumns)] PROPERTYKEY *rgkeyOrder,
        [in] UINT cColumns);

    HRESULT SetColumns(
        [in, size_is(cVisible)] const PROPERTYKEY *rgkeyOrder,
        [in] UINT cVisible);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

// New for XP, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")
[
    uuid(C0A651F5-B48B-11d2-B5ED-006097C686F6), // IID_IFolderFilterSite
    object,
    pointer_default(unique)
]
interface IFolderFilterSite : IUnknown
{
    HRESULT SetFilter([in]IUnknown* punk);
}

[
    uuid(9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E), // IID_IFolderFilter
    object,
    pointer_default(unique)
]
interface IFolderFilter : IUnknown
{
    HRESULT ShouldShow(
        [in] IShellFolder* psf,
        [in, unique] PCIDLIST_ABSOLUTE pidlFolder,
        [in] PCUITEMID_CHILD pidlItem);

    HRESULT GetEnumFlags(
        [in] IShellFolder* psf,
        [in] PCIDLIST_ABSOLUTE pidlFolder,
        [out] HWND *phwnd,
        [in, out] DWORD *pgrfFlags);
}
//cpp_quote("#endif  // NTDDI_WINXP")

// IInputObjectSite/IInputObject interfaces
//
// These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//

// A site implements this interface so the object can communicate
// focus change to it.
[
    object,
    uuid(F1DB8392-7331-11D0-8C99-00A0C92DBFE8),
    pointer_default(unique),
]
interface IInputObjectSite: IUnknown
{
    // Object (punkObj) is getting or losing the focus.
    HRESULT OnFocusChangeIS([in, unique] IUnknown* punkObj, [in] BOOL fSetFocus);
}

[
    object,
    uuid(68284fAA-6A48-11D0-8c78-00C04fd918b4),
    pointer_default(unique)
]
interface IInputObject: IUnknown
{
    // Activates or deactivates the object.  lpMsg may be NULL.  Returns
    // S_OK if the activation succeeded.
    HRESULT UIActivateIO([in] BOOL fActivate, [in, unique] MSG *pMsg);

    // Returns S_OK if the object has the focus, S_FALSE if not.
    HRESULT HasFocusIO();

    // Allow the object to process the message.  Returns S_OK if the
    // message was processed (eaten).
    HRESULT TranslateAcceleratorIO([in] MSG *pMsg);
}


// New for Vista, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
[
    object,
    uuid(6915C085-510B-44cd-94AF-28DFA56CF92B),
    pointer_default(unique),
    local
]
interface IInputObject2 : IInputObject
{
    // Called to handle global accelerators, so that input objects can
    // respond to keyboard even when they are not UI active.
    //
    // Note that pMsg is not const, to allow implementors to forward to the
    // Win32 TranslateAccelerator without having to cast away const-ness.
    HRESULT TranslateAcceleratorGlobal([in, annotation("_In_")] MSG *pMsg);
}
//cpp_quote("#endif  // NTDDI_VISTA")

// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon which is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      S_OK, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
[
    uuid(000214E5-0000-0000-C000-000000000046), // IID_IShellIcon
    object,
    pointer_default(unique)
]
interface IShellIcon : IUnknown
{
    HRESULT GetIconOf(
        [in] PCUITEMID_CHILD pidl,
        [in] UINT flags,
        [out] int *pIconIndex);
}

//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the 'contents pane' of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the 'contents pane'
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  'File' and 'Edit' pulldown in the File menu group, 'View' and 'Tools'
//  in the Container menu group and 'Help' in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(pszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)")
//
//   The view calls this member to let shell explorer browse to another")
//  folder. The pidl and wFlags specifies the folder to be browsed.")
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window
//  browser || explorer)).
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//   SBSP_NAVIGATEBACK    -- Navigate back (ignores the pidl)
//   SBSP_NAVIGATEFORWARD -- Navigate forward (ignores the pidl)
//
//  Following two flags control history manipulation as result of navigate
//   SBSP_WRITENOHISTORY -- write no history (shell folder) entry
//   SBSP_NOAUTOSELECT -- suppress selection in history pane
//
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the IStream *variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. 'lpButtons' and 'nButtons' specifies the array of toolbar
//  items. 'uFlags' must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

//
// flag values to be combined for the Flags parameter of IShellBrowser::BrowseObject() method
//
cpp_quote("#define SBSP_DEFBROWSER         0x0000")
cpp_quote("#define SBSP_SAMEBROWSER        0x0001")
cpp_quote("#define SBSP_NEWBROWSER         0x0002")

cpp_quote("#define SBSP_DEFMODE            0x0000")
cpp_quote("#define SBSP_OPENMODE           0x0010")
cpp_quote("#define SBSP_EXPLOREMODE        0x0020")
cpp_quote("#define SBSP_HELPMODE           0x0040")
cpp_quote("#define SBSP_NOTRANSFERHIST     0x0080")

cpp_quote("#define SBSP_ABSOLUTE           0x0000")
cpp_quote("#define SBSP_RELATIVE           0x1000")
cpp_quote("#define SBSP_PARENT             0x2000")
cpp_quote("#define SBSP_NAVIGATEBACK       0x4000")
cpp_quote("#define SBSP_NAVIGATEFORWARD    0x8000")

cpp_quote("#define SBSP_ALLOW_AUTONAVIGATE   0x00010000")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define SBSP_KEEPSAMETEMPLATE     0x00020000")
cpp_quote("#define SBSP_KEEPWORDWHEELTEXT    0x00040000")
cpp_quote("#define SBSP_ACTIVATE_NOFOCUS     0x00080000")
cpp_quote("#define SBSP_CREATENOHISTORY      0x00100000")
cpp_quote("#define SBSP_PLAYNOSOUND          0x00200000")
cpp_quote("#endif  // (NTDDI_VERSION >= NTDDI_VISTA)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#define SBSP_CALLERUNTRUSTED      0x00800000")
cpp_quote("#define SBSP_TRUSTFIRSTDOWNLOAD   0x01000000")
cpp_quote("#define SBSP_UNTRUSTEDFORDOWNLOAD 0x02000000")
cpp_quote("#endif  // _WIN32_IE_IE60SP2")
cpp_quote("#define SBSP_NOAUTOSELECT         0x04000000")
cpp_quote("#define SBSP_WRITENOHISTORY       0x08000000")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#define SBSP_TRUSTEDFORACTIVEX    0x10000000")
cpp_quote("#endif  // _WIN32_IE_IE60SP2")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define SBSP_FEEDNAVIGATION       0x20000000")
cpp_quote("#endif  // _WIN32_IE_IE70")


cpp_quote("#define SBSP_REDIRECT                     0x40000000")
cpp_quote("#define SBSP_INITIATEDBYHLINKFRAME        0x80000000")
//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
cpp_quote("#define FCW_STATUS         0x0001")
cpp_quote("#define FCW_TOOLBAR        0x0002")
cpp_quote("#define FCW_TREE           0x0003")
cpp_quote("#define FCW_INTERNETBAR    0x0006")
cpp_quote("#define FCW_PROGRESS       0x0008")


cpp_quote("#if (_WIN32_IE >= 0x0700)")
cpp_quote("#endif")

//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
cpp_quote("#define FCT_MERGE       0x0001")
cpp_quote("#define FCT_CONFIGABLE  0x0002")
cpp_quote("#define FCT_ADDTOEND    0x0004")

cpp_quote("#ifdef _NEVER_")
typedef LPARAM LPTBBUTTONSB;
cpp_quote("#else //!_NEVER_")
cpp_quote("#include <commctrl.h>")
cpp_quote("typedef LPTBBUTTON LPTBBUTTONSB;")
cpp_quote("#endif //_NEVER_")

[
    uuid(000214E2-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellBrowser : IOleWindow
{
    // same as IOleInPlaceFrame
    HRESULT InsertMenusSB(
        [in] HMENU hmenuShared,
        [in, out] LPOLEMENUGROUPWIDTHS lpMenuWidths);

    HRESULT SetMenuSB(
        [in, unique] HMENU hmenuShared,
        [in, unique] HOLEMENU holemenuRes,
        [in, unique] HWND hwndActiveObject);

    HRESULT RemoveMenusSB([in] HMENU hmenuShared);
    HRESULT SetStatusTextSB([in, unique] LPCWSTR pszStatusText);
    HRESULT EnableModelessSB([in] BOOL fEnable);
    HRESULT TranslateAcceleratorSB([in] MSG *pmsg, [in] WORD wID);

    // IShellBrowser
    HRESULT BrowseObject(
        [in, unique] PCUIDLIST_RELATIVE pidl,
        [in] UINT wFlags);

    HRESULT GetViewStateStream(
        [in] DWORD grfMode,
        [out] IStream **ppStrm);

    HRESULT GetControlWindow(
        [in] UINT id,
        [out] HWND * phwnd);

    [local] HRESULT SendControlMsg(
        [in, annotation("_In_")] UINT id,
        [in, annotation("_In_")] UINT uMsg,
        [in, annotation("_In_")] WPARAM wParam,
        [in, annotation("_In_")] LPARAM lParam,
        [out, annotation("_Out_opt_")] LRESULT *pret);

    HRESULT QueryActiveShellView([out] IShellView **ppshv);

    HRESULT OnViewWindowActive([in] IShellView *pshv);

    [local] HRESULT SetToolbarItems(
        [in, annotation("_In_reads_opt_(nButtons)")] LPTBBUTTONSB lpButtons,
        [in, annotation("_In_")] UINT nButtons,
        [in, annotation("_In_")] UINT uFlags);
}

typedef IShellBrowser * LPSHELLBROWSER;


[
    uuid(cb728b20-f786-11ce-92ad-00aa00a74cd0), // IID_IProfferService
    object,
    pointer_default(unique)
]
interface IProfferService : IUnknown
{
    HRESULT ProfferService(
        [in] REFGUID guidService,
        [in] IServiceProvider *psp,
        [out] DWORD *pdwCookie);

    HRESULT RevokeService([in] DWORD dwCookie);
}

cpp_quote("#define SID_SProfferService IID_IProfferService    // nearest service that you can proffer to")

// Tells an IShellItem not to resolve the link target obtained
// when using the BHID_LinkTargetItem GUID in BindToHandler.
cpp_quote("#define STR_DONT_RESOLVE_LINK      L\"Don't Resolve Link\"")

// The handler is being retrieved on the UI thread.  Avoid any expensive work that touches the disk, network, etc.
cpp_quote("#define STR_GET_ASYNC_HANDLER L\"GetAsyncHandler\"")

// New for XP, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

//  BindHandler GUIDs for IShellItem::BindToHandler (defined in shlguid.h)")
//  BHID_SFObject            restricts usage to IShellFolder::BindToObject()")
//  BHID_SFUIObject          restricts usage to IShellFolder::GetUIObjectOf()")
//  BHID_SFViewObject        restricts usage to IShellFolder::CreateViewObject()")
//  BHID_LinkTargetItem      CLSID_ShellItem initialized with the target this item (SFGAO_LINK only)")
//  BHID_Storage             attempts to get the stg/stm riid from BTO, but defaults to shell implementations on failure")

//  Shell Namespace helper
[
    uuid(43826d1e-e718-42ee-bc55-a1e261c37bfe),
    object,
    pointer_default(unique)
]
interface IShellItem : IUnknown
{
    typedef [v1_enum] enum _SIGDN
    {                                                         // lower word (& with 0xFFFF)
        SIGDN_NORMALDISPLAY               = 0x00000000,       // SHGDN_NORMAL
        SIGDN_PARENTRELATIVEPARSING       = (int) 0x80018001, // SHGDN_INFOLDER | SHGDN_FORPARSING
        SIGDN_DESKTOPABSOLUTEPARSING      = (int) 0x80028000, // SHGDN_FORPARSING
        SIGDN_PARENTRELATIVEEDITING       = (int) 0x80031001, // SHGDN_INFOLDER | SHGDN_FOREDITING
        SIGDN_DESKTOPABSOLUTEEDITING      = (int) 0x8004c000, // SHGDN_FORPARSING | SHGDN_FORADDRESSBAR
        SIGDN_FILESYSPATH                 = (int) 0x80058000, // SHGDN_FORPARSING
        SIGDN_URL                         = (int) 0x80068000, // SHGDN_FORPARSING
        SIGDN_PARENTRELATIVEFORADDRESSBAR = (int) 0x8007c001, // SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR
        SIGDN_PARENTRELATIVE              = (int) 0x80080001, // SHGDN_INFOLDER
        SIGDN_PARENTRELATIVEFORUI         = (int) 0x80094001, // SHGDN_INFOLDER | SHGDN_FORADDRESSBAR
    } SIGDN;

    //  SICHINT_DISPLAY         iOrder based on display in a folder view
    //  SICHINT_ALLFIELDS       exact instance compare
    //  SICHINT_CANONICAL       iOrder based on canonical name (better performance)
    [v1_enum] enum _SICHINTF
    {
        SICHINT_DISPLAY         = 0x00000000,
        SICHINT_ALLFIELDS       = (int) 0x80000000,
        SICHINT_CANONICAL       = 0x10000000,
        SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL = 0x20000000,
    };
    typedef DWORD SICHINTF;

    HRESULT BindToHandler(
        [in, unique] IBindCtx *pbc,
        [in] REFGUID bhid,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetParent([out] IShellItem **ppsi);

midl_pragma warning( disable: 2495 ) // allow the annotation here, it is safe and useful
    HRESULT GetDisplayName(
        [in] SIGDN sigdnName,
        [out, string, annotation("_Outptr_result_nullonfailure_")] LPWSTR *ppszName);
midl_pragma warning( default: 2495 ) // annotation() only allowed on local methods/interfaces

    HRESULT GetAttributes(
        [in] SFGAOF sfgaoMask,
        [out] SFGAOF *psfgaoAttribs);

    HRESULT Compare(
        [in] IShellItem *psi,
        [in] SICHINTF hint,
        [out] int *piOrder);
}
//cpp_quote("#endif  // NTDDI_WINXP")

cpp_quote("SHSTDAPI_(PIDLIST_ABSOLUTE) SHSimpleIDListFromPath(_In_ PCWSTR pszPath);")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("// CLSID_ShellItem create and init helper APIs. produce IShellItem derived interfaces from these different expressions of an item")
cpp_quote("SHSTDAPI SHCreateItemFromIDList(_In_ PCIDLIST_ABSOLUTE pidl, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("SHSTDAPI SHCreateItemFromParsingName(_In_ PCWSTR pszPath, _In_opt_ IBindCtx *pbc, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("SHSTDAPI SHCreateItemWithParent(_In_opt_ PCIDLIST_ABSOLUTE pidlParent, _In_opt_ IShellFolder *psfParent, _In_ PCUITEMID_CHILD pidl, _In_ REFIID riid, _Outptr_ void **ppvItem);")
cpp_quote("SHSTDAPI SHCreateItemFromRelativeName(_In_ IShellItem *psiParent, _In_ PCWSTR pszName, _In_opt_ IBindCtx* pbc, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("SHSTDAPI SHCreateItemInKnownFolder(_In_ REFKNOWNFOLDERID kfid, DWORD dwKFFlags, _In_opt_ PCWSTR pszItem, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("// get the IDList expression from an object, works with objects that support IPersistIDlist or IPersistIDlist like CLSID_ShellItem and most shell folders")
cpp_quote("SHSTDAPI SHGetIDListFromObject(_In_ IUnknown *punk, _Outptr_ PIDLIST_ABSOLUTE *ppidl);")
cpp_quote("// similar to SHGetIDListFromObject but returns an IShellItem-based object (preferred for performance if the IDList is already bound to a folder)")
cpp_quote("SHSTDAPI SHGetItemFromObject(_In_ IUnknown *punk, _In_ REFIID riid, _Outptr_ void **ppv);")

cpp_quote("// these APIs return object that support IPropertyStore or related interfaces")
cpp_quote("SHSTDAPI SHGetPropertyStoreFromIDList(_In_ PCIDLIST_ABSOLUTE pidl, _In_ GETPROPERTYSTOREFLAGS flags, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("SHSTDAPI SHGetPropertyStoreFromParsingName(_In_ PCWSTR pszPath, _In_opt_ IBindCtx *pbc, _In_ GETPROPERTYSTOREFLAGS flags, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("SHSTDAPI SHGetNameFromIDList(_In_ PCIDLIST_ABSOLUTE pidl, _In_ SIGDN sigdnName, _Outptr_ PWSTR *ppszName);")

cpp_quote("#endif // (NTDDI_VERSION >= NTDDI_VISTA)")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN7)")
typedef [v1_enum] enum DATAOBJ_GET_ITEM_FLAGS
{
    DOGIF_DEFAULT         = 0x0000,
    DOGIF_TRAVERSE_LINK   = 0x0001,    // if the item is a link get the target
    DOGIF_NO_HDROP        = 0x0002,    // don't fallback and use CF_HDROP clipboard format
    DOGIF_NO_URL          = 0x0004,    // don't fallback and use URL clipboard format
    DOGIF_ONLY_IF_ONE     = 0x0008,    // only return the item if there is one item in the array
} DATAOBJ_GET_ITEM_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(DATAOBJ_GET_ITEM_FLAGS)")
// returns IShellItem and other interfaces that CLSID_ShellItem implements
cpp_quote("STDAPI SHGetItemFromDataObject(_In_ IDataObject *pdtobj, _In_ DATAOBJ_GET_ITEM_FLAGS dwFlags, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("#endif // (NTDDI_VERSION >= NTDDI_WIN7)")

// New for Vista, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

//
// When requesting a property store through IShellFolder, you can specify the equivalent of
// GPS_DEFAULT by passing in a null IBindCtx parameter.
//
// You can specify the equivalent of GPS_READWRITE by passing a mode of STGM_READWRITE | STGM_EXCLUSIVE
// in the bind context
//
// Here are the string versions of GPS_ flags, passed to IShellFolder::BindToObject() via IBindCtx::RegisterObjectParam()
// These flags are valid when requesting an IPropertySetStorage or IPropertyStore handler
//
// The meaning of these flags are described above.
//
// There is no STR_ equivalent for GPS_TEMPORARY because temporary property stores
// are provided by IShellItem2 only -- not by the underlying IShellFolder.
//
cpp_quote("#define STR_GPS_HANDLERPROPERTIESONLY      L\"GPS_HANDLERPROPERTIESONLY\"")
cpp_quote("#define STR_GPS_FASTPROPERTIESONLY         L\"GPS_FASTPROPERTIESONLY\"")
cpp_quote("#define STR_GPS_OPENSLOWITEM               L\"GPS_OPENSLOWITEM\"")
cpp_quote("#define STR_GPS_DELAYCREATION              L\"GPS_DELAYCREATION\"")
cpp_quote("#define STR_GPS_BESTEFFORT                 L\"GPS_BESTEFFORT\"")
cpp_quote("#define STR_GPS_NO_OPLOCK                  L\"GPS_NO_OPLOCK\"")

// Shell Namespace helper 2
[
    uuid(7e9fb0d3-919f-4307-ab2e-9b1860310c93),
    object,
    pointer_default(unique)
]
interface IShellItem2 : IShellItem
{
    HRESULT GetPropertyStore(
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetPropertyStoreWithCreateObject(
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] IUnknown *punkCreateObject,   // factory for low-rights creation of type ICreateObject
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetPropertyStoreForKeys(
        [in, size_is(cKeys)] const PROPERTYKEY *rgKeys,
        [in] UINT cKeys,
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetPropertyDescriptionList(
        [in] REFPROPERTYKEY keyType,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // Ensures any cached information in this item is up to date, or returns __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the item does not exist.
    HRESULT Update([in, unique] IBindCtx *pbc);

    HRESULT GetProperty(
        [in] REFPROPERTYKEY key,
        [out] PROPVARIANT *ppropvar);

    HRESULT GetCLSID(
        [in] REFPROPERTYKEY key,
        [out] CLSID *pclsid);

    HRESULT GetFileTime(
        [in] REFPROPERTYKEY key,
        [out] FILETIME *pft);

    HRESULT GetInt32(
        [in] REFPROPERTYKEY key,
        [out] int *pi);

    HRESULT GetString(
        [in] REFPROPERTYKEY key,
        [out, string] LPWSTR *ppsz);

    HRESULT GetUInt32(
        [in] REFPROPERTYKEY key,
        [out] ULONG *pui);

    HRESULT GetUInt64(
        [in] REFPROPERTYKEY key,
        [out] ULONGLONG *pull);

    HRESULT GetBool(
        [in] REFPROPERTYKEY key,
        [out] BOOL *pf);
}
//cpp_quote("#endif  // NTDDI_VISTA")

[v1_enum] enum _SIIGBF
{
    SIIGBF_RESIZETOFIT          = 0x00000000,   // If necessary, shrink the bitmap (preserving aspect ratio) so width and height fit the given size.
    SIIGBF_BIGGERSIZEOK         = 0x00000001,   // A larger bitmap than requested may be returned, the caller will manage scaling down (inverse of SIIGBF_RESIZETOFIT).
    SIIGBF_MEMORYONLY           = 0x00000002,   // Return the item only if it is already in memory. Do not access the disk even if the item is cached.
    SIIGBF_ICONONLY             = 0x00000004,   // Return only the icon, never the thumbnail.
    SIIGBF_THUMBNAILONLY        = 0x00000008,   // Return only the thumbnail, never the icon.
    SIIGBF_INCACHEONLY          = 0x00000010,   // Allows access to the disk, but only to retrieve a cached item.
    SIIGBF_CROPTOSQUARE         = 0x00000020,   // Windows 8 and later. If necessary, crop the bitmap to a square.
    SIIGBF_WIDETHUMBNAILS       = 0x00000040,   // Windows 8 and later. Stretch and crop the bitmap to a .7 aspect ratio.
    SIIGBF_ICONBACKGROUND       = 0x00000080,   // Windows 8 and later. If returning an icon, paint a background using the associated app's registered background color.
    SIIGBF_SCALEUP              = 0x00000100,   // Windows 8 and later. If necessary, stretch the bitmap so width and height fit the given size.

};
typedef int SIIGBF;


[
    uuid(bcc18b79-ba16-442f-80c4-8a59c30c463b),
    object,
    pointer_default(unique)
]
interface IShellItemImageFactory : IUnknown
{
    // bitmap returned is a DIB; color format is RGB24, RGB32 or PARGB32
    HRESULT GetImage(
        [in] SIZE size,
        [in] SIIGBF flags,
        [out] HBITMAP *phbm);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

// Shell Namespace enumerator
[
    uuid(70629033-e363-4a28-a567-0db78006e6d7),
    object,
    pointer_default(unique)
]
interface IEnumShellItems : IUnknown
{
    [local]
    HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched), annotation("_Out_writes_to_(celt, *pceltFetched)")] IShellItem **rgelt,
        [out, annotation("_Out_opt_ _Deref_out_range_(0, celt)")] ULONG *pceltFetched);

    [call_as(Next)]
    HRESULT RemoteNext(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] IShellItem **rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumShellItems **ppenum);
}

typedef GUID STGTRANSCONFIRMATION, *LPSTGTRANSCONFIRMATION;

// Storage operations

typedef [v1_enum] enum STGOP
{
    STGOP_MOVE               = 1,
    STGOP_COPY               = 2,
    STGOP_SYNC               = 3,
    STGOP_REMOVE             = 5,
    STGOP_RENAME             = 6,
    STGOP_APPLYPROPERTIES    = 8,   // (NTDDI_VERSION >= NTDDI_VISTA)
    STGOP_NEW                = 10,  // (NTDDI_VERSION >= NTDDI_VISTA)
} STGOP;

cpp_quote("#endif  // NTDDI_WINXP")

// ITransferSource/ITransferDestination flag values use for OpenItem/MoveItem/RecycleItem/RemoveItem/etc

[v1_enum] enum _TRANSFER_SOURCE_FLAGS
{
    TSF_NORMAL                      = 0x00000000,
    TSF_FAIL_EXIST                  = 0x00000000,   // Fail if destination already exists
    TSF_RENAME_EXIST                = 0x00000001,   // Rename with auto-name generation if destination already exists
    TSF_OVERWRITE_EXIST             = 0x00000002,   // Overwrite/Merge with destination
    TSF_ALLOW_DECRYPTION            = 0x00000004,   // Allow creation of decrypted destination
    TSF_NO_SECURITY                 = 0x00000008,   // Without DACL/SACL/Owner
    TSF_COPY_CREATION_TIME          = 0x00000010,   // Copy the creation time as part of the copy (useful for move as copy/delete)
    TSF_COPY_WRITE_TIME             = 0x00000020,   // Copy the last write time as part of the copy
    TSF_USE_FULL_ACCESS             = 0x00000040,   // Open a file with write, read, or delete as share mode
    TSF_DELETE_RECYCLE_IF_POSSIBLE  = 0x00000080,   // Recycle if possible
    TSF_COPY_HARD_LINK              = 0x00000100,   // Hard link desired (not required)
    TSF_COPY_LOCALIZED_NAME         = 0x00000200,   // Copy localized name
    TSF_MOVE_AS_COPY_DELETE         = 0x00000400,   // We are doing a move operation, but we are doing it as a copy/delete
    TSF_SUSPEND_SHELLEVENTS         = 0x00000800,   // suspend shell events
};
typedef DWORD TRANSFER_SOURCE_FLAGS;

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

[
    uuid(d594d0d8-8da7-457b-b3b4-ce5dbaac0b88),
    object
]
interface ITransferAdviseSink : IUnknown
{
    [v1_enum] enum _TRANSFER_ADVISE_STATE
    {
        TS_NONE            = 0x00000000,
        TS_PERFORMING      = 0x00000001,       // Transfer is being performed
        TS_PREPARING       = 0x00000002,       // Preparing to perform transfer - calculating space needed, etc.
        TS_INDETERMINATE   = 0x00000004,       // The length of the transfer is indeterminate
    };
    typedef DWORD TRANSFER_ADVISE_STATE;

    //  UpdateProgress
    //
    //      Updates the sink as to current progress of an operation.
    //
    //      Implementers of this function should return an error code when the operation needs to terminate early (e.g. the user clicked on the cancel button).
    //      If all parameters are 0, UpdateProgress should not change any of its progress data but should can still return an error code
    //      to halt the operation.
    //      If all the total parameters are 0 but some of the current parameters are non-zero, UpdateProgress should update it's current progress but shouldn't change
    //      it's total progress.
    //
    //      Callers should regularly query for a cancel request by calling this function with all parameters set to 0 even if no measurable progress occured.
    //
    //  Parameters:
    //
    //      ullSizeTotal, nFilesTotal, nFoldersTotal
    //          Total size in bytes, number of files and number of folders. This includes what has been processed and what will be processed.
    //          Setting all three to 0 indicates that the totals have not changed since the last call to UpdateProgress.
    //
    //      ullSizeCurrent, nFilesCurrent, nFoldersCurrent
    //          Number of bytes, files and folders processed since the start of the operation.
    //          Setting all six parameters to zero indicates that progress has not changed since the last call to UpdateProgress.
    //
    //  Return values:
    //      COPYENGINE_E_USER_CANCELLED
    //          The user has cancelled the operation and the caller should halt execution of the operation as soon as possible.
    //
    //      Any other error:
    //          The caller should halt execution of the operation as soon as possible.
    HRESULT UpdateProgress(
        [in] ULONGLONG ullSizeCurrent,
        [in] ULONGLONG ullSizeTotal,
        [in] int nFilesCurrent,
        [in] int nFilesTotal,
        [in] int nFoldersCurrent,
        [in] int nFoldersTotal);

    HRESULT UpdateTransferState([in] TRANSFER_ADVISE_STATE ts);

    //  ConfirmOverwrite
    //
    //  Parameters:
    //      psiSource
    //          Source IShellItem.
    //      psiDestParent
    //          Destination's parent folder's IShellItem.
    //      pszName
    //          Pointer to wide-string containing the name of the item. If NULL,
    //          the name is the same as the psiSource's.
    //
    //  Return Values from Confirmations
    //      COPYENGINE_S_USER_IGNORED
    //          Continue operation
    //      COPYENGINE_E_USER_CANCELLED
    //          is a user-interaction cancel. The user clicked "Cancel" somewhere.
    //
    //      Any other HRESULT should be passed up.

    // Confirm that the operation is ok to actually overwrite an existing item
    HRESULT ConfirmOverwrite(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiDestParent,
        [in, string] LPCWSTR pszName);

    // Confirm that the operation is ok to lose encryption (disclosure)
    HRESULT ConfirmEncryptionLoss([in] IShellItem *psiSource);

    //  Parameters:
    //      psi
    //          The IShellItem that is reporting the failure.
    //      pszItem
    //          If NULL, the "psi"'s display name will be used.
    //          If not NULL, this should be a pointer to a string that is the
    //          name of the item.
    //      hrError
    //          The error that is being reported.
    //      pszRename
    //          A buffer that the caller passes if it wants to be able to
    //          retry the operation with a new destination name. If this
    //          parameter is NULL, no option to rename will be available.
    //      cchRename
    //          Size of the buffer pointed to be pszRename.
    //
    //  Return Values:
    //      COPYENGINE_S_USER_RETRY
    //          The handler should retry the file operation.
    //      COPYENGINE_S_USER_IGNORED
    //          The handler should skip creating the item and return this code
    //          back to the copy engine.
    //      COPYENGINE_E_USERCANCELLED
    //          The user clicked "Cancel" somewhere. The entire copy job is
    //          being aborted. The handler should return this code back to the
    //          copy engine.
    //
    //      Any other HRESULT should be passed up. If failure not handled,
    //      the return value should be the same as hrError.
    HRESULT FileFailure(
        [in] IShellItem *psi,
        [in, unique, string] LPCWSTR pszItem,
        [in] HRESULT hrError,
        [in, out, unique, size_is(cchRename)] LPWSTR pszRename,
        [in] ULONG cchRename);

    HRESULT SubStreamFailure(
        [in] IShellItem *psi,
        [in, string] LPCWSTR pszStreamName,
        [in] HRESULT hrError);

    HRESULT PropertyFailure(
        [in] IShellItem *psi,
        [in, unique] const PROPERTYKEY* pkey,   // (pkey == NULL) indicates loss of all properties
        [in] HRESULT hrError);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

[
    object,
    uuid(00adb003-bde9-45c6-8e29-d09f9353e108),
    pointer_default(unique),
    local
]
interface ITransferSource : IUnknown
{
    //  Description:
    //      Do an advise before calling anything so the handler can callback for
    //      any errors that might occur. If not set, the handler should consider
    //      it an indication that no feedback is available and to do the "default"
    //      operation.
    //
    //  Parameters:
    //      psink
    //          ITransferAdviseSink interface to be used for status and
    //          failures.
    //      pdwCookie
    //          Pointer to a returned token that uniquely identifies this
    //          connection. The caller uses this token later to delete the
    //          connection by passing it to the Unadvise method. If the
    //          connection was not successfully established, this value is zero.
    //
    //  Return Values:
    //      S_OK
    //          Interface successfully associated.
    //      E_UNEXPECTED
    //          The handler can only handle one sink interface.
    //
    //      other HRESULTs indicate a failure.
    HRESULT Advise(
        [in, annotation("_In_")] ITransferAdviseSink *psink,
        [out, annotation("_Out_")] DWORD *pdwCookie);

    //  Description:
    //      Terminates an advisory connection previously established through
    //      Advise method. The dwCookie parameter identifies the connection
    //      to terminate
    //
    //  Parameters:
    //      dwCookie
    //          Connection token previously returned from Advise.
    //
    //  Return Values:
    //      S_OK
    //          The connection was successfully terminated.
    //      CONNECT_E_NOCONNECTION
    //          The value in dwCookie does not represent a valid connection.
    //
    //      other HRESULTs indicate a failure.
    HRESULT Unadvise([in, annotation("_In_")] DWORD dwCookie);

    //  Description:
    //      Set properties that should be applied to an item
    //
    //  Parameters:
    //      pproparray
    //          Contains a list of changes
    //
    //  Return Values:
    //      S_OK
    //          Properties set successfully
    //      other HRESULTs indicate a failure.
    HRESULT SetProperties([in, annotation("_In_")] IPropertyChangeArray *pproparray);

    // Open the item for copying, returning an object that can be enumerated
    // for resources (IShellItemResources).
    HRESULT OpenItem(
        [in, annotation("_In_")] IShellItem *psi,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags,
        [in, annotation("_In_")] REFIID riid,
        [out, iid_is(riid), annotation("_Outptr_")] void **ppv);

    // Move the item within the volume/namespace, returning the shell item
    // in its new location.
    // returns:
    //      FAILED() codes with special meaning for
    //          HRESULT_FROM_WIN32(ERROR_NOT_SAME_DEVICE) -> caller should convert move into a copy/delete
    //          E_NOINTERFACE -> caller should convert move into a copy/delete
    //          in the case of moving a folder
    //              HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) or HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)
    //              indicates
    //          to convert to a copy/delete the destination item must support ITransferDestination
    //
    //      SUCCEEDED() code with special meaning for
    //          S_OK - move succeeded, *ppsiNew contains the new item that is the target of the move
    //          COPYENGINE_S_USER_IGNORED -> *ppsiNew is NULL, the destination item already exists and
    //              has not been overwritten. caller should complete the "move" by deleting the
    ///             source item
    //          COPYENGINE_S_MERGE -> *ppsiNew is NULL, the destination folder already exists
    //              and the user has chosen to proceed merging the folder, the caller should complete
    //              the "move" of the folder by deleting the source

    HRESULT MoveItem(
        [in, annotation("_In_")] IShellItem *psi,
        [in, annotation("_In_")] IShellItem *psiParentDst,
        [in, string, annotation("_In_")] LPCWSTR pszNameDst,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [out, annotation("_Outptr_")] IShellItem **ppsiNew);

    // Recycle the item into the provided recycle location, returning the new
    // recycled item in that location.
    HRESULT RecycleItem(
        [in, annotation("_In_")] IShellItem *psiSource,
        [in, annotation("_In_")] IShellItem *psiParentDest,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags,
        [out, annotation("_Outptr_")] IShellItem **ppsiNewDest);

    // Removed the item (without recycle support)
    HRESULT RemoveItem(
        [in, annotation("_In_")] IShellItem *psiSource,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags);

    // Change the name of an item, returing the shell item in its new location
    HRESULT RenameItem(
        [in, annotation("_In_")] IShellItem *psiSource,
        [in, string, annotation("_In_")] LPCWSTR pszNewName,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags,
        [out, annotation("_Outptr_")] IShellItem **ppsiNewDest);

    // not used or supported, return E_NOTIMPL
    HRESULT LinkItem(
        [in, annotation("_In_")] IShellItem *psiSource,
        [in, annotation("_In_")] IShellItem *psiParentDest,
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszNewName,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags,
        [out, annotation("_Outptr_")] IShellItem **ppsiNewDest);

    // Apply a set of property changes to an item, return the modified shell item.
    HRESULT ApplyPropertiesToItem(
        [in, annotation("_In_")] IShellItem *psiSource,
        [out, annotation("_Outptr_")] IShellItem **ppsiNew);

    // Return the default name, if different from the items parsing name.
    HRESULT GetDefaultDestinationName(
        [in, annotation("_In_")] IShellItem *psiSource,
        [in, annotation("_In_")] IShellItem *psiParentDest,
        [out, string, annotation("_Outptr_")] LPWSTR *ppszDestinationName);

    //  Description:
    //      These are called after a destination folder item has been created.
    //      EnterFolder() will be called before the children objects will be
    //      created.
    //
    //      Expected the order of operations to be:
    //      DoCopyItem( psiParentSource, psiParentFolderDest, pszChildName )
    //      {
    //          psiParentSource->BindToHandler( ..., &ptsParentFolderSource)
    //          ptsParentSource->Advise( psink, &dwCookie )
    //          ptsParentSource->CopyItem( psiParentFolderDest, pszChildName, 0, &psiFolderDest )
    //          if ( psiParentSource.HasChildren() )
    //          {
    //              ptsParentSource->EnterFolder( psiFolderDest )
    //              for each child in psiParentSource
    //              {
    //                  psiParentSource->"GetChild"( &psiChildSource ); <-- a little more complicated
    //                  DoCopyItem( psiChildSource , psiFolderDest )
    //              }
    //              ptsParentSource->LeaveFolder( psiFolderDest )
    //          }
    //          ptsParentSource->Unadvise( dwCookie )
    //      }
    //
    //  Parameters:
    //      psiChildFolderDest
    //          IShellItem of the folder being entered.
    //
    //  Return Values:
    //      S_OK
    //          Operation successful.
    //
    //      other HRESULTs indicate failure.
    HRESULT EnterFolder([in, annotation("_In_")] IShellItem *psiChildFolderDest);

    HRESULT LeaveFolder([in, annotation("_In_")] IShellItem *psiChildFolderDest);
}

cpp_quote("#endif  // NTDDI_VISTA")

typedef struct SHELL_ITEM_RESOURCE
{
    GUID    guidType;
    WCHAR   szName[260 /*MAX_PATH*/];
} SHELL_ITEM_RESOURCE;

[
    object,
    uuid(2dd81fe3-a83c-4da9-a330-47249d345ba1),
    pointer_default(unique)
]
interface IEnumResources : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] SHELL_ITEM_RESOURCE *psir,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumResources **ppenumr);
}

[
    object,
    uuid(ff5693be-2ce0-4d48-b5c5-40817d1acdb9),
    pointer_default(unique)
]
interface IShellItemResources : IUnknown
{
    HRESULT GetAttributes([out] DWORD *pdwAttributes);

    HRESULT GetSize([out] ULONGLONG *pullSize);

    HRESULT GetTimes(
        [out] FILETIME *pftCreation,
        [out] FILETIME *pftWrite,
        [out] FILETIME *pftAccess);

    HRESULT SetTimes(
        [in, unique] const FILETIME *pftCreation,
        [in, unique] const FILETIME *pftWrite,
        [in, unique] const FILETIME *pftAccess);

    HRESULT GetResourceDescription(
        [in] const SHELL_ITEM_RESOURCE *pcsir,
        [out, string] LPWSTR *ppszDescription);

    HRESULT EnumResources([out] IEnumResources **ppenumr);

    HRESULT SupportsResource([in] const SHELL_ITEM_RESOURCE *pcsir);

    HRESULT OpenResource(
        [in] const SHELL_ITEM_RESOURCE *pcsir,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT CreateResource(
        [in] const SHELL_ITEM_RESOURCE *pcsir,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT MarkForDelete();
}

[
    object,
    uuid(48addd32-3ca5-4124-abe3-b5a72531b207),
    pointer_default(unique),
    local
]
interface ITransferDestination : IUnknown
{
    //  *** 1: advise ***

    //  Do an advise before calling anything so the object can callback for
    //  any errors that might occur. If not set, the object should consider
    //  it an indication that no feedback is available and to do the "default"
    //  for the operation.
    HRESULT Advise(
        [in, annotation("_In_")] ITransferAdviseSink * psink,
        [out, annotation("_Out_")] DWORD * pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    // returns:
    //      SUCCEEDED() code with special meaning for
    //          S_OK - move succeeded, *ppvItem and *ppvResources contains the new item and resources object
    //          that should be copied to
    //          COPYENGINE_S_USER_IGNORED ->  *ppvItem and *ppvResources are NULL, the destination item already exists and
    //              has not been overwritten. if the caller is implemeting "move" as copy/delete it should complete
    //              the "move" by deleting the source item

    HRESULT CreateItem(
        [in, string, annotation("_In_")] LPCWSTR pszName,
        // FILE_ATTRIBUTE_XXX values, most important being FILE_ATTRIBUTE_DIRECTORY indicating that
        // a folder should be created
        [in, annotation("_In_")] DWORD dwAttributes,
        // the size of the item being copied or zero if unknow
        [in, annotation("_In_")] ULONGLONG ullSize,
        [in, annotation("_In_")] TRANSFER_SOURCE_FLAGS flags,
        // ppvItem should be an IShellItem or derived interface
        [in, annotation("_In_")] REFIID riidItem,
        [out, iid_is(riidItem), annotation("_Outptr_")] void **ppvItem,
        // ppvResources should be an IShellItemResources or derived interface
        [in, annotation("_In_")] REFIID riidResources,
        [out, iid_is(riidResources), annotation("_Outptr_")] void **ppvResources);
}

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

[
    object,
    uuid(04b0f1a7-9490-44bc-96e1-4296a31252e2),
    pointer_default(unique),
]
interface IFileOperationProgressSink : IUnknown
{
    HRESULT StartOperations();

    HRESULT FinishOperations(
        [in] HRESULT hrResult);

    HRESULT PreRenameItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in, unique, string] LPCWSTR pszNewName);

    HRESULT PostRenameItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in, string] LPCWSTR pszNewName,
        [in] HRESULT hrRename,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreMoveItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName);

    HRESULT PostMoveItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName,
        [in] HRESULT hrMove,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreCopyItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName);

    HRESULT PostCopyItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName,
        [in] HRESULT hrCopy,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreDeleteItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem);

    HRESULT PostDeleteItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] HRESULT hrDelete,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreNewItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName);

    HRESULT PostNewItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName,
        [in, unique, string] LPCWSTR pszTemplateName,
        [in] DWORD dwFileAttributes,
        [in] HRESULT hrNew,
        [in] IShellItem *psiNewItem);

    HRESULT UpdateProgress(
        [in] UINT iWorkTotal,
        [in] UINT iWorkSoFar);

    HRESULT ResetTimer();

    HRESULT PauseTimer();

    HRESULT ResumeTimer();
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

// New for Vista, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
// Shell Item Container
[
    uuid(b63ea76d-1f85-456f-a19c-48159efa858b),
    object,
    pointer_default(unique)
]
interface IShellItemArray : IUnknown
{
    typedef [v1_enum] enum SIATTRIBFLAGS
    {
        SIATTRIBFLAGS_AND               = 0x00000001, // if multiple items and the attirbutes together.
        SIATTRIBFLAGS_OR                = 0x00000002, // if multiple items or the attributes together.
        SIATTRIBFLAGS_APPCOMPAT         = 0x00000003, // Call GetAttributes directly on the ShellFolder for multiple attributes
        SIATTRIBFLAGS_MASK              = 0x00000003, // for the AND/OR/APPCOMPAT value
        SIATTRIBFLAGS_ALLITEMS          = 0x00004000, // normally only the first few items are used to compute the attributes, pass this to force all of them
                                                      // doing all will result in poor performance for large arrays so use this carefuly
    } SIATTRIBFLAGS;
    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SIATTRIBFLAGS)")  // some bits are flags, others are not

    // bhid values supported for the handler type are defined in shlguid.h
    // BHID_DataObject - IDataObject, only works for flat data objects or item arrays produced directly using SHCreateShellItemArrayFromDataObject()
    // BHID_AssociationArray - IQueryAssociations from the first item in the array
    // BHID_SFUIObject - only works for flat (items in the same folder) item array
    HRESULT BindToHandler([in, unique] IBindCtx *pbc, [in] REFGUID bhid, [in] REFIID riid, [out, iid_is(riid)] void **ppvOut);

    HRESULT GetPropertyStore([in] GETPROPERTYSTOREFLAGS flags, [in] REFIID riid, [out, iid_is(riid)] void **ppv);

    HRESULT GetPropertyDescriptionList([in] REFPROPERTYKEY keyType, [in] REFIID riid, [out, iid_is(riid)] void **ppv);

    // get the attributes for the items using different methods defined by SIATTRIBFLAGS
    HRESULT GetAttributes([in] SIATTRIBFLAGS AttribFlags, [in] SFGAOF sfgaoMask, [out] SFGAOF *psfgaoAttribs);

    HRESULT GetCount([out] DWORD *pdwNumItems);

    HRESULT GetItemAt([in] DWORD dwIndex, [out] IShellItem **ppsi);

    HRESULT EnumItems([out] IEnumShellItems **ppenumShellItems);
}
//cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("SHSTDAPI SHCreateShellItemArray(_In_opt_ PCIDLIST_ABSOLUTE pidlParent, _In_opt_ IShellFolder *psf, _In_ UINT cidl, _In_reads_opt_(cidl) PCUITEMID_CHILD_ARRAY ppidl, _Outptr_ IShellItemArray **ppsiItemArray);")
cpp_quote("SHSTDAPI SHCreateShellItemArrayFromDataObject(_In_ IDataObject *pdo, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("SHSTDAPI SHCreateShellItemArrayFromIDLists(_In_ UINT cidl, _In_reads_(cidl) PCIDLIST_ABSOLUTE_ARRAY rgpidl, _Outptr_ IShellItemArray **ppsiItemArray);")
cpp_quote("SHSTDAPI SHCreateShellItemArrayFromShellItem(_In_ IShellItem *psi, _In_ REFIID riid, _Outptr_ void **ppv);")
cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

[
    uuid(7f73be3f-fb79-493c-a6c7-7ee14e245841),
    object,
    pointer_default(unique)
]
interface IInitializeWithItem : IUnknown
{
    // grfMode is STGM_ values indicating read/readwrite and sharing modes
    HRESULT Initialize([in] IShellItem *psi, [in] DWORD grfMode);
}

[
    object,
    uuid(1c9cd5bb-98e9-4491-a60f-31aacc72b83c),
    pointer_default(unique)
]
interface IObjectWithSelection : IUnknown
{
    HRESULT SetSelection([in] IShellItemArray *psia);

    HRESULT GetSelection(
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
}

[
    object,
    uuid(321a6a6a-d61f-4bf3-97ae-14be2986bb36),
    pointer_default(unique)
]
interface IObjectWithBackReferences : IUnknown
{
    // This method is used for all tasks associated with freeing/releasing back references held
    // by an object, and may prepare an object for reuse
    HRESULT RemoveBackReferences();
}

[v1_enum] enum _PROPERTYUI_NAME_FLAGS
{
    PUIFNF_DEFAULT          = 0x00000000,
    PUIFNF_MNEMONIC         = 0x00000001,   // include mnemonic in display name
};
typedef DWORD PROPERTYUI_NAME_FLAGS;

[v1_enum] enum _PROPERTYUI_FLAGS
{
    PUIF_DEFAULT                 = 0x00000000,
    PUIF_RIGHTALIGN              = 0x00000001,   // this property should be right aligned
    PUIF_NOLABELININFOTIP        = 0x00000002,   // this property should not display a label in the infotip
};
typedef DWORD PROPERTYUI_FLAGS;

[v1_enum] enum _PROPERTYUI_FORMAT_FLAGS
{
    PUIFFDF_DEFAULT         = 0x00000000,
    PUIFFDF_RIGHTTOLEFT     = 0x00000001,   // deprecated - do not use
    PUIFFDF_SHORTFORMAT     = 0x00000002,   // short format version of string
    PUIFFDF_NOTIME          = 0x00000004,   // truncate time to days, not hours/mins/sec
    PUIFFDF_FRIENDLYDATE    = 0x00000008,   // "Today", "Yesterday", etc
};
typedef DWORD PROPERTYUI_FORMAT_FLAGS;

// helper service for dealing with properties ala IPropertySetStorage
[
    uuid(757a7d9f-919a-4118-99d7-dbb208c8cc66),
    object,
    pointer_default(unique)
]
interface IPropertyUI : IUnknown
{
    HRESULT ParsePropertyName(
        [in, string] LPCWSTR pszName,
        [out] FMTID *pfmtid,
        [out] PROPID *ppid,
        [in, out] ULONG *pchEaten);

    HRESULT GetCannonicalName(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [out, string, size_is(cchText)] LPWSTR pwszText,
        [in] DWORD cchText);

    HRESULT GetDisplayName(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [in] PROPERTYUI_NAME_FLAGS flags,
        [out, size_is(cchText)] LPWSTR pwszText,
        [in] DWORD cchText);

    HRESULT GetPropertyDescription(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [out, size_is(cchText)] LPWSTR pwszText,
        [in] DWORD cchText);

    HRESULT GetDefaultWidth(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [out] ULONG *pcxChars);

    HRESULT GetFlags(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [out] PROPERTYUI_FLAGS *pflags);

    HRESULT FormatForDisplay(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [in] const PROPVARIANT *ppropvar,
        [in] PROPERTYUI_FORMAT_FLAGS puiff,
        [out, string, size_is(cchText)] LPWSTR pwszText,
        [in] DWORD cchText);

    HRESULT GetHelpInfo(
        [in] REFFMTID fmtid,
        [in] PROPID pid,
        [out, string, size_is(cch)] LPWSTR pwszHelpFile,
        [in] DWORD cch,
        [out] UINT *puHelpID);
}

//-------------------------------------------------------------
// Folder Category Support
//-------------------------------------------------------------

// Provides a list of catagorizers registered on an IShellFolder
[
    uuid(9af64809-5864-4c26-a720-c1f78c086ee3),
    object,
    pointer_default(unique)
]
interface ICategoryProvider : IUnknown
{
    // Returns S_OK if the view should display this column in category selection UI, or S_FALSE to remove it.
    HRESULT CanCategorizeOnSCID([in] const SHCOLUMNID* pscid);

    // Returns either a GUID to create in CreateCategory, or a SHCOLUNNID that is used by the default categorizer.
    // Return S_FALSE if you do not support a default group.
    // GUID_NULL returned in pguid indicates to the client to use pscid as the default category.
    HRESULT GetDefaultCategory(
        [out] GUID* pguid,
        [out] SHCOLUMNID* pscid);

    // Returns either a GUID that represents the categoizer to use for the specified SHCOLUMNID.
    HRESULT GetCategoryForSCID(
        [in] const SHCOLUMNID* pscid,
        [out] GUID* pguid);

    // Returns an IEnumGUID that has a list of GUIDs that represent categories.
    HRESULT EnumCategories([out] IEnumGUID** penum);

    // Returns the name of the given category.
    HRESULT GetCategoryName(
        [in] const GUID* pguid,
        [out, string, size_is(cch)] LPWSTR pszName,
        [in] UINT cch);

    // Creates the category.
    HRESULT CreateCategory(
        [in] const GUID* pguid,
        [in] REFIID riid,
        [out, iid_is(riid)] void** ppv);
}

typedef [v1_enum] enum CATEGORYINFO_FLAGS
{
    CATINFO_NORMAL            = 0x00000000,   // Apply default properties to this category
    CATINFO_COLLAPSED         = 0x00000001,   // This category should appear collapsed. useful for the "None" category.
    CATINFO_HIDDEN            = 0x00000002,   // This category should follow the "Hidden" files setting for being displayed
    CATINFO_EXPANDED          = 0x00000004,   // This category should appear expanded.
    CATINFO_NOHEADER          = 0x00000008,   // This category has no header.
    CATINFO_NOTCOLLAPSIBLE    = 0x00000010,   // This category can not be collapsed.
    CATINFO_NOHEADERCOUNT     = 0x00000020,   // The count of items in the category should not be displayed in the header
    // Win7 Flags
    CATINFO_SUBSETTED         = 0x00000040,   // The category should appear subsetted.
    // Threshold Flags
    CATINFO_SEPARATE_IMAGES   = 0x00000080,   // The category should use its own image list.
    CATINFO_SHOWEMPTY         = 0x00000100,   // Show the category even when empty.
} CATEGORYINFO_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CATEGORYINFO_FLAGS)")

typedef [v1_enum] enum CATSORT_FLAGS
{
    CATSORT_DEFAULT     = 0x00000000,   // Default Sort order
    CATSORT_NAME        = 0x00000001,   // Sort by name
} CATSORT_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CATSORT_FLAGS)")

typedef struct CATEGORY_INFO
{
    CATEGORYINFO_FLAGS cif;
    WCHAR wszName[260];
} CATEGORY_INFO;

//-------------------------------------------------------------
// ICategorizer
//-------------------------------------------------------------

// Categorizes items
[
    uuid(a3b14589-9174-49a8-89a3-06a1ae2b9ba7),
    object,
    pointer_default(unique)
]
interface ICategorizer : IUnknown
{
    // Returns the description of this category that will be displayed in the UI
    HRESULT GetDescription(
        [out, string, size_is(cch)] LPWSTR pszDesc,
        [in] UINT cch);

    // Returns a list of categories associated with a list of ID Lists. NOTE: -1 is an invalid Category ID, and they cannot be persisted
    HRESULT GetCategory(
        [in] UINT cidl,
        [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,
        [out, size_is(cidl)] DWORD* rgCategoryIds);

    // Returns information about the category, such as default display and the text to display in the UI
    HRESULT GetCategoryInfo(
        [in] DWORD dwCategoryId,
        [out] CATEGORY_INFO* pci);

    // Returns HRESULTFromShort. -1, 0, 1 indicate the comparison of the IDs. Used for sorting categories in the UI
    HRESULT CompareCategory(
        [in] CATSORT_FLAGS csfFlags,
        [in] DWORD dwCategoryId1,
        [in] DWORD dwCategoryId2);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN2K)")

///////////////////////////////////////////////////////
//
// Drag and Drop helper
//
// Purpose: To expose the Shell drag images
//
// This interface is implemented in the shell by CLSID_DragDropHelper.
//
// To use:
//   If you are the source of a drag (i.e. in response to LV_DRAGBEGIN or
//    equivelent begin drag message) call
//    IDragSourceHelper::InitializeFromWindow
//              (<hwnd of window supporting DI_GETDRAGIMAGE>,
//               <pointer to POINT indicating offset to the mouse from
//                  the upper left corner of the image>,
//               <pointer to data object>)
//
//      NOTE: The Data object must support IDataObject::SetData with multiple
//            data types and GetData must implement data type cloning
//            (Including HGLOBAL), not just aliasing.
//
//   If you want to adjust the behavior of the drag image by calling
//    IDragSourceHelper2::SetFlags then that call to SetFlags should be
//    made before calling InitializeFromWindow or InitializeFromBitmap.
//
//   If you wish to have an image while over your application add the
//    IDragImages::Dr* calls to your IDropTarget implementation. For Example:
//
//    STDMETHODIMP CUserDropTarget::DragEnter(IDataObject* pDataObject,
//                                            DWORD grfKeyState,
//                                            POINTL pt, DWORD* pdwEffect)
//    {
//          // Process your DragEnter
//          // Call IDragImages::DragEnter last.
//          _pDropTargetHelper->DragEnter(_hwndDragOver, pDataObject,
//                                        (POINT*)&pt, *pdwEffect);
//          return hres;
//    }
//
//
//   If you wish to be able to source a drag image from a custom control,
//     implement a handler for the RegisterWindowMessage(DI_GETDRAGIMAGE).
//     The LPARAM is a pointer to an SHDRAGIMAGE structure.
//
//      sizeDragImage  -   Calculate the length and width required to render
//                          the images.
//      ptOffset       -   Calculate the offset from the upper left corner to
//                          the mouse cursor within the image
//      hbmpDragImage  -   CreateBitmap( sizeDragImage.cx, sizeDragImage.cy,
//                           GetDeviceCaps(hdcScreen, PLANES),
//                           GetDeviceCaps(hdcScreen, BITSPIXEL),
//                           NULL);
//
//   Drag Images will only be displayed on Windows NT 5.0 or later.
//
//
//   Note about IDropTargetHelper::Show - This method is provided for
//     showing/hiding the Drag image in low color depth video modes. When
//     painting to a window that is currently being dragged over (i.e. For
//     indicating a selection) you need to hide the drag image by calling this
//     method passing FALSE. After the window is done painting, Show the image
//     again by passing TRUE.

cpp_quote("#include <pshpack8.h>")
typedef struct SHDRAGIMAGE
{
    SIZE        sizeDragImage;      // OUT - The length and Width of the rendered image
    POINT       ptOffset;           // OUT - The Offset from the mouse cursor to the upper left corner of the image
    HBITMAP     hbmpDragImage;      // OUT - The Bitmap containing the rendered drag images
    COLORREF    crColorKey;         // OUT - The COLORREF that has been blitted to the background of the images
} SHDRAGIMAGE, *LPSHDRAGIMAGE;
cpp_quote("#include <poppack.h> // Return to byte packing")

// This is sent to a window to get the rendered images to a bitmap
// Call RegisterWindowMessage to get the ID
cpp_quote("#define DI_GETDRAGIMAGE     TEXT(\"ShellGetDragImage\")")

[
    uuid(4657278B-411B-11D2-839A-00C04FD918D0),
    local,
    pointer_default(unique)
]
interface IDropTargetHelper : IUnknown
{
    HRESULT DragEnter(
        [in, annotation("_In_")] HWND hwndTarget,
        [in, annotation("_In_")] IDataObject* pDataObject,
        [in, annotation("_In_")] POINT* ppt,
        [in, annotation("_In_")] DWORD dwEffect);

    HRESULT DragLeave();

    HRESULT DragOver(
        [in, annotation("_In_")] POINT* ppt,
        [in, annotation("_In_")] DWORD dwEffect);

    HRESULT Drop(
        [in, annotation("_In_")] IDataObject* pDataObject,
        [in, annotation("_In_")] POINT* ppt,
        [in, annotation("_In_")] DWORD dwEffect);

    HRESULT Show([in, annotation("_In_")] BOOL fShow);
}

[
    uuid(DE5BF786-477A-11D2-839D-00C04FD918D0),
    local,
    pointer_default(unique)
]
interface IDragSourceHelper: IUnknown
{
    // IDragSourceHelper
    HRESULT InitializeFromBitmap(
        [in, annotation("_In_")] LPSHDRAGIMAGE pshdi,
        [in, annotation("_In_")] IDataObject* pDataObject);

    HRESULT InitializeFromWindow(
        [in, unique, annotation("_In_opt_")] HWND hwnd,
        [in, unique, annotation("_In_opt_")] POINT* ppt,
        [in, annotation("_In_")] IDataObject* pDataObject);
}

cpp_quote("#endif  // NTDDI_WIN2K")

cpp_quote("#ifdef UNICODE")
cpp_quote("#define IShellLink      IShellLinkW")
cpp_quote("#else")
cpp_quote("#define IShellLink      IShellLinkA")
cpp_quote("#endif")

// IShellLink::Resolve fFlags
typedef[v1_enum] enum SLR_FLAGS
{
    SLR_NONE                      = 0x0,
    SLR_NO_UI                     = 0x0001,   // don't display any UI during the resolve operation, call blocks until done
    SLR_ANY_MATCH                 = 0x0002,   // no longer used
    SLR_UPDATE                    = 0x0004,   // save the link back to it's file if the track made it dirty
    SLR_NOUPDATE                  = 0x0008,   // don't update the link file (if there is one) if the resolve made it dirty
    SLR_NOSEARCH                  = 0x0010,   // don't execute the search heuristics
    SLR_NOTRACK                   = 0x0020,   // don't use the link tracking service (trkwks) to find the target
    SLR_NOLINKINFO                = 0x0040,   // don't use the network and volume serial number information
    SLR_INVOKE_MSI                = 0x0080,   // for MSI links call MSI to install the application
    SLR_NO_UI_WITH_MSG_PUMP       = 0x0101,   // don't display UI but enter a nested message loop and wait for the resolve to finish
    SLR_OFFER_DELETE_WITHOUT_FILE = 0x0200,   // offer the option to delete when unable to resolve, even if the shortcut is not stored in a file
    SLR_KNOWNFOLDER               = 0x0400,   // update known folder information if path changes due to folder redirection
    SLR_MACHINE_IN_LOCAL_TARGET   = 0x0800,   // resolve machine name in UNC targets pointing to local machine (used with SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET)
    SLR_UPDATE_MACHINE_AND_SID    = 0x1000,   // update machine GUID and user SID if necessary
    SLR_NO_OBJECT_ID              = 0x2000,   // don't use the Volume Id and Object Id to locate the file.
} SLR_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SLR_FLAGS)")

// IShellLink::GetPath fFlags
typedef [v1_enum] enum SLGP_FLAGS
{
    SLGP_SHORTPATH          = 0x0001,
    SLGP_UNCPRIORITY        = 0x0002,
    SLGP_RAWPATH            = 0x0004,
    SLGP_RELATIVEPRIORITY   = 0x0008,
} SLGP_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SLGP_FLAGS)")

[
    uuid(000214EE-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellLinkA : IUnknown
{
    HRESULT GetPath(
        [out, string, size_is(cch)] LPSTR pszFile,
        [in] int cch,
        [in, out, unique] WIN32_FIND_DATAA *pfd,
        [in] DWORD fFlags);

    HRESULT GetIDList(
        [out] PIDLIST_ABSOLUTE * ppidl);

    HRESULT SetIDList(
        [in] PCIDLIST_ABSOLUTE pidl);

    HRESULT GetDescription(
        [out, string, size_is(cch)] LPSTR pszName,
        [in] int cch);

    HRESULT SetDescription(
        [in, string] LPCSTR pszName);

    HRESULT GetWorkingDirectory(
        [out, string, size_is(cch)] LPSTR pszDir,
        [in] int cch);

    HRESULT SetWorkingDirectory(
        [in, string] LPCSTR pszDir);

    HRESULT GetArguments(
        [out, string, size_is(cch)] LPSTR pszArgs,
        [in] int cch);

    HRESULT SetArguments(
        [in, string] LPCSTR pszArgs);

    HRESULT GetHotkey(
        [out] WORD *pwHotkey);

    HRESULT SetHotkey(
        [in] WORD wHotkey);

    HRESULT GetShowCmd(
        [out] int *piShowCmd);

    HRESULT SetShowCmd(
        [in] int iShowCmd);

    HRESULT GetIconLocation(
        [out, string, size_is(cch)] LPSTR pszIconPath,
        [in] int cch,
        [out] int *piIcon);

    HRESULT SetIconLocation(
        [in, string] LPCSTR pszIconPath,
        [in] int iIcon);

    HRESULT SetRelativePath(
        [in, string] LPCSTR pszPathRel,
        [in] DWORD dwReserved);

    HRESULT Resolve(
        [in, unique] HWND hwnd,
        [in] DWORD fFlags);

    HRESULT SetPath(
        [in, string] LPCSTR pszFile);
}

[
    uuid(000214F9-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellLinkW : IUnknown
{
    HRESULT GetPath(
        [out, string, size_is(cch)] LPWSTR pszFile,
        [in] int cch,
        [in, out, unique] WIN32_FIND_DATAW *pfd,
        [in] DWORD fFlags);

    HRESULT GetIDList(
        [out] PIDLIST_ABSOLUTE * ppidl);

    HRESULT SetIDList(
        [in, unique] PCIDLIST_ABSOLUTE pidl);

    HRESULT GetDescription(
        [out, string, size_is(cch)] LPWSTR pszName,
        int cch);

    HRESULT SetDescription(
        [in, string] LPCWSTR pszName);

    HRESULT GetWorkingDirectory(
        [out, string, size_is(cch)] LPWSTR pszDir,
        int cch);

    HRESULT SetWorkingDirectory(
        [in, string] LPCWSTR pszDir);

    HRESULT GetArguments(
        [out, string, size_is(cch)] LPWSTR pszArgs,
        [in] int cch);

    HRESULT SetArguments(
        [in, string] LPCWSTR pszArgs);

    HRESULT GetHotkey(
        [out] WORD *pwHotkey);

    HRESULT SetHotkey(
        [in] WORD wHotkey);

    HRESULT GetShowCmd(
        [out] int *piShowCmd);

    HRESULT SetShowCmd(
        [in] int iShowCmd);

    HRESULT GetIconLocation(
        [out, string, size_is(cch)] LPWSTR pszIconPath,
        [in] int cch,
        [out] int *piIcon);

    HRESULT SetIconLocation(
        [in, string] LPCWSTR pszIconPath,
        [in] int iIcon);

    HRESULT SetRelativePath(
        [in, string] LPCWSTR pszPathRel,
        [in] DWORD dwReserved);

    HRESULT Resolve(
        [in, unique] HWND hwnd,
        [in] DWORD fFlags);

    HRESULT SetPath(
        [in, string] LPCWSTR pszFile);
}
[
    uuid(45e2b4ae-b1c3-11d0-b92f-00a0c90312e1),
    object,
    pointer_default(unique)
#ifdef BUILD_SPLIT_AS_IE
    ,local
#endif
]
interface IShellLinkDataList : IUnknown
{
    [local] HRESULT AddDataBlock(
        [in, annotation("_In_")] void * pDataBlock);

    [local] HRESULT CopyDataBlock(
        [in, annotation("_In_")] DWORD dwSig,
        [out, annotation("_Outptr_")] void **ppDataBlock);

    HRESULT RemoveDataBlock(
        [in] DWORD dwSig);

    // flags are SLDF_ values as defined in shlobj.h
    HRESULT GetFlags(
        [out] DWORD *pdwFlags);

    HRESULT SetFlags(
        [in] DWORD dwFlags);
}


cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN2K)")

// Link resolution helpers - called when a link is created or needs to be resolved.

[
    object,
    uuid(5cd52983-9449-11d2-963a-00c04f79adf0),
    pointer_default(unique)
]
interface IResolveShellLink : IUnknown
{
    HRESULT ResolveShellLink(
        [in] IUnknown *punkLink,
        [in, unique] HWND hwnd,
        [in] DWORD fFlags);
}

cpp_quote("#endif  // NTDDI_WIN2K")

// New for XP, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

[
    object,
    uuid(49ff1172-eadc-446d-9285-156453a6431c),
    pointer_default(unique)
]
interface IActionProgressDialog : IUnknown
{
    [v1_enum] enum _SPINITF
    {
        SPINITF_NORMAL         = 0x00000000,      // default normal progress behavior
        SPINITF_MODAL          = 0x00000001,      // call punkSite->EnableModeless() or EnableWindow()
        SPINITF_NOMINIMIZE     = 0x00000008,      // Do not have a minimize button in the caption bar.
    };
    typedef DWORD SPINITF;

    HRESULT Initialize(
        [in] SPINITF flags,
        [in, unique, string] LPCWSTR pszTitle,
        [in, unique, string] LPCWSTR pszCancel);

    HRESULT Stop();
}

// Do not use 0x1, it was used to indicate cancellation in legacy autoplay.
cpp_quote("#define ARCONTENT_AUTORUNINF             0x00000002   // That's the one we have today, and always had")
cpp_quote("#define ARCONTENT_AUDIOCD                0x00000004   // Audio CD (not MP3 and the like, the stuff you buy at the store)")
cpp_quote("#define ARCONTENT_DVDMOVIE               0x00000008   // DVD Movie (not MPEGs, the stuff you buy at the store)")
cpp_quote("#define ARCONTENT_BLANKCD                0x00000010   // Blank CD-R/CD-RW)")
cpp_quote("#define ARCONTENT_BLANKDVD               0x00000020   // Blank DVD-R/DVD-RW")
cpp_quote("#define ARCONTENT_UNKNOWNCONTENT         0x00000040   // Whatever files.  Mean that it's formatted.")
cpp_quote("#define ARCONTENT_AUTOPLAYPIX            0x00000080   // Any files classified by shell as image. (jpg, bmp, etc.)")
cpp_quote("#define ARCONTENT_AUTOPLAYMUSIC          0x00000100   // Any files classified by shell as music. (wma, mp3, etc.)")
cpp_quote("#define ARCONTENT_AUTOPLAYVIDEO          0x00000200   // Any files classified by shell as video. (mpg, avi, etc.)")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define ARCONTENT_VCD                    0x00000400   // VCD format")
cpp_quote("#define ARCONTENT_SVCD                   0x00000800   // Super-VCD format")
cpp_quote("#define ARCONTENT_DVDAUDIO               0x00001000   // DVD-Audio")
cpp_quote("#define ARCONTENT_BLANKBD                0x00002000   // Blank BD-R/BD-RW")
cpp_quote("#define ARCONTENT_BLURAY                 0x00004000   // Blu-ray Disc")
cpp_quote("#define ARCONTENT_CAMERASTORAGE          0x00008000   // Camera Storage")
cpp_quote("#define ARCONTENT_CUSTOMEVENT            0x00010000   // Custom Event")
cpp_quote("#define ARCONTENT_NONE                   0x00000000   // Empty (but formatted)")
cpp_quote("#define ARCONTENT_MASK                   0x0001FFFE   // Bits that denote valid content types")

cpp_quote("#define ARCONTENT_PHASE_UNKNOWN          0x00000000   // We can be in any phase.  This is XP behavior.")
cpp_quote("#define ARCONTENT_PHASE_PRESNIFF         0x10000000   // These are contents we know w/o scanning the media for complete data (e.g. Audio track, DVD Movie).")
cpp_quote("#define ARCONTENT_PHASE_SNIFFING         0x20000000   // We are in the middle of searching the media.  There could be more contents to be found than currently reported.")
cpp_quote("#define ARCONTENT_PHASE_FINAL            0x40000000   // We have finished searching; contents we report are final.")
cpp_quote("#define ARCONTENT_PHASE_MASK             0x70000000   // Bits that denote what phase we are in the Autoplay process.")
cpp_quote("#endif  // NTDDI_VISTA")

[
    object,
    uuid(49ff1173-eadc-446d-9285-156453a6431c),
    pointer_default(unique)
]
interface IActionProgress : IUnknown
{
    [v1_enum] enum _SPBEGINF
    {
        SPBEGINF_NORMAL             = 0x00000000,      // default normal progress behavior
        SPBEGINF_AUTOTIME           = 0x00000002,      // automatically updates the "time remaining" text
        SPBEGINF_NOPROGRESSBAR      = 0x00000010,      // Don't display the progress bar (SetProgress() wont be called)
        SPBEGINF_MARQUEEPROGRESS    = 0x00000020,      // use marquee progress (comctl32 v6 required)
        SPBEGINF_NOCANCELBUTTON     = 0x00000040,      // no cancel button
    };
    typedef DWORD SPBEGINF;

    typedef [v1_enum] enum _SPACTION {
        SPACTION_NONE                   = 0,
        SPACTION_MOVING,
        SPACTION_COPYING,
        SPACTION_RECYCLING,
        SPACTION_APPLYINGATTRIBS,
        SPACTION_DOWNLOADING,
        SPACTION_SEARCHING_INTERNET,
        SPACTION_CALCULATING,
        SPACTION_UPLOADING,
        SPACTION_SEARCHING_FILES,
        SPACTION_DELETING,                            // Vista or higher
        SPACTION_RENAMING,                            // Vista or higher
        SPACTION_FORMATTING,                          // Vista or higher
        SPACTION_COPY_MOVING,                         // Move as copy-delete, Windows 7 or higher
    } SPACTION;

    typedef [v1_enum] enum _SPTEXT
    {
        SPTEXT_ACTIONDESCRIPTION        = 1,
        SPTEXT_ACTIONDETAIL,
    } SPTEXT;

    HRESULT Begin(
        [in] SPACTION action,
        [in] SPBEGINF flags);

    HRESULT UpdateProgress(
        [in] ULONGLONG ulCompleted,
        [in] ULONGLONG ulTotal);

    HRESULT UpdateText(
        [in] SPTEXT sptext,
        [in, string] LPCWSTR pszText,
        [in] BOOL fMayCompact);

    HRESULT QueryCancel([out] BOOL * pfCancelled);

    HRESULT ResetCancel();

    HRESULT End();

}

//cpp_quote("#endif  // NTDDI_WINXP")

//  The IShellExtInit interface is used by the explorer to initialize shell
// extension objects. The explorer (1) calls CoCreateInstance (or equivalent)
// with the registered CLSID and IID_IShellExtInit, (2) calls its Initialize
// member, then (3) calls its QueryInterface to a particular interface (such
// as IContextMenu or IPropSheetExt and (4) performs the rest of operation.
//
// IShellExtInit::Initialize
//
//  This member function is called when the explorer is initializing either
// context menu extension, property sheet extension or non-default drag-drop
// extension.
//
//  Parameters: (context menu or property sheet extension)
//   pidlFolder -- Specifies the parent folder
//   lpdobj -- Spefifies the set of items selected in that folder.
//   hkeyProgID -- Specifies the type of the focused item in the selection.
//
//  Parameters: (non-default drag-and-drop extension)
//   pidlFolder -- Specifies the target (destination) folder
//   lpdobj -- Specifies the items that are dropped (see the description
//    about shell's clipboard below for clipboard formats).
//   hkeyProgID -- Specifies the folder type.

// used to initialize an object on a remote computer (server)
[
    uuid(000214E8-0000-0000-C000-000000000046),
    object,
    local,
    pointer_default(unique)
]
interface IShellExtInit : IUnknown
{
    HRESULT Initialize(
        [in, unique, annotation("_In_opt_")] PCIDLIST_ABSOLUTE pidlFolder,
        [in, unique, annotation("_In_opt_")] IDataObject *pdtobj,
        [in, unique, annotation("_In_opt_")] HKEY hkeyProgID);
}
typedef IShellExtInit * LPSHELLEXTINIT;


//  The explorer uses the IShellPropSheetExt to allow property sheet
// extensions or control panel extensions to add additional property
// sheet pages.
//
// IShellPropSheetExt::AddPages
//
//  The explorer calls this member function when it finds a registered
// property sheet extension for a particular type of object. For each
// additional page, the extension creates a page object by calling
// CreatePropertySheetPage API and calls lpfnAddPage.
//
//  Parameters:
//   lpfnAddPage -- Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//
// IShellPropSheetExt::ReplacePage
//
//  The explorer never calls this member of property sheet extensions. The
// explorer calls this member of control panel extensions, so that they
// can replace some of default control panel pages (such as a page of
// mouse control panel).
//
//  Parameters:
//   uPageID -- Specifies the page to be replaced.
//   lpfnReplace Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
[
    uuid(000214E9-0000-0000-C000-000000000046),
    object,
    local,
    pointer_default(unique)
]
interface IShellPropSheetExt : IUnknown
{
    [v1_enum] enum _EXPPS
    {
        EXPPS_FILETYPES     = 0x00000001,
    };
    typedef UINT EXPPS;

    HRESULT AddPages(
        [in, annotation("_In_")] LPFNSVADDPROPSHEETPAGE pfnAddPage,
        [in, annotation("_In_")] LPARAM lParam);

    HRESULT ReplacePage(
        [in, annotation("_In_")] EXPPS uPageID,
        [in, annotation("_In_")] LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
        [in, annotation("_In_")] LPARAM lParam);
}
typedef IShellPropSheetExt * LPSHELLPROPSHEETEXT;

[
    uuid(000214FE-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IRemoteComputer : IUnknown
{
    // function is called when the explorer is initializing or
    // enumerating the name space extension. If failure is returned during
    // enumeration, the extension won't appear for this computer. Otherwise,
    // the extension will appear, and should target the given machine.
    //
    // pszMachine       Specifies the name of the machine to target. (\\server)
    // bEnumerationg    test to see if this object should be enumerated
    //                  on this server
    HRESULT Initialize(
        [in, string] LPCWSTR pszMachine,
        [in] BOOL bEnumerating);
}

[
    uuid(7307055c-b24a-486b-9f25-163e597a28a9),
    object,
    pointer_default(unique)
]
interface IQueryContinue : IUnknown
{
    HRESULT QueryContinue();    // S_OK -> Continue, S_FALSE -> Cancel
}

// This interface supplies a caller with an event that will be signaled
// by the callee to denote cancellation of a task.

[
    uuid(F279B885-0AE9-4b85-AC06-DDECF9408941),
    object,
    local,
    pointer_default(unique)
]
interface IObjectWithCancelEvent : IUnknown
{
    // Call this function to retrieve an event that will be signaled when
    // the callee cancels the operation it's performing.
    // The caller is responsible for closing the returned handle.
    HRESULT GetCancelEvent([out, annotation("_Out_")] HANDLE *phEvent);
}

[
    uuid(ba9711ba-5893-4787-a7e1-41277151550b),
    object,
    pointer_default(unique)
]
interface IUserNotification : IUnknown
{
    HRESULT SetBalloonInfo(
        [in, unique, string] LPCWSTR pszTitle,
        [in, unique, string] LPCWSTR pszText,
        [in] DWORD dwInfoFlags);

    HRESULT SetBalloonRetry(
        [in] DWORD dwShowTime,  // times in msec
        [in] DWORD dwInterval,
        [in] UINT cRetryCount);

    HRESULT SetIconInfo(
        [in, unique] HICON hIcon,
        [in, unique, string] LPCWSTR pszToolTip);

    HRESULT Show(
        [in, unique] IQueryContinue *pqc,
        [in] DWORD dwContinuePollInterval);

    HRESULT PlaySound([in, string] LPCWSTR pszSoundName);
}

// interface for describing the limits placed on a name, used for validation
// parsing and translation.

[
    uuid(1df0d7f1-b267-4d28-8b10-12e23202a5c4)
]
interface IItemNameLimits : IUnknown
{
    HRESULT GetValidCharacters(
        [out, string] LPWSTR *ppwszValidChars,
        [out, string] LPWSTR *ppwszInvalidChars);

    HRESULT GetMaxLength(
        [in, string] LPCWSTR pszName,
        [out] int *piMaxNameLen);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

[
    object,
    uuid(a0ffbc28-5482-4366-be27-3e81e78e06c2),
    pointer_default(unique)
]
interface ISearchFolderItemFactory : IUnknown
{
    HRESULT SetDisplayName(
        [in, string] LPCWSTR pszDisplayName);

    HRESULT SetFolderTypeID(
        [in] FOLDERTYPEID ftid);

    HRESULT SetFolderLogicalViewMode(
        [in] FOLDERLOGICALVIEWMODE flvm);

    HRESULT SetIconSize(
        [in] int iIconSize);

    HRESULT SetVisibleColumns(
        [in] UINT cVisibleColumns,
        [in, size_is(cVisibleColumns)] PROPERTYKEY const *rgKey);

    HRESULT SetSortColumns(
        [in] UINT cSortColumns,
        [in, size_is(cSortColumns)] SORTCOLUMN *rgSortColumns);

    HRESULT SetGroupColumn(
        [in] REFPROPERTYKEY keyGroup);

    HRESULT SetStacks(
        [in] UINT cStackKeys,
        [in, size_is(cStackKeys)] PROPERTYKEY *rgStackKeys);

    HRESULT SetScope(
        [in] IShellItemArray *psiaScope);

    HRESULT SetCondition(
        [in] ICondition *pCondition);

    HRESULT GetShellItem(
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);    // returns IShellItem, navigate to this

    HRESULT GetIDList(
        [out] PIDLIST_ABSOLUTE *ppidl);
}

cpp_quote("#endif  // NTDDI_VISTA")

// --- IExtractImage
// this interface is provided for objects to provide a thumbnail image.
// IExtractImage::GetLocation()
//      Gets a path description of the image that is to be extracted. This is used to
//      identify the image in the view so that multiple instances of the same image can reuse the
//      original image. If *pdwFlags == IEIFLAG_ASYNC and the result is E_PENDING, then *pdwPriority
//      is used to return the priority of the item, this is usually a measure of how long it will take
//      to perform the extraction. *pdwFlags can return IEIFLAG_CACHE if the view should cache a copy
//      of the image for future reference and faster access. This flag is used to tell the difference
//      between file formats that cache a thumbnail image such as Flashpix or Office documents, and those
//      that don't cache one.
// IExtractImage::Extract()
//      Extract the thumbnail of the specified size. If GetLocation() returned the values indicating
//      it is free-threaded and can be placed on a background thread. If the object
//      supports IRunnableTask as well, then long extractions can be started and paused as appropriate.
//      At this point it is asssumed the object is free-threaded.
//      If dwRecClrDepth contains a recommended Colour depth
//      If *phBmpthumbnail is non NULL, then it contains the destination bitmap that should be used.

cpp_quote("#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY")
cpp_quote("#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY")
cpp_quote("#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY")

cpp_quote("#define IEIFLAG_ASYNC       0x0001      // (deprecated) ask the extractor if it supports ASYNC extract (free threaded)")
cpp_quote("#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail")
cpp_quote("#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect")
cpp_quote("#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering")
cpp_quote("#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does")
cpp_quote("#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )")
cpp_quote("#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary")
cpp_quote("#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail")
cpp_quote("#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail")
cpp_quote("#define IEIFLAG_QUALITY     0x0200      // passed to the Extract method to indicate that a slower, higher quality image is desired, re-compute the thumbnail")
cpp_quote("#define IEIFLAG_REFRESH     0x0400      // returned from the extractor if it would like to have Refresh Thumbnail available")

[
    uuid(BB2E617C-0920-11d1-9A0B-00C04FC2D6C1),
    object,
    pointer_default(unique)
]
interface IExtractImage : IUnknown
{
    HRESULT GetLocation(
        [out, string, size_is(cch)] LPWSTR pszPathBuffer,
        [in] DWORD cch,
        [in, out, unique] DWORD *pdwPriority,
        [in] const SIZE * prgSize,
        [in] DWORD dwRecClrDepth,
        [in, out] DWORD *pdwFlags);

   HRESULT Extract(
       [out] HBITMAP *phBmpThumbnail);
}
typedef IExtractImage * LPEXTRACTIMAGE;

// GetDateStamp : returns the date stamp associated with the image. If this image is already cached,
//                then it is easy to find out if the image is out of date.

[
    uuid(953BB1EE-93B4-11d1-98A3-00C04FB687DA),
    object,
    pointer_default(unique)
]
interface IExtractImage2 : IExtractImage
{
    HRESULT GetDateStamp([out] FILETIME *pDateStamp);
}
typedef IExtractImage2 * LPEXTRACTIMAGE2;

[
    uuid(e35b4b2e-00da-4bc1-9f13-38bc11f5d417),
    object,
    pointer_default(unique)
]
interface IThumbnailHandlerFactory : IUnknown
{
    HRESULT GetThumbnailHandler(
        [in] PCUITEMID_CHILD pidlChild,
        [in, unique] IBindCtx *pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
}

[
    uuid(b3a4b685-b685-4805-99d9-5dead2873236),  // IID_IParentAndItem
    object,
    pointer_default(unique)
]
interface IParentAndItem : IUnknown
{
    // 2 ways to init
    //      pidlParent == NULL
    //      psf is folder, pidlChild is child relative to psf
    HRESULT SetParentAndItem(
        [in, unique] PCIDLIST_ABSOLUTE pidlParent,
        [in, unique] IShellFolder *psf,
        [in] PCUITEMID_CHILD pidlChild);

    // all params optional
    //      ppidlParent gets full pidl to parent of item
    //      ppsf gets parent folder for item
    //      ppidlChild gets item relitve to psf
    [local]
    HRESULT GetParentAndItem(
        [out, annotation("_Outptr_opt_")] PIDLIST_ABSOLUTE *ppidlParent,
        [out, annotation("_Outptr_opt_")] IShellFolder **ppsf,
        [out, annotation("_Outptr_opt_")] PITEMID_CHILD *ppidlChild);

    [call_as(GetParentAndItem)]
    HRESULT RemoteGetParentAndItem(
        [out] PIDLIST_ABSOLUTE *ppidlParent,
        [out] IShellFolder **ppsf,
        [out] PITEMID_CHILD *ppidlChild);
}

//-------------------------------------------------------------------------
//
// IDockingWindow interface
//
//   An object (docking window) implements this interface so the site can
// communicate with it.  An example of a docking window is a toolbar.
//
// [Member functions]
//
// IDockingWindow::ShowDW(fShow)
//   Shows or hides the docking window.
//
// IDockingWindow::CloseDW(dwReserved)
//   Closes the docking window.  dwReserved must be 0.
//
// IDockingWindow::ResizeBorderDW(prcBorder, punkToolbarSite, fReserved)
//   Resizes the docking window's border to *prcBorder.  fReserved must
//   be 0.
//
// IObjectWithSite::SetSite(punkSite)
//   IDockingWindow usually paired with IObjectWithSite.
//   Provides the IUnknown pointer of the site to the docking window.
//
//-------------------------------------------------------------------------

[
    uuid(012dd920-7b26-11d0-8ca9-00a0c92dbfe8),
    object
]
interface IDockingWindow : IOleWindow
{
    HRESULT ShowDW([in] BOOL fShow);

    HRESULT CloseDW([in] DWORD dwReserved);

    HRESULT ResizeBorderDW(
        [in, unique] LPCRECT prcBorder,
        [in, unique] IUnknown* punkToolbarSite,
        [in] BOOL fReserved);
}

//-------------------------------------------------------------------------
//
// IDeskBand interface
//
//
// [Member functions]
//
// IDeskBand::GetBandInfo(dwBandID, dwViewMode, pdbi)
//   Returns info on the given band in *pdbi, according to the mask
//   field in the DESKBANDINFO structure and the given viewmode.
//
//-------------------------------------------------------------------------


// Mask values for DESKBANDINFO
cpp_quote("#define DBIM_MINSIZE    0x0001")
cpp_quote("#define DBIM_MAXSIZE    0x0002")
cpp_quote("#define DBIM_INTEGRAL   0x0004")
cpp_quote("#define DBIM_ACTUAL     0x0008")
cpp_quote("#define DBIM_TITLE      0x0010")
cpp_quote("#define DBIM_MODEFLAGS  0x0020")
cpp_quote("#define DBIM_BKCOLOR    0x0040")

cpp_quote("#include <pshpack8.h>")

typedef struct DESKBANDINFO
{
    DWORD       dwMask;
    POINTL      ptMinSize;
    POINTL      ptMaxSize;
    POINTL      ptIntegral;
    POINTL      ptActual;
    WCHAR       wszTitle[256];
    DWORD       dwModeFlags;
    COLORREF    crBkgnd;
} DESKBANDINFO;

cpp_quote("#include <poppack.h>")   // Return to byte packing

// DESKBANDINFO dwModeFlags values
cpp_quote("#define DBIMF_NORMAL            0x0000")
cpp_quote("#define DBIMF_FIXED             0x0001")
cpp_quote("#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)")
cpp_quote("#define DBIMF_VARIABLEHEIGHT    0x0008")
cpp_quote("#define DBIMF_UNDELETEABLE      0x0010")
cpp_quote("#define DBIMF_DEBOSSED          0x0020")
cpp_quote("#define DBIMF_BKCOLOR           0x0040")
cpp_quote("#define DBIMF_USECHEVRON        0x0080")
cpp_quote("#define DBIMF_BREAK             0x0100")
cpp_quote("#define DBIMF_ADDTOFRONT        0x0200")
cpp_quote("#define DBIMF_TOPALIGN          0x0400")
cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("#define DBIMF_NOGRIPPER         0x0800")
cpp_quote("#define DBIMF_ALWAYSGRIPPER     0x1000")
cpp_quote("#define DBIMF_NOMARGINS         0x2000")
cpp_quote("#endif  // NTDDI_VISTA")

// GetBandInfo view mode values
cpp_quote("#define DBIF_VIEWMODE_NORMAL         0x0000")
cpp_quote("#define DBIF_VIEWMODE_VERTICAL       0x0001")
cpp_quote("#define DBIF_VIEWMODE_FLOATING       0x0002")
cpp_quote("#define DBIF_VIEWMODE_TRANSPARENT    0x0004")

// Command Target IDs
enum tagDESKBANDCID
{
    DBID_BANDINFOCHANGED    = 0,
    DBID_SHOWONLY           = 1,
    DBID_MAXIMIZEBAND       = 2,      // Maximize the specified band (VT_UI4 == dwID)
    DBID_PUSHCHEVRON        = 3,
    DBID_DELAYINIT          = 4,      // Note: _bandsite_ calls _band_ with this code
    DBID_FINISHINIT         = 5,      // Note: _bandsite_ calls _band_ with this code
    DBID_SETWINDOWTHEME     = 6,      // Note: _bandsite_ calls _band_ with this code
    DBID_PERMITAUTOHIDE     = 7,
};

cpp_quote("#define DBPC_SELECTFIRST    (DWORD)-1")
cpp_quote("#define DBPC_SELECTLAST     (DWORD)-2")

cpp_quote("#define CGID_DeskBand IID_IDeskBand")

[
    uuid(EB0FE172-1A3A-11D0-89B3-00A0C90A90AC),
    object,
]
interface IDeskBand : IDockingWindow
{
    HRESULT GetBandInfo(
        [in] DWORD dwBandID,
        [in] DWORD dwViewMode,
        [in, out] DESKBANDINFO* pdbi);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
//-------------------------------------------------------------------------
//
// IDeskBandInfo interface
//
//
// [Member functions]
//
// IDeskBandInfo::GetDefaultBandWidth(dwBandID, dwViewMode, puWidth)
//   Call back by bandsite to get the band width that bandsite uses to set
//   the default width of the band when the band is first added/docked to
//   bandsite.
//
//-------------------------------------------------------------------------
[
    uuid(77E425FC-CBF9-4307-BA6A-BB5727745661),
    object,
]
interface IDeskBandInfo : IUnknown
{
    HRESULT GetDefaultBandWidth(
        [in] DWORD dwBandID,
        [in] DWORD dwViewMode,
        [out] int *pnWidth);
}

cpp_quote("#endif  // NTDDI_VISTA")

//-------------------------------------------------------------------------
//
// ITaskbarList interface
//
//
// [Member functions]
//
// ITaskbarList::HrInit()
//   This function must be called first to validate use of other members.
//
// ITaskbarList::AddTab(hwnd)
//   This function adds a tab for hwnd to the taskbar.
//
// ITaskbarList::DeleteTab(hwnd)
//   This function deletes a tab for hwnd from the taskbar.
//
// ITaskbarList::ActivateTab(hwnd)
//   This function activates the tab associated with hwnd on the taskbar.
//
// ITaskbarList::SetActivateAlt(hwnd)
//   This function marks hwnd in the taskbar as the active tab
//
//-------------------------------------------------------------------------
[
    uuid(56FDF342-FD6D-11d0-958A-006097C9A090),
    object,
]
interface ITaskbarList : IUnknown
{
    HRESULT HrInit();

    HRESULT AddTab([in] HWND hwnd);

    HRESULT DeleteTab([in] HWND hwnd);

    HRESULT ActivateTab([in] HWND hwnd);

    HRESULT SetActiveAlt([in] HWND hwnd);
}

[
    uuid(602D4995-B13A-429b-A66E-1935E44F4317),
    object,
]
interface ITaskbarList2 : ITaskbarList
{
    HRESULT MarkFullscreenWindow(
        [in] HWND hwnd,
        [in] BOOL fFullscreen);
}

cpp_quote("#ifdef MIDL_PASS")
typedef IUnknown* HIMAGELIST;
cpp_quote("#endif")

typedef [v1_enum] enum THUMBBUTTONFLAGS
{
    THBF_ENABLED        =   0x00000000,
    THBF_DISABLED       =   0x00000001,
    THBF_DISMISSONCLICK =   0x00000002,
    THBF_NOBACKGROUND   =   0x00000004,
    THBF_HIDDEN         =   0x00000008,
    THBF_NONINTERACTIVE =   0x00000010,
} THUMBBUTTONFLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(THUMBBUTTONFLAGS)")

typedef [v1_enum] enum THUMBBUTTONMASK
{
    THB_BITMAP          =   0x00000001,
    THB_ICON            =   0x00000002,
    THB_TOOLTIP         =   0x00000004,
    THB_FLAGS           =   0x00000008,
} THUMBBUTTONMASK;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(THUMBBUTTONMASK)")

cpp_quote("#include <pshpack8.h>")

typedef struct THUMBBUTTON
{
    THUMBBUTTONMASK  dwMask;
    UINT    iId;
    UINT    iBitmap;
    HICON   hIcon;
    WCHAR   szTip[260];
    THUMBBUTTONFLAGS  dwFlags;
} THUMBBUTTON, *LPTHUMBBUTTON;

cpp_quote("#include <poppack.h>")

cpp_quote("#define THBN_CLICKED        0x1800")

[
    uuid(ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf),
    object,
]
interface ITaskbarList3 : ITaskbarList2
{
    // Flags for Setting Taskbar Progress state
    typedef [v1_enum] enum TBPFLAG
    {
        TBPF_NOPROGRESS     = 0x00000000,
        TBPF_INDETERMINATE  = 0x00000001,
        TBPF_NORMAL         = 0x00000002,
        TBPF_ERROR          = 0x00000004,
        TBPF_PAUSED         = 0x00000008,
    } TBPFLAG;
    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(TBPFLAG)")

    HRESULT SetProgressValue(
        [in] HWND hwnd,
        [in] ULONGLONG ullCompleted,
        [in] ULONGLONG ullTotal);

    HRESULT SetProgressState(
        [in] HWND hwnd,
        [in] TBPFLAG tbpFlags);

    HRESULT RegisterTab(
        [in] HWND hwndTab,
        [in] HWND hwndMDI);

    HRESULT UnregisterTab(
        [in] HWND hwndTab);

    HRESULT SetTabOrder(
        [in] HWND hwndTab,
        [in] HWND hwndInsertBefore);

    HRESULT SetTabActive(
        [in] HWND hwndTab,
        [in] HWND hwndMDI,
        [in] DWORD dwReserved);

    HRESULT ThumbBarAddButtons(
        [in] HWND hwnd,
        [in] UINT cButtons,
        [in, size_is(cButtons)] LPTHUMBBUTTON pButton);

    HRESULT ThumbBarUpdateButtons(
        [in] HWND hwnd,
        [in] UINT cButtons,
        [in, size_is(cButtons)] LPTHUMBBUTTON pButton);

    HRESULT ThumbBarSetImageList(
        [in] HWND hwnd,
        [in] HIMAGELIST himl);

    HRESULT SetOverlayIcon(
        [in] HWND hwnd,
        [in] HICON hIcon,
        [in, unique, string] LPCWSTR pszDescription);

    HRESULT SetThumbnailTooltip(
        [in] HWND hwnd,
        [in, unique, string] LPCWSTR pszTip);

    HRESULT SetThumbnailClip(
        [in] HWND hwnd,
        [in] RECT *prcClip);
}

[
    uuid(c43dc798-95d1-4bea-9030-bb99e2983a1a),
    object,
]
interface ITaskbarList4 : ITaskbarList3
{
    // Flags for Setting Tab Properties
    typedef [v1_enum] enum STPFLAG
    {
        STPF_NONE                       = 0x00000000,
        STPF_USEAPPTHUMBNAILALWAYS      = 0x00000001,
        STPF_USEAPPTHUMBNAILWHENACTIVE  = 0x00000002,
        STPF_USEAPPPEEKALWAYS           = 0x00000004,
        STPF_USEAPPPEEKWHENACTIVE       = 0x00000008,
    } STPFLAG;
    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(STPFLAG)")

    HRESULT SetTabProperties(
        [in] HWND hwndTab,
        [in] STPFLAG stpFlags);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

//  Event sink interface for IExplorerBrowser events
[
    uuid(361bbdc7-e6ee-4e13-be58-58e2240c810f),    // IID_IExplorerBrowserEvents
    object
]
interface IExplorerBrowserEvents : IUnknown
{
    // Returning failure from this will cancel the navigation.
    HRESULT OnNavigationPending([in] PCIDLIST_ABSOLUTE pidlFolder);

    // Called once the view window has been created.  Do any last minute modifcations
    //  to the view here before it is shown (set view modes, folder flags, etc...)
    HRESULT OnViewCreated([in] IShellView *psv);

    // Called once the navigation has succeeded (after OnViewCreated).
    HRESULT OnNavigationComplete([in] PCIDLIST_ABSOLUTE pidlFolder);

    // Called if a navigation failed, despite the call to IShellBrowser::BrowseObject succeeding.
    HRESULT OnNavigationFailed([in] PCIDLIST_ABSOLUTE pidlFolder);
}

// IExplorerBrowser::SetOptions() flags
typedef [v1_enum] enum EXPLORER_BROWSER_OPTIONS
{
    EBO_NONE               = 0x00000000,     // No options
    EBO_NAVIGATEONCE       = 0x00000001,     // Don't navigate after initial navigation
    EBO_SHOWFRAMES         = 0X00000002,     // Show with frame module manager on - otherwise, single view object
    EBO_ALWAYSNAVIGATE     = 0x00000004,     // Always navigate, even if you are attempting to navigate to the current folder
    EBO_NOTRAVELLOG        = 0x00000008,     // Do not update travel log
    EBO_NOWRAPPERWINDOW    = 0x00000010,     // For legacy clients that need the browser parented directly on themselves
    EBO_HTMLSHAREPOINTVIEW = 0x00000020,     // Show WebView for sharepoint sites
    EBO_NOBORDER           = 0x00000040,     // Do not draw a border around ExplorerBrowser's HWND - Windows 8 and above
    EBO_NOPERSISTVIEWSTATE = 0x00000080,     // Do not persist the view state
} EXPLORER_BROWSER_OPTIONS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(EXPLORER_BROWSER_OPTIONS)")

// IExplorerBrowser::FillFromObject() flags
// Cannot conflict with SBSP_... flags from IShellBrowser::BrowseObject()
typedef [v1_enum] enum EXPLORER_BROWSER_FILL_FLAGS
{
    EBF_NONE                  = 0x0000000,   // No flags
    // Causes FillFromObject to populate the ResultsFolder with the
    // contents of the parent folders of the items in the DataObject
    // and then check-selects only the items that are in the DataObject
    EBF_SELECTFROMDATAOBJECT  = 0x0000100,
    // don't regsiter a drop target for the view, this enables apps to register their own drop target
    // that they can use to receive the drops
    EBF_NODROPTARGET          = 0x0000200,
} EXPLORER_BROWSER_FILL_FLAGS;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(EXPLORER_BROWSER_FILL_FLAGS)")

//
//  This allows you to host a simple browser (CLSID_ExplorerBrowser) that can be navigated
//  or host a view of a data object.   Use either BrowseToIDList or BrowseToObject to navigate
//  the browser or use FillWithDataObject to create the view on the data object.
//
[
    uuid(dfd3b6b5-c10c-4be9-85f6-a66969f402f6),
    object,
]
interface IExplorerBrowser : IUnknown
{
    // to clean up this object you must call ::Destroy.
    [local] HRESULT Initialize(
        [in, annotation("_In_")] HWND hwndParent,
        [in, annotation("_In_")] const RECT *prc,
        [in, unique, annotation("_In_opt_")] const FOLDERSETTINGS *pfs);

    HRESULT Destroy();

    [local] HRESULT SetRect(
        [in, out, unique, annotation("_Inout_opt_")] HDWP *phdwp,
        [in, annotation("_In_")] RECT rcBrowser);  // relative to hwndParent

    HRESULT SetPropertyBag([in, string] LPCWSTR pszPropertyBag);  // Property bag for view state persistence

    HRESULT SetEmptyText([in, string] LPCWSTR pszEmptyText);  // Displayed when view is empty

    HRESULT SetFolderSettings([in] const FOLDERSETTINGS *pfs);  // Sets how view displays / operates

    HRESULT Advise([in] IExplorerBrowserEvents *psbe, [out] DWORD *pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    HRESULT SetOptions([in] EXPLORER_BROWSER_OPTIONS dwFlag);

    HRESULT GetOptions([out] EXPLORER_BROWSER_OPTIONS *pdwFlag);

    // navigate the browser to a particular location
    // uFlags contains SBSP_ flag values
    HRESULT BrowseToIDList([in] PCUIDLIST_RELATIVE pidl, [in] UINT uFlags);

    // punk is a shell item (IShellItem) or any object that can produce an IDList
    // using SHGetIDListFromObject()
    // uFlags contains SBSP_ flag values
    HRESULT BrowseToObject([in] IUnknown *punk, [in] UINT uFlags);

    // populate from a given data source
    // punk can be an IDataObject or anything that can be used with INamespaceWalk
    HRESULT FillFromObject([in, unique] IUnknown *punk, [in] EXPLORER_BROWSER_FILL_FLAGS dwFlags);

    HRESULT RemoveAll();

    // return the current view object on IShellView or IFolderView or related interface
    HRESULT GetCurrentView([in] REFIID riid, [out, iid_is(riid)] void **ppv);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

// Unknown Object Enumerator
[
    uuid(2c1c7e2e-2d0e-4059-831e-1e6f82335c2e),
    object,
    pointer_default(unique)
]
interface IEnumObjects : IUnknown
{
    [local] HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [in, annotation("_In_")] REFIID riid,
        [out, size_is(celt), length_is(*pceltFetched), iid_is(riid), annotation("_Out_writes_to_(celt, *pceltFetched)")] void **rgelt,
        [out, annotation("_Out_opt_ _Deref_out_range_(0, celt)")] ULONG *pceltFetched);

    [call_as(Next)] HRESULT RemoteNext(
        [in] ULONG celt,
        [in] REFIID riid,
        [out, size_is(celt), length_is(*pceltFetched), iid_is(riid)] void **rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumObjects **ppenum);
}

[v1_enum] enum _OPPROGDLGF
{
    // The flag space includes OPPROGDLG_ and PROGDLG_ values
    // please guarantee they don't conflict. See shlobj.w for PROGDLG_*
    OPPROGDLG_DEFAULT               = 0x00000000,
    OPPROGDLG_ENABLEPAUSE           = 0x00000080,   // Add a pause button (operation can be paused)
    OPPROGDLG_ALLOWUNDO             = 0x00000100,   // The operation can be undone in the dialog.  (The Stop button becomes Undo)
    OPPROGDLG_DONTDISPLAYSOURCEPATH = 0x00000200,   // Don't display the path of source file in progress dialog
    OPPROGDLG_DONTDISPLAYDESTPATH   = 0x00000400,   // Don't display the path of destination file in progress dialog
    OPPROGDLG_NOMULTIDAYESTIMATES   = 0x00000800,   // deprecated - progress dialog no longer displays > 1 day estimates
    OPPROGDLG_DONTDISPLAYLOCATIONS  = 0x00001000,   // Don't display the location line in the progress dialog
};
typedef DWORD OPPROGDLGF;

// Shell Operations Engine Progress Dialog
[
    uuid(0C9FB851-E5C9-43EB-A370-F0677B13874C),
    object,
    pointer_default(unique)
]
interface IOperationsProgressDialog : IUnknown
{
    [v1_enum] enum _PDMODE
    {
        PDM_DEFAULT        = 0x00000000,
        PDM_RUN            = 0x00000001,       // Operation is running
        PDM_PREFLIGHT      = 0x00000002,       // Pre-flight mode, calculating operation time, etc
        PDM_UNDOING        = 0x00000004,       // Operation is rolling back, undo has been selected
        PDM_ERRORSBLOCKING = 0x00000008,       // Only errors remain, error dialogs are blocking progress from completing
        PDM_INDETERMINATE  = 0x00000010,       // The length of the operation is indeterminate, don't show a timer, progressbar is in marquee mode
    };
    typedef DWORD PDMODE;

    typedef [v1_enum] enum PDOPSTATUS
    {
        PDOPS_RUNNING   = 1,       // Operation is running, no user intervention
        PDOPS_PAUSED    = 2,       // Operation has been paused by the user
        PDOPS_CANCELLED = 3,       // Operation has been cancelled by the user - now go undo
        PDOPS_STOPPED   = 4,       // Operation has been stopped by the user - terminate completely
        PDOPS_ERRORS    = 5,       // Operation has gone as far as it can without throwing error dialogs
    } PDOPSTATUS;

    HRESULT StartProgressDialog([in, unique] HWND hwndOwner, [in] OPPROGDLGF flags);

    HRESULT StopProgressDialog();

    // Sets which operation is occuring, and whether we are in pre-flight or undo mode - sets animations, text, etc.
    HRESULT SetOperation([in] SPACTION action);

    HRESULT SetMode([in] PDMODE mode);

    HRESULT UpdateProgress(
       [in] ULONGLONG ullPointsCurrent,     // Progress (in points) we are currently at
       [in] ULONGLONG ullPointsTotal,       // Progress (in points) to go to timer
       [in] ULONGLONG ullSizeCurrent,       // Progress (in bytes) we are currently at
       [in] ULONGLONG ullSizeTotal,         // Progress (in bytes) total
       [in] ULONGLONG ullItemsCurrent,      // Progress (in # of items) we are currently at
       [in] ULONGLONG ullItemsTotal);       // Progress (in # of items) total

    // Used to generate display for "from <item (path)> to <item (path)>", etc.
    HRESULT UpdateLocations(
        [in, unique] IShellItem *psiSource,
        [in, unique] IShellItem *psiTarget,
        [in, unique] IShellItem *psiItem);

    HRESULT ResetTimer();

    HRESULT PauseTimer();

    HRESULT ResumeTimer();

    HRESULT GetMilliseconds([out] ULONGLONG *pullElapsed, [out] ULONGLONG *pullRemaining);

    // Returns running/paused/cancelled, etc.
    HRESULT GetOperationStatus([out] PDOPSTATUS *popstatus);
}

// Handles the thread ID and message information used after cancelling progress UI
[
    uuid(f5b0bf81-8cb5-4b1b-9449-1a159e0c733c),
    object,
    pointer_default(unique),
    local
]
interface IIOCancelInformation : IUnknown
{
    // When the progress UI is cancled by the user, dwThreadID will have
    // 1) any pending or future IO requests canceled using CancelSynchronousIo()
    // 2) uMsgCancel will be posted to the thread to tell it to
    //    exit a wait that it might be in waiting for async IO to complete
    HRESULT SetCancelInformation([in] DWORD dwThreadID, [in] UINT uMsgCancel);
    HRESULT GetCancelInformation([out, annotation("_Out_opt_")] DWORD *pdwThreadID, [out, annotation("_Out_opt_")] UINT *puMsgCancel);
}

// Extended FOF_ flags passed to IFileOperation::SetOperationFlags()
// These flags only work with IFileOperation not SHFileOperation.
// other posible FOF_ flags are specified in shellapi.h

cpp_quote("#define FOFX_NOSKIPJUNCTIONS         0x00010000  // Don't avoid binding to junctions (like Task folder, Recycle-Bin)")
cpp_quote("#define FOFX_PREFERHARDLINK          0x00020000  // Create hard link if possible")
cpp_quote("#define FOFX_SHOWELEVATIONPROMPT     0x00040000  // Show elevation prompts when error UI is disabled (use with FOF_NOERRORUI)")
cpp_quote("#define FOFX_RECYCLEONDELETE         0x00080000  // Recycle when deleting, rather than permanently deleting")
cpp_quote("#define FOFX_EARLYFAILURE            0x00100000  // Fail operation as soon as a single error occurs rather than trying to process other items (applies only when using FOF_NOERRORUI)")
cpp_quote("#define FOFX_PRESERVEFILEEXTENSIONS  0x00200000  // Rename collisions preserve file extns (use with FOF_RENAMEONCOLLISION)")
cpp_quote("#define FOFX_KEEPNEWERFILE           0x00400000  // Keep newer file on naming conflicts")
cpp_quote("#define FOFX_NOCOPYHOOKS             0x00800000  // Don't use copy hooks")
cpp_quote("#define FOFX_NOMINIMIZEBOX           0x01000000  // Don't allow minimizing the progress dialog")
cpp_quote("#define FOFX_MOVEACLSACROSSVOLUMES   0x02000000  // Copy security information when performing a cross-volume move operation")
cpp_quote("#define FOFX_DONTDISPLAYSOURCEPATH   0x04000000  // Don't display the path of source file in progress dialog")
cpp_quote("#define FOFX_DONTDISPLAYDESTPATH     0x08000000  // Don't display the path of destination file in progress dialog")
cpp_quote("#define FOFX_REQUIREELEVATION        0x10000000  // User expects the elevation; don't show a dialog to confirm")
cpp_quote("#define FOFX_ADDUNDORECORD           0x20000000  // This is a user-invoked operation, and should be placed on the undo stack.  This flag is preferred to FOF_ALLOWUNDO")
cpp_quote("#define FOFX_COPYASDOWNLOAD          0x40000000  // Show Downloading instead of Copying")
cpp_quote("#define FOFX_DONTDISPLAYLOCATIONS    0x80000000  // Hides the locations line in the progress dialog")

// Shell Copy/Move/Rename/Delete/Link/ApplyProperties Operation Handler
[
    uuid(947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8),
    object,
    pointer_default(unique)
]
interface IFileOperation : IUnknown
{
    // 1) (Optional) Set up your event sink.
    HRESULT Advise([in] IFileOperationProgressSink *pfops, [out] DWORD *pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    // 2) Set operation state
    // FOF_ flags (defined in shellapi.h) and FOFX_ flags are passed here
    // if not specified the default flags are FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR
    HRESULT SetOperationFlags([in] DWORD dwOperationFlags);

    HRESULT SetProgressMessage([in, string] LPCWSTR pszMessage);

    HRESULT SetProgressDialog([in] IOperationsProgressDialog *popd);

    HRESULT SetProperties([in] IPropertyChangeArray *pproparray);

    HRESULT SetOwnerWindow([in] HWND hwndOwner);

    // 3) Specify operations to take on given items.
    // FooItem takes an IShellItem*.
    // FooItems takes an IShellItem*, an IEnumShellItems* or an IDataObject*.
    HRESULT ApplyPropertiesToItem([in] IShellItem *psiItem);

    HRESULT ApplyPropertiesToItems([in] IUnknown *punkItems);

    HRESULT RenameItem(
        [in] IShellItem *psiItem,
        [in, string] LPCWSTR pszNewName,
        [in, unique] IFileOperationProgressSink *pfopsItem);

    HRESULT RenameItems(
        [in] IUnknown *pUnkItems,
        [in, string] LPCWSTR pszNewName);

    HRESULT MoveItem(
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszNewName,
        [in, unique] IFileOperationProgressSink *pfopsItem);

    HRESULT MoveItems(
        [in] IUnknown *punkItems,
        [in] IShellItem *psiDestinationFolder);

    HRESULT CopyItem(
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in, unique, string] LPCWSTR pszCopyName,
        [in, unique] IFileOperationProgressSink *pfopsItem);

    HRESULT CopyItems(
        [in] IUnknown *punkItems,
        [in] IShellItem *psiDestinationFolder);

    HRESULT DeleteItem(
        [in] IShellItem *psiItem,
        [in, unique] IFileOperationProgressSink *pfopsItem);

    HRESULT DeleteItems([in] IUnknown *punkItems);

    HRESULT NewItem(
        [in] IShellItem *psiDestinationFolder,
        [in] DWORD dwFileAttributes,
        [in, string] LPCWSTR pszName,
        [in, unique, string] LPCWSTR pszTemplateName,
        [in, unique] IFileOperationProgressSink *pfopsItem);

    // 4) Perform operations.
    HRESULT PerformOperations();

    // 5) Were any operations aborted?
    HRESULT GetAnyOperationsAborted([out] BOOL *pfAnyOperationsAborted);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN10_RS4)")
typedef [v1_enum] enum FILE_OPERATION_FLAGS2
{
    FOF2_NONE = 0x00000000,
    FOF2_MERGEFOLDERSONCOLLISION = 0x00000001,
} FILE_OPERATION_FLAGS2;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(FILE_OPERATION_FLAGS2)")

[
    uuid(cd8f23c1-8f61-4916-909d-55bdd0918753),
    object,
    pointer_default(unique)
]
interface IFileOperation2 : IFileOperation
{
    HRESULT SetOperationFlags2([in] FILE_OPERATION_FLAGS2 operationFlags2);
}
cpp_quote("#endif  // (NTDDI_VERSION >= NTDDI_WIN10_RS4)")

[
    uuid(a6087428-3be3-4d73-b308-7c04a540bf1a),
    object,
    pointer_default(unique)
]
interface IObjectProvider : IUnknown
{
    // IObjectProvider is similar to IServiceProvider except that it
    // does not imply that unhandled/unknown requests should be forwarded,
    // as IServiceProvider does. the object being queired for is identified
    // by guidObject, usually named as OID_XXX
    HRESULT QueryObject([in] REFGUID guidObject, [in] REFIID riid, [out, iid_is(riid)] void **ppvOut);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

// shell name space walking callback interface"),
[
    uuid(d92995f8-cf5e-4a76-bf59-ead39ea2b97e),
]
interface INamespaceWalkCB : IUnknown
{
    // called for every non folder item found in the folder. these items are reported
    // before any of the folders are returned via EnterFolder(). this is a bredth first
    // walk of the name space
    HRESULT FoundItem([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);

    // this is called for ever sub folder found below the punkToWalk input
    // it is not called for any folders specified directly in the input
    //
    // for every folder this is called after all of the items in the folder have
    // been reported via FoundItem()
    //
    // return:
    //      S_OK to continue recursing
    //      S_FALSE to skip this folder but continue
    //      FAILED() (HRESULT_FROM_WIN32(ERROR_CANCELLED)) to stop the whole walk
    HRESULT EnterFolder([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);

    // matches the EnterFolder() calls, but since folders can nest this
    // other folders may be entered and left before the matching call is made
    HRESULT LeaveFolder([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);

    HRESULT InitializeProgressDialog([out, string] LPWSTR *ppszTitle, [out, string] LPWSTR *ppszCancel);
}

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

[
    uuid(7ac7492b-c38e-438a-87db-68737844ff70),
]
interface INamespaceWalkCB2 : INamespaceWalkCB
{
    HRESULT WalkComplete([in] HRESULT hr);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

// shell name space walk, used to expand data objects, views or recurse folders
[
    uuid(57ced8a7-3f4a-432c-9350-30f24483f74f),
]
interface INamespaceWalk : IUnknown
{
    typedef [v1_enum] enum NAMESPACEWALKFLAG
    {
        NSWF_DEFAULT                        = 0x00000000,
        NSWF_NONE_IMPLIES_ALL               = 0x00000001,
        NSWF_ONE_IMPLIES_ALL                = 0x00000002,
        NSWF_DONT_TRAVERSE_LINKS            = 0x00000004,   // don't traverse the targets of link items (items with SFGAO_LINK)
        NSWF_DONT_ACCUMULATE_RESULT         = 0x00000008,   // don't store the results of the walk, GetIDArrayResult() will fail if called

        // for items with both SFGAO_FOLDER and SFGAO_STREAM discovered via the walk
        // (as opposed to those passed as the input) for example .zip, .search-ms and .library-ms files
        // traverse through them and find the items they reference. this will result in
        // EnterFolder()/LeaveFolder() callbacks instead of FoundItem()
        NSWF_TRAVERSE_STREAM_JUNCTIONS      = 0x00000010,

        NSWF_FILESYSTEM_ONLY                = 0x00000020,   // only return file system items (SFGAO_FILESYSTEM)
        NSWF_SHOW_PROGRESS                  = 0x00000040,   // display the progress dialog while walking
        NSWF_FLAG_VIEWORDER                 = 0x00000080,   // order the items based on the view order that might be different from the default sort
        NSWF_IGNORE_AUTOPLAY_HIDA           = 0x00000100,
        NSWF_ASYNC                          = 0x00000200,   // run the walk on a background thread
        NSWF_DONT_RESOLVE_LINKS             = 0x00000400,   // avoid the expense of resolving links, means link targets might not be up to date
        NSWF_ACCUMULATE_FOLDERS             = 0x00000800,
        NSWF_DONT_SORT                      = 0x00001000,   // Don't maintain sort order of items
        NSWF_USE_TRANSFER_MEDIUM            = 0x00002000,   // Use SHCONTF_STORAGE in enumerations

        // for items with both SFGAO_FOLDER and SFGAO_STREAM passed to the walk
        // (as opposed to those discovered by walking), for example .zip, .search-ms and .library-ms files
        // do not traverse them, instead treat them as items. this will result in
        // FoundItem() callbacks instead of EnterFolder()/LeaveFolder()
        NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS = 0x00004000,
        NSWF_ANY_IMPLIES_ALL                = 0x00008000,   // For selections > 0

    }  NAMESPACEWALKFLAG;

    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(NAMESPACEWALKFLAG)")

    // punkToWalk can be
    //      a punkSite that QueryService(SID_SFolderView, IFolderView) can discover
    //      IShellFolder
    //      IDataObject
    //      IParentAndItem (thus supports CLSID_ShellItem/IShellItem)
    //      IEnumFullIDList
    //      IShellItem
    //      IShellItemArray
    HRESULT Walk(
        [in] IUnknown *punkToWalk,
        [in] DWORD /* NAMESPACEWALKFLAG */ dwFlags,
        [in] int cDepth,
        [in, unique] INamespaceWalkCB *pnswcb);

    HRESULT GetIDArrayResult(
        [out] UINT *pcItems,
        [out, size_is( , *pcItems)] PIDLIST_ABSOLUTE **prgpidl);
}

cpp_quote("#endif  // NTDDI_WINXP || (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("__inline void FreeIDListArray(_In_reads_(cItems) PIDLIST_RELATIVE *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     UINT i;                             ")
cpp_quote("     for (i = 0; i < cItems; i++)        ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")
cpp_quote("__inline void FreeIDListArrayFull(_In_reads_(cItems) PIDLIST_ABSOLUTE *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     for (UINT i = 0; i < cItems; i++)   ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("__inline void FreeIDListArrayChild(_In_reads_(cItems) PITEMID_CHILD *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     for (UINT i = 0; i < cItems; i++)   ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("#else //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")
cpp_quote("#define FreeIDListArrayFull FreeIDListArray")
cpp_quote("#define FreeIDListArrayChild FreeIDListArray")
cpp_quote("#endif //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")

//-------------------------------------------------------------------------
//
// IBandSite interface
//
//   This interface provides methods to get or set bandsite information.
//
// [Member functions]
//
// IBandSite::AddBand(punk)
//   Add a band to the bandsite.  Returns the band ID in ShortFromResult(hres).
//
// IBandSite::EnumBands(uBand, *pdwBandID)
//   Enumerate the bands. If uBand is -1, pdwBandID is ignored and this
//   method returns the count of bands in the bandsite.  Call this method
//   with uBand starting at 0 to begin enumerating.  Returns S_OK and the
//   band ID in *pdwBandID of the next band.
//
// IBandSite::QueryBand(dwBandID, ppstb, pdwState, pszName, cchName)
//   Get info about a band.
//
// IBandSite::SetBandState(dwBandID, dwState)
//   Set the band's state.
//
// IBandSite::RemoveBand(dwBandID)
//   Remove the band.
//
// IBandSite::GetBandObject(dwBandID, riid, ppv)
//   Get an object that support riid for the band.
//
// IBandSite::GetBandSiteInfo(pbsinfo)
//   Get info about the bandsite.
//
// IBandSite::SetBandSiteInfo(pbsinfo)
//   Set info about the bandsite.
//
//-------------------------------------------------------------------------

cpp_quote("#include <pshpack8.h>")

typedef struct tagBANDSITEINFO
{
    DWORD       dwMask;         // BSIM_* flags
    DWORD       dwState;        // BSSF_* flags
    DWORD       dwStyle;        // BSIS_* flags
} BANDSITEINFO;

cpp_quote("#include <poppack.h>")   // Return to byte packing


enum tagBANDSITECID {
    BSID_BANDADDED,
    BSID_BANDREMOVED,
};

// Field mask
cpp_quote("#define BSIM_STATE          0x00000001")
cpp_quote("#define BSIM_STYLE          0x00000002")

// State flags
cpp_quote("#define BSSF_VISIBLE        0x00000001")
cpp_quote("#define BSSF_NOTITLE        0x00000002")
cpp_quote("#define BSSF_UNDELETEABLE   0x00001000")

// Style flags
cpp_quote("#define BSIS_AUTOGRIPPER               0x00000000")
cpp_quote("#define BSIS_NOGRIPPER                 0x00000001")
cpp_quote("#define BSIS_ALWAYSGRIPPER             0x00000002")
cpp_quote("#define BSIS_LEFTALIGN                 0x00000004")
cpp_quote("#define BSIS_SINGLECLICK               0x00000008")
cpp_quote("#define BSIS_NOCONTEXTMENU             0x00000010")
cpp_quote("#define BSIS_NODROPTARGET              0x00000020")
cpp_quote("#define BSIS_NOCAPTION                 0x00000040")
cpp_quote("#define BSIS_PREFERNOLINEBREAK         0x00000080")
cpp_quote("#define BSIS_LOCKED                    0x00000100")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define BSIS_PRESERVEORDERDURINGLAYOUT 0x00000200")
cpp_quote("#define BSIS_FIXEDORDER                0x00000400")
cpp_quote("#endif  // _WIN32_IE_IE70")


cpp_quote("#define SID_SBandSite IID_IBandSite")
cpp_quote("#define CGID_BandSite IID_IBandSite")

[
    object,
    uuid(4CF504B0-DE96-11D0-8B3F-00A0C911E8E5)
]
interface IBandSite : IUnknown
{
    HRESULT AddBand([in] IUnknown* punk);

    HRESULT EnumBands(
        [in] UINT uBand,
        [out] DWORD* pdwBandID);

    [local]
    HRESULT QueryBand(
        [in, annotation("_In_")] DWORD dwBandID,
        [out, annotation("_Outptr_opt_")] IDeskBand** ppstb,
        [out, annotation("_Out_opt_")] DWORD* pdwState,
        [out, string, size_is(cchName), annotation("_Out_writes_opt_(cchName)")] LPWSTR pszName,
        [in, annotation("_In_")] int cchName);

    [call_as(QueryBand)]
    HRESULT RemoteQueryBand(
        [in] DWORD dwBandID,
        [out] IDeskBand** ppstb,
        [out] DWORD* pdwState,
        [out, string, size_is(cchName)] LPWSTR pszName,
        [in] int cchName);

    HRESULT SetBandState(
        [in] DWORD dwBandID,
        [in] DWORD dwMask,
        [in] DWORD dwState);

    HRESULT RemoveBand([in] DWORD dwBandID);

    HRESULT GetBandObject(
        [in] DWORD dwBandID,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT SetBandSiteInfo([in] const BANDSITEINFO *pbsinfo);

    HRESULT GetBandSiteInfo([in, out] BANDSITEINFO *pbsinfo);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

// simple interface for showing a window
[
    uuid(b4db1657-70d7-485e-8e3e-6fcb5a5c1802),
    object,
    pointer_default(unique)
]
interface IModalWindow : IUnknown
{
    [local] HRESULT Show([in, unique, annotation("_In_opt_")] HWND hwndOwner);

    [call_as(Show)] HRESULT RemoteShow([in, unique] HWND hwndOwner);
}

cpp_quote("#endif  // NTDDI_WINXP")

// New for XP, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")
[
    uuid(0811AEBE-0B87-4C54-9E72-548CF649016B),
    object,
    pointer_default(unique)
]
interface IContextMenuSite : IUnknown
{
    HRESULT DoContextMenuPopup(
        [in] IUnknown* punkContextMenu,
        [in] UINT fFlags,
        [in] POINT pt);
}
//cpp_quote("#endif  // NTDDI_WINXP")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

//-------------------------------------------------------------------------
//
// IMenuBand interface
//
//   This interface provides methods the menuband (CLSID_MenuBand)
//  to receive pertinent messages.
//
// [Member functions]
//
// IMenuBand::IsMenuMessage(pmsg)
//   A message pump calls this function to see if any messages need
//   to be redirected to this object.  If this returns S_OK, the
//   message loop should not call TranslateMessage or DispatchMessage.
//   If this returns E_FAIL, the menu has exited menu mode and is ready
//   to be destroyed.
//
// IMenuBand::TranslateMenuMessage(pmsg, plRet)
//   Offers the object an opportunity to translate messages.  The
//   parent window proc must call this method for every message (not
//   the message pump).  The message, wParam, and lParam should be
//   delivered to this method in *pmsg.  This method may change the
//   values of pmsg->wParam or pmsg->lParam, in which case these changes
//   should be forwarded on.
//
//   This method is required because some modal message pumps (like the one
//   in TrackPopupMenu) do not give an opportunity to call a custom
//   TranslateAccelerator method like IInputObject::TranslateAcceleratorIO.
//
//   TranslateMenuMessage returns S_OK if the message was handled and
//   should be eaten.  *plRet is not touched if this returns S_FALSE.
//
//
//-------------------------------------------------------------------------

[
    uuid(568804CD-CBD7-11d0-9816-00C04FD91972),
    object,
    pointer_default(unique),
    local
]
interface IMenuBand : IUnknown
{
    // CmdIDs for the IOleCommandTarget Group: CGID_MenuBandHandler (defined in shguidp.h)
    enum tagMENUBANDHANDLERCID {
        MBHANDCID_PIDLSELECT    = 0,         // A PIDL from a menuband was selected
    };

    HRESULT IsMenuMessage([in, annotation("_In_")] MSG* pmsg);

    HRESULT TranslateMenuMessage(
        [in, out, annotation("_Inout_")] MSG* pmsg,
        [out, annotation("_Out_")] LRESULT* plRet);
}

// callback objects for CRegTreeOptions items
[
    uuid(A9521922-0812-4d44-9EC3-7FD38C726F3D),
    local
]
interface IRegTreeItem : IUnknown
{
    HRESULT GetCheckState([out, annotation("_Out_")] BOOL *pbCheck);

    HRESULT SetCheckState([in, annotation("_In_")] BOOL bCheck);
}

cpp_quote("#endif  // NTDDI_WINXP")
cpp_quote("#endif  // NTDDI_WINXP) || (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60)")

[
    uuid(EB0FE173-1A3A-11D0-89B3-00A0C90A90AC),
    object,
    pointer_default(unique),
    local
]
interface IDeskBar : IOleWindow
{
    HRESULT SetClient([in, unique, annotation("_In_opt_")] IUnknown* punkClient);

    HRESULT GetClient([out, annotation("_Outptr_")] IUnknown** ppunkClient);

    HRESULT OnPosRectChangeDB([in, annotation("_In_")] RECT *prc);
}

//-------------------------------------------------------------------------
//
// IMenuPopup interface
//
//   This interface provides methods to navigate thru a menu.
//
// [Member functions]
//
// IMenuPopup::Popup(ppt, prcExclude, dwFlags)
//   Invoke the menu, located at the point *ppt (in screen coordinates).
//   The optional prcExclude points to the rectangle to exclude when
//   positioning the menu, otherwise it should be NULL.  dwFlags may be:
//
//      MDBPU_SETFOCUS: the menu can take the focus.
//
//   Returns S_OK if the object implements the popup menu as a modeless
//   menu.  Otherwise it returns S_FALSE, and the menu is finished.
//
// IMenuPopup::OnSelect(dwSelectType)
//   This method handles selection notifications.
//
// IMenuPopup::SetSubMenu(pmp, fSet)
//   Sets the given menu bar interface to be the submenu of this
//   object's interface.  Set fSet == FALSE to remove the submenu.
//
//-------------------------------------------------------------------------
[
    uuid(D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4),
    object,
    pointer_default(unique),
    local
]
interface IMenuPopup : IDeskBar
{
    // Type values for IMenuPopup::OnSelect
    enum tagMENUPOPUPSELECT
    {
        MPOS_EXECUTE = 0,           // Execute the selected menu item
        MPOS_FULLCANCEL,            // Cancel the entire menu
        MPOS_CANCELLEVEL,           // Cancel the current cascaded menu
        MPOS_SELECTLEFT,            // select one to the left of the cur selection
        MPOS_SELECTRIGHT,           // select one to the right of the cur selection
        MPOS_CHILDTRACKING          // the child got a tracking select (mouse moved over)
    };

    // Flags for IMenuPopup::Popup
    enum tagMENUPOPUPPOPUPFLAGS
    {
        MPPF_SETFOCUS        = 0x00000001,    // Menu can take the focus
        MPPF_INITIALSELECT   = 0x00000002,    // Select the first item
        MPPF_NOANIMATE       = 0x00000004,    // Do not animate this show
        MPPF_KEYBOARD        = 0x00000010,    // The menu is activated by keyboard
        MPPF_REPOSITION      = 0x00000020,    // Resposition the displayed bar.
        MPPF_FORCEZORDER     = 0x00000040,    // internal: Tells menubar to ignore Submenu positions
        MPPF_FINALSELECT     = 0x00000080,    // Select the last item
        MPPF_TOP             = 0x20000000,    // Popup menu up from point
        MPPF_LEFT            = 0x40000000,    // Popup menu left from point
        MPPF_RIGHT           = 0x60000000,    // Popup menu right from point
        MPPF_BOTTOM          = (int) 0x80000000, // Popup menu below point
        MPPF_POS_MASK        = (int) 0xE0000000, // Menu Position Mask
        MPPF_ALIGN_LEFT      = 0x02000000,    // Default alignment
        MPPF_ALIGN_RIGHT     = 0x04000000     // Popup menu aligned to right of exclude rect
    };
    typedef int MP_POPUPFLAGS;

    HRESULT Popup(
        [in, annotation("_In_")] POINTL *ppt,
        [in, unique, annotation("_In_opt_")] RECTL *prcExclude,
        [in, annotation("_In_")] MP_POPUPFLAGS dwFlags);

    HRESULT OnSelect([in, annotation("_In_")] DWORD dwSelectType);

    HRESULT SetSubMenu(
        [in, annotation("_In_")] IMenuPopup* pmp,
        [in, annotation("_In_")] BOOL fSet);
}

cpp_quote("#endif  // _WIN32_IE_IE60")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

// Constants for the type of usage of an open file
typedef [v1_enum] enum FILE_USAGE_TYPE
{
    FUT_PLAYING,
    FUT_EDITING,
    FUT_GENERIC
} FILE_USAGE_TYPE;

cpp_quote("#define OF_CAP_CANSWITCHTO     0x0001")
cpp_quote("#define OF_CAP_CANCLOSE        0x0002")

[
    uuid(64a1cbf0-3a1a-4461-9158-376969693950),
    pointer_default(unique)
]
interface IFileIsInUse : IUnknown
{
    HRESULT GetAppName([out, string] LPWSTR *ppszName);

    HRESULT GetUsage([out] FILE_USAGE_TYPE *pfut);

    HRESULT GetCapabilities([out] DWORD *pdwCapFlags);

    HRESULT GetSwitchToHWND([out] HWND *phwnd);

    HRESULT CloseFile();
}

interface IFileDialog;

typedef [v1_enum] enum FDE_OVERWRITE_RESPONSE
{
    FDEOR_DEFAULT            = 0, // The application has not handled the event, and the dialog should put up UI asking the user
                                  // whether or not the file should be overwritten and be returned from the dialog
    FDEOR_ACCEPT             = 1, // The application has decided that the file should be returned from the dialog
    FDEOR_REFUSE             = 2, // The application has decided that the file should not be returned from the dialog
} FDE_OVERWRITE_RESPONSE;

typedef [v1_enum] enum FDE_SHAREVIOLATION_RESPONSE
{
    FDESVR_DEFAULT           = 0, // The application has not handled the event.  The dialog will put up UI indicating the file
                                  // is in use, and a different file must be chosen.
    FDESVR_ACCEPT            = 1, // The application has decided that the file should be returned from the dialog
    FDESVR_REFUSE            = 2, // The application has decided that the file should not be returned from the dialog
} FDE_SHAREVIOLATION_RESPONSE;

typedef [v1_enum] enum FDAP
{
    FDAP_BOTTOM              = 0, // The place is added to the bottom of the default list.
    FDAP_TOP                 = 1, // The place is added to the top of the default list.
} FDAP;


//
// Implemented by a client of the common file dialog browser,
//  for notification of events within the dialog.
//
[
    uuid(973510db-7d7f-452b-8975-74a85828d354),
    object,
    pointer_default(unique)
]
interface IFileDialogEvents : IUnknown
{
    HRESULT OnFileOk([in] IFileDialog *pfd);

    HRESULT OnFolderChanging(
        [in] IFileDialog *pfd,
        [in] IShellItem *psiFolder);

    HRESULT OnFolderChange([in] IFileDialog *pfd);

    HRESULT OnSelectionChange([in] IFileDialog *pfd);

    // Note: FOS_SHAREAWARE must be set in IFileDialog::SetOptions in order for this method to be called.
    HRESULT OnShareViolation(
        [in] IFileDialog *pfd,
        [in] IShellItem *psi,
        [out] FDE_SHAREVIOLATION_RESPONSE *pResponse);

    HRESULT OnTypeChange([in] IFileDialog *pfd);

    // Note: FOS_OVERWRITEPROMPT must be set in IFileDialog::SetOptions in order for this method to be called.
    HRESULT OnOverwrite(
        [in] IFileDialog *pfd,
        [in] IShellItem *psi,
        [out] FDE_OVERWRITE_RESPONSE *pResponse);
}

interface IShellItemFilter;

//
// Implemented by the common file dialog browser, used by clients to
//  initialize, show, and get results from the dialog.
//
[
    uuid(42f85136-db7e-439c-85f1-e4075d135fc8),
    object,
    pointer_default(unique)
]
interface IFileDialog : IModalWindow
{
    [v1_enum] enum _FILEOPENDIALOGOPTIONS
    {
        FOS_OVERWRITEPROMPT          = 0x00000002, // (on by default in the save dialog)
        FOS_STRICTFILETYPES          = 0x00000004, // In the save dialog, only allow the user to choose a file that has
                                                   // one of the file extensions provided in SetFileTypes.
        FOS_NOCHANGEDIR              = 0x00000008, // Don't change the current working directory
        FOS_PICKFOLDERS              = 0x00000020, // Invoke the open dialog in folder picking mode.
        FOS_FORCEFILESYSTEM          = 0x00000040, // Ensure that items returned are filesystem items.
        FOS_ALLNONSTORAGEITEMS       = 0x00000080, // Allow choosing items that have no storage.
        FOS_NOVALIDATE               = 0x00000100,
        FOS_ALLOWMULTISELECT         = 0x00000200,
        FOS_PATHMUSTEXIST            = 0x00000800, // (on by default)
        FOS_FILEMUSTEXIST            = 0x00001000, // (on by default in the open dialog and folder picker)
        FOS_CREATEPROMPT             = 0x00002000,
        FOS_SHAREAWARE               = 0x00004000,
        FOS_NOREADONLYRETURN         = 0x00008000, // (on by default in the save dialog)
        FOS_NOTESTFILECREATE         = 0x00010000, // Avoid testing the creation of the chosen file in the save dialog
                                                   // (specifying this flag will circumvent some useful error handling, such as access denied)
        FOS_HIDEMRUPLACES            = 0x00020000, // (not used in Win7)
        FOS_HIDEPINNEDPLACES         = 0x00040000, // Don't display the standard namespace locations in the navigation pane.
                                                   // (generally used along with AddPlace)
        FOS_NODEREFERENCELINKS       = 0x00100000, // Don't treat shortcuts as their target files.
        FOS_OKBUTTONNEEDSINTERACTION = 0x00200000, // Only enable the OK button if the user has done something in the view.
        FOS_DONTADDTORECENT          = 0x02000000, // Don't add the chosen file to the recent documents list (SHAddToRecentDocs)
        FOS_FORCESHOWHIDDEN          = 0x10000000, // Show all files including system and hidden files.
        FOS_DEFAULTNOMINIMODE        = 0x20000000, // (not used in Win7)
        FOS_FORCEPREVIEWPANEON       = 0x40000000,
        FOS_SUPPORTSTREAMABLEITEMS   = 0x80000000, // Indicates the caller will use BHID_Stream to open contents, no need to download the file
    };
    typedef DWORD FILEOPENDIALOGOPTIONS;

    HRESULT SetFileTypes(
        [in] UINT cFileTypes,
        [in, size_is(cFileTypes)] const COMDLG_FILTERSPEC *rgFilterSpec);

    HRESULT SetFileTypeIndex([in] UINT iFileType);

    HRESULT GetFileTypeIndex([out] UINT *piFileType);

    HRESULT Advise(
        [in] IFileDialogEvents *pfde,
        [out] DWORD *pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    HRESULT SetOptions([in] FILEOPENDIALOGOPTIONS fos);

    HRESULT GetOptions([out] FILEOPENDIALOGOPTIONS *pfos);

    HRESULT SetDefaultFolder([in] IShellItem *psi);

    HRESULT SetFolder([in] IShellItem *psi);

    HRESULT GetFolder([out] IShellItem **ppsi);

    HRESULT GetCurrentSelection([out] IShellItem **ppsi);

    HRESULT SetFileName([in, string] LPCWSTR pszName);

    HRESULT GetFileName([out, string] LPWSTR *pszName);

    HRESULT SetTitle([in, string] LPCWSTR pszTitle);

    HRESULT SetOkButtonLabel([in, string] LPCWSTR pszText);

    HRESULT SetFileNameLabel([in, string] LPCWSTR pszLabel);

    HRESULT GetResult([out] IShellItem **ppsi);

    HRESULT AddPlace(
        [in] IShellItem *psi,
        [in] FDAP fdap);

    HRESULT SetDefaultExtension([in, string] LPCWSTR pszDefaultExtension);

    HRESULT Close([in] HRESULT hr);

    HRESULT SetClientGuid([in] REFGUID guid);

    HRESULT ClearClientData();

    HRESULT SetFilter([in] IShellItemFilter *pFilter);
}

//
// Additional methods specific to the file save dialog
//
[
    uuid(84bccd23-5fde-4cdb-aea4-af64b83d78ab),
    object,
    pointer_default(unique)
]
interface IFileSaveDialog : IFileDialog
{
    HRESULT SetSaveAsItem([in] IShellItem *psi);

    HRESULT SetProperties([in] IPropertyStore *pStore);

    HRESULT SetCollectedProperties(
        [in] IPropertyDescriptionList *pList,
        [in] BOOL fAppendDefault);

    HRESULT GetProperties([out] IPropertyStore **ppStore);

    HRESULT ApplyProperties(
        [in] IShellItem *psi,
        [in] IPropertyStore *pStore,
        [in, unique] HWND hwnd,
        [in, unique] IFileOperationProgressSink *pSink);
}

//
// Additional methods specific to the file open dialog
// (adding multiselect capability)
//
[
    uuid(d57c7288-d4ad-4768-be02-9d969532d960),
    object,
    pointer_default(unique)
]
interface IFileOpenDialog : IFileDialog
{
    HRESULT GetResults([out] IShellItemArray **ppenum);

    HRESULT GetSelectedItems([out] IShellItemArray **ppsai);
}

typedef [v1_enum] enum CDCONTROLSTATEF
{
    CDCS_INACTIVE       = 0x00000000,
    CDCS_ENABLED        = 0x00000001,
    CDCS_VISIBLE        = 0x00000002,
    CDCS_ENABLEDVISIBLE = 0x00000003,
} CDCONTROLSTATEF;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(CDCONTROLSTATEF)")

// Some facts:
// - Controls are added before the dialog is shown.  Their relative layout is implied by the order in which
//    they are added. Controls may be added below or above the standard set of controls.
//    Controls can not be removed or added afterwards, but they may be hidden or disabled at any time.
//    Their labels may be changed at any time.
// - Some controls are container controls: combobox, toolsmenu, opendropdown, radiogroup.  These may have
//   items added to them.
// - Items with a container control are "immutable", except for their enabled/visible state.  They can be
//    added and removed at will.  There is no ability to position items within a container - they appear in the
//    order they were added.  IDs for items are scoped to their parent control.
// - Container controls have the notion of a "selected item", with the exception of the toolsmenu.
// - radiobuttongroups behave exactly like comboboxes.  The radio buttons within the group are treated exactly
//    like items in a combobox, one of which can be the "selected item".
[
    uuid(e6fdd21a-163f-4975-9c8c-a69f1ba37034),
    object,
    pointer_default(unique)
]
interface IFileDialogCustomize : IUnknown
{
    // Methods for adding or enabling controls. All of these can have their
    // enabled/visible state set, however the default is for them to be enabled and visible,
    // so this parameter has been left off these methods.
    HRESULT EnableOpenDropDown([in] DWORD dwIDCtl);

    HRESULT AddMenu(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT AddPushButton(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT AddComboBox([in] DWORD dwIDCtl);

    HRESULT AddRadioButtonList([in] DWORD dwIDCtl);

    HRESULT AddCheckButton(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel,
        [in] BOOL bChecked);

    HRESULT AddEditBox(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszText);

    HRESULT AddSeparator([in] DWORD dwIDCtl);

    HRESULT AddText(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszText);

    // Getting/setting attributes on controls on the fly
    HRESULT SetControlLabel(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT GetControlState(
        [in] DWORD dwIDCtl,
        [out] CDCONTROLSTATEF *pdwState);

    HRESULT SetControlState(
        [in] DWORD dwIDCtl,
        [in] CDCONTROLSTATEF dwState);

    HRESULT GetEditBoxText(
        [in] DWORD dwIDCtl,
        [out, string] WCHAR **ppszText);

    HRESULT SetEditBoxText(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszText);

    HRESULT GetCheckButtonState(
        [in] DWORD dwIDCtl,
        [out] BOOL *pbChecked);

    HRESULT SetCheckButtonState(
        [in] DWORD dwIDCtl,
        [in] BOOL bChecked);

    // Method for adding items to "container controls" (radiogroup, combobox, opendropdown, toolsmenu)
    HRESULT AddControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in] LPCWSTR pszLabel);

    // Methods for removing items in the "container controls"
    HRESULT RemoveControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem);

    HRESULT RemoveAllControlItems([in] DWORD dwIDCtl);

    // Getting/setting attributes on control items on the fly
    // Items are considered immutable once created, except for their state:
    HRESULT GetControlItemState(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [out] CDCONTROLSTATEF *pdwState);

    HRESULT SetControlItemState(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in] CDCONTROLSTATEF dwState);

    // Methods for some "container controls": OpenDropDown, combobox, radiobuttongroup.
    // These methods don't apply to the tools menu.
    // These methods can be called after the dialog has closed, to determine the users final choice.
    // For comboboxes and radiobuttongroups, these methods may also be called while the
    // dialog is showing (which makes no sense for the OpenDropDown).
    HRESULT GetSelectedControlItem(
        [in] DWORD dwIDCtl,
        [out] DWORD *pdwIDItem);

    HRESULT SetSelectedControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem); // Not valid for OpenDropDown

    // Controls can be grouped by wrapping their adds in StartVisualGroup/EndVisualGroup
    // Groups have control IDs, and can be disabled/hidden, just like other controls.
    HRESULT StartVisualGroup(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT EndVisualGroup();

    // One control may be marked as appearing prominently in the UI
    HRESULT MakeProminent([in] DWORD dwIDCtl);

    // Set the text of a control item (RadioButton, or item in an OpenDropDown or Menu)
    HRESULT SetControlItemText(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in, string] LPCWSTR pszLabel);
}

typedef [v1_enum] enum ASSOCIATIONLEVEL
{
    AL_MACHINE,
    AL_EFFECTIVE,
    AL_USER,
} ASSOCIATIONLEVEL;

typedef [v1_enum] enum ASSOCIATIONTYPE
{
    AT_FILEEXTENSION,
    AT_URLPROTOCOL,
    AT_STARTMENUCLIENT,
    AT_MIMETYPE,
} ASSOCIATIONTYPE;

// Application File Extension and URL Protocol Registration
[
    object,
    uuid(4e530b0a-e611-4c77-a3ac-9031d022281b),
    pointer_default(unique)
]
interface IApplicationAssociationRegistration : IUnknown
{
    HRESULT QueryCurrentDefault(
        [in, string] LPCWSTR pszQuery,
        [in] ASSOCIATIONTYPE atQueryType,
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [out, string] LPWSTR* ppszAssociation);

    HRESULT QueryAppIsDefault(
        [in, string] LPCWSTR pszQuery,
        [in] ASSOCIATIONTYPE atQueryType,
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [in, string] LPCWSTR pszAppRegistryName,
        [out] BOOL* pfDefault);

    HRESULT QueryAppIsDefaultAll(
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [in, string] LPCWSTR pszAppRegistryName,
        [out] BOOL* pfDefault);

    HRESULT SetAppAsDefault(
        [in, string] LPCWSTR pszAppRegistryName,
        [in, string] LPCWSTR pszSet,
        [in] ASSOCIATIONTYPE atSetType);

    HRESULT SetAppAsDefaultAll(
        [in, string] LPCWSTR pszAppRegistryName);

    HRESULT ClearUserAssociations();
}

// SHCreateAssociationRegistration can be used to create an IApplicationAssociationRegistration
cpp_quote("SHSTDAPI SHCreateAssociationRegistration(_In_ REFIID riid, _Outptr_ void **ppv);")

cpp_quote("#endif  // NTDDI_VISTA")

// New for XP, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINXP)")

//
// Delegate Item IDs are in a partially known format so the delegate (inner) and
// delgating (outer) folders share the pidl contents. the inner folder allocates
// its pidls using the IMalloc provided by the outer folder via SetItemAlloc()
// that pidl must conform to the delegate item format.
//
cpp_quote("#include <pshpack1.h>")

typedef struct DELEGATEITEMID
{
    WORD cbSize;                // size of entire item ID (points to the NULL or next item)
    WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;               // Size of delegate's data
    BYTE rgb[1];                // Inner folder's data (opaque to outer folder)
                                //   followed by outer folder's data.
} DELEGATEITEMID;

cpp_quote("#include <poppack.h>")

cpp_quote("typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;")
cpp_quote("typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;")

// shell name space delegate folder interface
[
    uuid(ADD8BA80-002B-11D0-8F0F-00C04FD7D062),
    object,
    local,
    pointer_default(unique)
]
interface IDelegateFolder : IUnknown
{
    // use to give the delegate folder the IMalloc interface that it
    // needs to use to alloc and free item IDs.
    // These IDs are in the form of DELEGATEITEMIDs
    // and it is the delegates job to pack its data into the pidl
    // in the delegate format
    HRESULT SetItemAlloc([in, annotation("_In_")] IMalloc *pmalloc);
}
//cpp_quote("#endif  // NTDDI_WINXP")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60)")

cpp_quote("// INTERFACE: IBrowserFrameOptions")
cpp_quote("//")
cpp_quote("// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what")
cpp_quote("// kind of 'Behavior' is appropriate for that view.")
cpp_quote("//")
cpp_quote("//    IBrowserFrameOptions::GetBrowserOptions()")
cpp_quote("//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and")
cpp_quote("//       it's return value will always equal or will be a subset of dwMask.")
cpp_quote("//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.")
cpp_quote("//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.")
cpp_quote("//")

[
    uuid(10DF43C8-1DBE-11d3-8B34-006097DF5BD4),
    object,
    local
]
interface IBrowserFrameOptions : IUnknown
{
    typedef [unique] IBrowserFrameOptions * LPBROWSERFRAMEOPTIONS;

    [v1_enum] enum _BROWSERFRAMEOPTIONS
    {
        BFO_NONE                            = 0x00000000,      // Do nothing.
        BFO_BROWSER_PERSIST_SETTINGS        = 0x00000001,      // Does this item want the browser stream? (Same window position as IE browser windows?)
        BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = 0x00000002,     // Rename "Folder Options" to "Internet Options" in the Tools or View menu?
        BFO_BOTH_OPTIONS                    = 0x00000004,      // Keep both "Folder Options" and "Internet Options" in the Tools or View menu?
        BIF_PREFER_INTERNET_SHORTCUT        = 0x00000008,      // NSE would prefer a .url shortcut over a .lnk shortcut
        BFO_BROWSE_NO_IN_NEW_PROCESS        = 0x00000010,      // Specify this flag if you don't want the "Browse in New Process" via invoking a shortcut.
        BFO_ENABLE_HYPERLINK_TRACKING       = 0x00000020,      // Does this NSE want it's display name tracked to determine when hyperlinks should be tagged as previously used?
        BFO_USE_IE_OFFLINE_SUPPORT          = 0x00000040,      // Use "Internet Explorer"'s offline support?
        BFO_SUBSTITUE_INTERNET_START_PAGE   = 0x00000080,      // Does this NSE want to use the Start Page support?
        BFO_USE_IE_LOGOBANDING              = 0x00000100,      // Use the Brand block in the Toolbar.  (Spinning globe or whatever it is this year)
        BFO_ADD_IE_TOCAPTIONBAR             = 0x00000200,      // Should " - Internet Explorer" be appended to display name in the Captionbar
        BFO_USE_DIALUP_REF                  = 0x00000400,      // Should the DialUp ref count get a ref while the browse is navigated to this location?  This will also enable the ICW and Software update.
        BFO_USE_IE_TOOLBAR                  = 0x00000800,      // Should the IE toolbar be used?
        BFO_NO_PARENT_FOLDER_SUPPORT        = 0x00001000,      // Can you NOT navigate to a parent folder?  Used for Backspace button to parent folder or the View.GoTo.ParentFolder feature.
        BFO_NO_REOPEN_NEXT_RESTART          = 0x00002000,      // Browser windows are NOT reopened the next time the shell boots if the windows were left open on the previous logoff.  Does this NSE want the same feature?
        BFO_GO_HOME_PAGE                    = 0x00004000,      // Add "Home Page" to menu (Go).
        BFO_PREFER_IEPROCESS                = 0x00008000,      // prefers to use IEXPLORE.EXE over EXPLORER.EXE
        BFO_SHOW_NAVIGATION_CANCELLED       = 0x00010000,      // If navigation is aborted, show the "Action Cancelled" HTML page.
        BFO_USE_IE_STATUSBAR                = 0x00020000,      // Use the persisted IE status bar settings
        BFO_QUERY_ALL                       = (int) 0xFFFFFFFF, // Return all values set.
    };
    typedef DWORD BROWSERFRAMEOPTIONS;

    HRESULT GetFrameOptions(
        [in, annotation("_In_")] BROWSERFRAMEOPTIONS dwMask,
        [out, annotation("_Out_")] BROWSERFRAMEOPTIONS * pdwOptions);
}

cpp_quote("#endif  // _WIN32_IE_IE60")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")

typedef [v1_enum] enum NWMF
{
    NWMF_UNLOADING        = 0x00000001,  // The query is occuring during onBeforeUnload or onUnload
    NWMF_USERINITED       = 0x00000002,  // The query is occuring in the context of what trident considers to be a user initiated action
    NWMF_FIRST            = 0x00000004,  // This is the first query since the begining of the last user initiated action
    NWMF_OVERRIDEKEY      = 0x00000008,  // The override key was pressed at the time the query was made
    NWMF_SHOWHELP         = 0x00000010,  // New window is an HTML help window
    NWMF_HTMLDIALOG       = 0x00000020,  // New window is an HTML dialog
    NWMF_FROMDIALOGCHILD  = 0x00000040,  // Called from an HTML dialog - do not show UI in parent window
    NWMF_USERREQUESTED    = 0x00000080,  // There is no doubt the user requested this window (from RClick->Open in New Window, or Shift+Clicked a link)
    NWMF_USERALLOWED      = 0x00000100,  // This popup is the result of the user requesting a replay that resulted in a refresh
    NWMF_FORCEWINDOW      = 0x00010000,  // This popup should be forced to open in a new window
    NWMF_FORCETAB         = 0x00020000,  // This popup should be forced to open in a new tab
    NWMF_SUGGESTWINDOW    = 0x00040000,  // This popup should open in a new window unless user forced pop-ups to a tab
    NWMF_SUGGESTTAB       = 0x00080000,  // This popup should open in a new tab unless user forced pop-ups to a window
    NWMF_INACTIVETAB      = 0x00100000,  // This popup came from an inactive tab
} NWMF;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(NWMF)")

// Popup manager interface for WebOC hosts and Trident.
cpp_quote("#define SID_SNewWindowManager IID_INewWindowManager")
[
    uuid(D2BC4C84-3F72-4a52-A604-7BCBF3982CBB),
    object,
    pointer_default(unique)
]
interface INewWindowManager : IUnknown
{
    HRESULT EvaluateNewWindow(
        [in, string] LPCWSTR pszUrl,
        [in, string] LPCWSTR pszName,
        [in, string] LPCWSTR pszUrlContext,
        [in, string] LPCWSTR pszFeatures,
        [in] BOOL fReplace,
        [in] DWORD dwFlags,
        [in] DWORD dwUserActionTime);
}

//-------------------------------------------------------------------------
// IAttachmentExecute
[
    object,
    uuid(73db1241-1e85-4581-8e4f-a81e1d0f8c57),  // IID_IAttachmentExecute
    local,
    pointer_default(unique),
]
interface IAttachmentExecute : IUnknown
{
    typedef [v1_enum] enum ATTACHMENT_PROMPT
    {
        ATTACHMENT_PROMPT_NONE              = 0x0000,
        ATTACHMENT_PROMPT_SAVE              = 0x0001,
        ATTACHMENT_PROMPT_EXEC              = 0x0002,
        ATTACHMENT_PROMPT_EXEC_OR_SAVE      = 0x0003,
    } ATTACHMENT_PROMPT;

    typedef [v1_enum] enum ATTACHMENT_ACTION
    {
        ATTACHMENT_ACTION_CANCEL            = 0x0000,
        ATTACHMENT_ACTION_SAVE              = 0x0001,
        ATTACHMENT_ACTION_EXEC              = 0x0002,
    } ATTACHMENT_ACTION;

    //
    //  IAttachmentExecute - COM object designed to help client applications
    //      safely manage saving and opening attachments for users.
    //      clients are assumed to have some policy/settings already
    //      to determine the support and behavior for attachments.
    //      this API assumes that the client is interactive with the user
    //
    //  ClientTitle - (optional) caller specific title for the prompt
    //    if unset, the prompts come with a default title of "File Download"
    HRESULT SetClientTitle([in, string, annotation("_In_")] LPCWSTR pszTitle);

    //  ClientGuid - (optional) for storing user specific settings
    //      someprompts are allowed to be avoided in the future if the user
    //      chooses.  that choice is stored on per-client basis indexed by the ClientGuid
    //
    //      Specific Example: In the User Trust Prompt there is a check box that is checked
    //      by default, but may be unchecked by the user.  this option is stored under the ClientGuid
    //      based on the file type.
    //
    //      ClearClientState() will reset any user options stored on the clients behalf.
    HRESULT SetClientGuid([in, annotation("_In_")] REFGUID guid);


    //  EVIDENCE properties

    //  LocalPath - (REQUIRED) path that would be passed to ShellExecute()
    //      if FileName was already used for the Check() and Prompt() calls,
    //      and the LocalPath points to a different handler than predicted,
    //      previous trust may be revoked, and the Policy and User trust re-verified.
    HRESULT SetLocalPath([in, string, annotation("_In_")] LPCWSTR pszLocalPath);

    //  FileName - (optional) proposed name (not path) to be used to construct LocalPath
    //  optionally use this if the caller wants to perform Check() before copying
    //  the file to the LocalPath.  (eg, Check() proposed download)
    HRESULT SetFileName([in, string, annotation("_In_")] LPCWSTR pszFileName);

    //  Source - (optional) alternate identity path or URL for a file transfer
    //      used as the primary Zone determinant.  if this is NULL default to the Restricted Zone.
    //      may also be used in the Prompt() UI for the "From" field
    //      may also be sent to handlers that can process URLs
    HRESULT SetSource([in, string, annotation("_In_")] LPCWSTR pszSource);

    //  Referrer - (optional) Zone determinant for container or link types
    //      only used for Zone/Policy
    //      container formats like ZIP and OLE packager use the Referrer to
    //      indicate indirect inheritance and avoid Zone elevation.
    //      Shortcuts can also use it to limit elevation based on parameters
    HRESULT SetReferrer([in, string, annotation("_In_")] LPCWSTR pszReferrer);

    //  CheckPolicy() - examines available evidence and checks the resultant policy
    //      * requires FileName or LocalPath
    //
    //  Returns S_OK for enable
    //          S_FALSE for prompt
    //          FAILURE for disable
    //
    HRESULT CheckPolicy();

    //  Prompt() - application can force UI at an earlier point,
    //      even before the file has been copied to disk
    //      * requires FileName or LocalPath
    HRESULT Prompt(
        [in, annotation("_In_")] HWND hwnd,
        [in, annotation("_In_")] ATTACHMENT_PROMPT prompt,
        [out, annotation("_Out_")] ATTACHMENT_ACTION *paction);

    //  Save() - should always be called if LocalPath is in not in a temp dir
    //      * requires valid LocalPath
    //      * called after the file has been copied to LocalPath
    //      * may run virus scanners or other trust services to validate the file.
    //          these services may delete or alter the file
    //      * may attach evidence to the LocalPath
    HRESULT Save();

    //  Execute() - will call Prompt() if necessary, with the EXEC action
    //      * requires valid LocalPath
    //      * called after the file has been copied to LocalPath
    //      * may run virus scanners or other trust services to validate the file.
    //          these services may delete or alter the file
    //      * may attach evidence to the LocalPath
    //
    //      phProcess - if non-NULL Execute() will be synchronous and return an HPROCESS if available
    //                  if null Execute() will be async, implies that you have a message pump and a long lived window
    //
    HRESULT Execute(
        [in, annotation("_In_")] HWND hwnd,
        [in, string, annotation("_In_opt_")] LPCWSTR pszVerb,
        [out, annotation("_Out_opt_")] HANDLE *phProcess);

    //   SaveWithUI() - superset of Save() that can show modal error UI, but still does not call Prompt()
    //      * requires valid LocalPath
    //      * called after the file has been copied to LocalPath
    //      * may run virus scanners or other trust services to validate the file.
    //          these services may delete or alter the file
    //      * may attach evidence to the LocalPath
    HRESULT SaveWithUI([in, annotation("_In_")] HWND hwnd);

    //  ClearClientState() - removes any state that is stored based on the ClientGuid
    //      * requires SetClientGuid() to be called first
    HRESULT ClearClientState();
}

cpp_quote("#endif  // _WIN32_IE_IE60SP2")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60)")

cpp_quote("#include <pshpack8.h>")

typedef struct tagSMDATA
{
    DWORD   dwMask;             // SMDM_* values
    DWORD   dwFlags;            // Not used
    HMENU   hmenu;              // Static HMENU portion.
    HWND    hwnd;               // HWND owning the HMENU
    UINT    uId;                // Id of the item in the menu (-1 for menu itself)
    UINT    uIdParent;          // Id of the item spawning this menu
    UINT    uIdAncestor;        // Id of the very top item in the chain of ShellFolders
    IUnknown*    punk;          // IUnkown of the menuband
    PIDLIST_ABSOLUTE pidlFolder;// pidl of the ShellFolder portion
    PUITEMID_CHILD   pidlItem;  // pidl of the item in the ShellFolder portion
    IShellFolder*   psf;        // IShellFolder for the shell folder portion
    void*   pvUserData;         // User defined Data associated with a pane.
} SMDATA, *LPSMDATA;

cpp_quote("// Mask")
cpp_quote("#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band")
cpp_quote("#define SMDM_HMENU                     0x00000002  // This is for the Band itself")
cpp_quote("#define SMDM_TOOLBAR                   0x00000004  // Plain toolbar, not associated with a shell folder or hmenu")

cpp_quote("// Flags (bitmask)")
typedef struct tagSMINFO
{
    DWORD   dwMask;     // SMIM_*
    DWORD   dwType;     // SMIT_*
    DWORD   dwFlags;    // SMIF_*
    int     iIcon;
} SMINFO, * PSMINFO;

typedef struct SHCSCHANGENOTIFYSTRUCT
{
    long                lEvent; // Change notify Event
    PCIDLIST_ABSOLUTE   pidl1;  // Pidl 1 Passed in from the Change notify
    PCIDLIST_ABSOLUTE   pidl2;  // Pidl 2 Passed in from the Change notify
} SMCSHCHANGENOTIFYSTRUCT, *PSMCSHCHANGENOTIFYSTRUCT;

cpp_quote("#include <poppack.h>") /* Return to byte packing */

// Mask flags
enum tagSMINFOMASK
{
    SMIM_TYPE           = 0x00000001,
    SMIM_FLAGS          = 0x00000002,
    SMIM_ICON           = 0x00000004
};

// Types for mbiinfo.dwType
enum tagSMINFOTYPE
{
    SMIT_SEPARATOR      = 0x00000001,
    SMIT_STRING         = 0x00000002
};

// Flags for mbiinfo.dwFlags
enum tagSMINFOFLAGS
{
    SMIF_ICON           = 0x00000001,       // Show an icon
    SMIF_ACCELERATOR    = 0x00000002,       // Underline the character marked w/ '&'
    SMIF_DROPTARGET     = 0x00000004,       // Item is a drop target
    SMIF_SUBMENU        = 0x00000008,       // Item has a submenu
    SMIF_CHECKED        = 0x00000020,       // Item has a Checkmark
    SMIF_DROPCASCADE    = 0x00000040,       // Item can cascade out during drag/drop
    SMIF_HIDDEN         = 0x00000080,       // Don't display item
    SMIF_DISABLED       = 0x00000100,       // Should be unselectable. Gray.
    SMIF_TRACKPOPUP     = 0x00000200,       // Should be unselectable. Gray.
    SMIF_DEMOTED        = 0x00000400,       // Display item in "Demoted" state.
    SMIF_ALTSTATE       = 0x00000800,       // Displayed in "Altered State"
    SMIF_DRAGNDROP      = 0x00001000,       // If item that is being dragged hovers over an item for long enough then it SMC_EXECs that item
    SMIF_NEW            = 0x00002000,       // Item is newly-installed or otherwise attractive (XP)
};

cpp_quote("#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband")
cpp_quote("#define SMC_CREATE              0x00000002")
cpp_quote("#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing")
cpp_quote("#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values")
cpp_quote("#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values")
cpp_quote("#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object")
cpp_quote("#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object")
cpp_quote("#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item")
cpp_quote("#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected")
cpp_quote("#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.")
cpp_quote("#define SMC_DEMOTE              0x00000011  // Demote an item")
cpp_quote("#define SMC_PROMOTE             0x00000012  // Promote an item, wParam = SMINV_* flag")
cpp_quote("#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam")
cpp_quote("#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.")
cpp_quote("#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron")
cpp_quote("#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.")
cpp_quote("#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object")
cpp_quote("#define SMC_SHCHANGENOTIFY      0x0000002E  // Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT")
cpp_quote("#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH")
cpp_quote("#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define SMC_SFEXEC_MIDDLE       0x00000031  // Same as SFEXEC, but the middle mouse button caused the exec.")
cpp_quote("#define SMC_GETAUTOEXPANDSTATE  0x00000041  // callback returns the default autoexpand state lParam = LPDWORD to recieve flags")
cpp_quote("#define SMC_AUTOEXPANDCHANGE    0x00000042  // Notify that the menu is expanding/contracting")
cpp_quote("#define SMC_GETCONTEXTMENUMODIFIER 0x00000043  // Used to add items to a context menu")
cpp_quote("#define SMC_GETBKCONTEXTMENU    0x00000044  // used to get a context menu to display when user right clicks on the background")
cpp_quote("#define SMC_OPEN                0x00000045  // allows client to overwrite open/explore verb action on an item")

cpp_quote("// Flags for return value from SMC_GETAUTOEXPANDSTATE and SMC_AUTOEXPANDCHANGE:")
cpp_quote("#define SMAE_EXPANDED           0x00000001  // The menu is or should start expanded")
cpp_quote("#define SMAE_CONTRACTED         0x00000002  // The menu is or should start contracted")
cpp_quote("                                            // SMAE_EXPANDED and SMAE_CONTRACTED are mutually exclusive")
cpp_quote("#define SMAE_USER               0x00000004  // Indicates that the menu expansion/contraction is a reflection")
cpp_quote("                                            // of user choice")
cpp_quote("#define SMAE_VALID              0x00000007")
cpp_quote("#endif  // _WIN32_IE_IE70")

[
    uuid(4CA300A1-9B8D-11d1-8B22-00C04FD918D0),
    object,
    pointer_default(unique),
    local // cannot marshal because method has polymorphic parameters
]

interface IShellMenuCallback : IUnknown
{
    // psmd is [in,out] because SMC_MAPACCELERATOR returns a value in uId
    HRESULT CallbackSM(
        [in, out, annotation("_Inout_")] LPSMDATA psmd,
        [in, annotation("_In_")] UINT uMsg,
        [in, annotation("_In_")] WPARAM wParam,
        [in, annotation("_In_")] LPARAM lParam);
}

//-------------------------------------------------------------------------
//
// IShellMenu interface
//
//-------------------------------------------------------------------------

cpp_quote("#define SMINIT_DEFAULT              0x00000000  // No Options")
cpp_quote("#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop")
cpp_quote("#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.")
cpp_quote("#define SMINIT_CACHED               0x00000010")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define SMINIT_AUTOEXPAND           0x00000100  // automatically expand/contract menu band")
cpp_quote("#define SMINIT_AUTOTOOLTIP          0x00000200  // regular tooltip support")
cpp_quote("#define SMINIT_DROPONCONTAINER      0x00000400  // allow drop on a container")
cpp_quote("#endif  // _WIN32_IE_IE70")

// These are mutually Exclusive
cpp_quote("#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu")
cpp_quote("#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)")

cpp_quote("#define ANCESTORDEFAULT      (UINT)-1")

cpp_quote("#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu")
cpp_quote("#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu")
cpp_quote("#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object")
                                                  // and should not destroy it.

cpp_quote("#define SMINV_REFRESH        0x00000001")
cpp_quote("#define SMINV_ID             0x00000008")

[
    uuid(EE1F7637-E138-11d1-8379-00C04FD918D0),
    object,
    pointer_default(unique), /* some of our pointers can be NULL (as noted) */
    local
]
interface IShellMenu : IUnknown
{
    HRESULT Initialize(
        [in, unique, annotation("_In_opt_")] IShellMenuCallback* psmc,
        [in, annotation("_In_")] UINT uId,
        [in, annotation("_In_")] UINT uIdAncestor,
        [in, annotation("_In_")] DWORD dwFlags);

    HRESULT GetMenuInfo(
        [out, annotation("_Outptr_opt_")] IShellMenuCallback** ppsmc,
        [out, annotation("_Out_opt_")] UINT* puId,
        [out, annotation("_Out_opt_")] UINT* puIdAncestor,
        [out, annotation("_Out_opt_")] DWORD* pdwFlags);

    HRESULT SetShellFolder(
        [in, unique, annotation("_In_opt_")] IShellFolder* psf,
        [in, unique, annotation("_In_opt_")] PCIDLIST_ABSOLUTE pidlFolder,
        [in, unique, annotation("_In_opt_")] HKEY hKey,
        [in, annotation("_In_")] DWORD dwFlags);

    HRESULT GetShellFolder(
        [out, annotation("_Out_")] DWORD* pdwFlags,
        [out, annotation("_Outptr_")] PIDLIST_ABSOLUTE* ppidl,
        [in] REFIID riid,
        [out, iid_is(riid), annotation("_Outptr_")] void** ppv);

    HRESULT SetMenu(
        [in, unique, annotation("_In_opt_")] HMENU hmenu,
        [in, unique, annotation("_In_opt_")] HWND hwnd,
        [in, annotation("_In_")] DWORD dwFlags);

    HRESULT GetMenu(
        [out, annotation("_Out_opt_")] HMENU* phmenu,
        [out, annotation("_Out_opt_")] HWND* phwnd,
        [out, annotation("_Out_opt_")] DWORD* pdwFlags);

    HRESULT InvalidateItem(
        [in, annotation("_In_opt_")] LPSMDATA psmd,
        [in, annotation("_In_")] DWORD dwFlags);

    HRESULT GetState([out, annotation("_Out_")] LPSMDATA psmd);

    HRESULT SetMenuToolbar(
        [in, annotation("_In_")] IUnknown* punk,
        [in, annotation("_In_")] DWORD dwFlags);
}

cpp_quote("#endif  // _WIN32_IE_IE60")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

typedef [v1_enum] enum KF_CATEGORY
{
    KF_CATEGORY_VIRTUAL     = 1,       // virtual folders, have not file system path
    KF_CATEGORY_FIXED       = 2,       // fixed, predefined OS folders, might be different for different users
    KF_CATEGORY_COMMON      = 3,       // Public folders shared by all users, can be redirected
    KF_CATEGORY_PERUSER     = 4,       // User folders, can be redirected
} KF_CATEGORY;

[v1_enum] enum _KF_DEFINITION_FLAGS
{
    KFDF_LOCAL_REDIRECT_ONLY            = 0x00000002,    // Can only be redirected to a local disk
    KFDF_ROAMABLE                       = 0x00000004,    // Can be roamed via PC to PC sync
    KFDF_PRECREATE                      = 0x00000008,    // Pre create folder
    KFDF_STREAM                         = 0x00000010,    // folder is actually a file
    KFDF_PUBLISHEXPANDEDPATH            = 0x00000020,    // Expanded path is published in the registry under HKCU
    KFDF_NO_REDIRECT_UI                 = 0x00000040,    // New for NTDDI_WINBLUE. Cannot be redirected through the folder properties Location tab
};
typedef DWORD KF_DEFINITION_FLAGS;

[v1_enum] enum _KF_REDIRECT_FLAGS
{
    KF_REDIRECT_USER_EXCLUSIVE      = 0x00000001, // Give user exclusive permission
    KF_REDIRECT_COPY_SOURCE_DACL    = 0x00000002, // Copy the DACL of the source directory to target

    // Ownership checks for the target folder if the folder exists, by default, the API does not do any ownership checks
    KF_REDIRECT_OWNER_USER          = 0x00000004, // The owner of the folder must be the user itself
    KF_REDIRECT_SET_OWNER_EXPLICIT  = 0x00000008, // The owner of any newly created folder will be set explicitly
                                                    // by default if user belongs to Administrators group Administrators will be the owner

    // Check if the redirection is already done, S_OK if yes, S_FALSE if some actions need to be done.
    KF_REDIRECT_CHECK_ONLY          = 0x00000010,

    // Enable user interaction when redirecting
    KF_REDIRECT_WITH_UI             = 0x00000020,

    // CSC related settings
    KF_REDIRECT_UNPIN               = 0x00000040, // Unpin the source folder
    KF_REDIRECT_PIN                 = 0x00000080, // Pin the target folder

    KF_REDIRECT_COPY_CONTENTS       = 0x00000200, // Copy the contents (both files and subfolders) under the known folder
    KF_REDIRECT_DEL_SOURCE_CONTENTS = 0x00000400, // Delete source, valid only if KF_REDIRECT_COPY_CONTENTS set

    KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS
                                    = 0x00000800, // Exclude all known subfolders from redirection
};
typedef DWORD KF_REDIRECT_FLAGS;

[v1_enum] enum _KF_REDIRECTION_CAPABILITIES
{
    KF_REDIRECTION_CAPABILITIES_ALLOW_ALL               = 0x000000FF, // if any of these flags set this means that
                                                                      // the folder can potentially be redirected unless
                                                                      // any deny flag is set
    KF_REDIRECTION_CAPABILITIES_REDIRECTABLE            = 0x00000001, // the folder can potentially be redirected
                                                                      // currently we only allow redirection for
                                                                      // common and user's folders.
                                                                      // Fixed and virtual can not be redirected

    KF_REDIRECTION_CAPABILITIES_DENY_ALL                = 0x000FFF00, // If any of there flags set then redirection is blocked
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED  = 0x00000100, // Folder can not be redirected because it is redirected by group policy
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY             = 0x00000200, // Folder can not be redirected because the policy prohibits redirecting this folder
    KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS        = 0x00000400, // Folder can not be redirected because the caller does not have sufficient permissions
};
typedef DWORD KF_REDIRECTION_CAPABILITIES;

typedef struct KNOWNFOLDER_DEFINITION
{
    KF_CATEGORY             category;
    LPWSTR                  pszName;
    LPWSTR                  pszDescription;
    KNOWNFOLDERID           fidParent;
    LPWSTR                  pszRelativePath;
    LPWSTR                  pszParsingName;
    LPWSTR                  pszTooltip;
    LPWSTR                  pszLocalizedName;
    LPWSTR                  pszIcon;
    LPWSTR                  pszSecurity;
    DWORD                   dwAttributes;
    KF_DEFINITION_FLAGS     kfdFlags;
    FOLDERTYPEID            ftidType;
} KNOWNFOLDER_DEFINITION;

// Known Folder Interface
[
    uuid(3AA7AF7E-9B36-420c-A8E3-F77D4674A488),
    object,
    version(1.0),
    pointer_default(ref)
]
interface IKnownFolder : IUnknown
{
    HRESULT GetId([out] KNOWNFOLDERID *pkfid);

    HRESULT GetCategory([out] KF_CATEGORY* pCategory);

    // get the ShellItem (IShellItem or derived interface) for this known folder
    HRESULT GetShellItem(
        [in] DWORD /* KNOWN_FOLDER_FLAG */ dwFlags,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT GetPath(
        [in] DWORD /* KNOWN_FOLDER_FLAG */ dwFlags,
        [out, string] LPWSTR *ppszPath);

    HRESULT SetPath(
        [in] DWORD /* KNOWN_FOLDER_FLAG */ dwFlags,
        [in, string] LPCWSTR pszPath);

    HRESULT GetIDList(
        [in] DWORD /* KNOWN_FOLDER_FLAG */ dwFlags,
        [out] PIDLIST_ABSOLUTE *ppidl);

    HRESULT GetFolderType([out] FOLDERTYPEID *pftid);

    HRESULT GetRedirectionCapabilities([out] KF_REDIRECTION_CAPABILITIES * pCapabilities);

    HRESULT GetFolderDefinition([out] KNOWNFOLDER_DEFINITION *pKFD);
}

// Known Folder Manager
[
    uuid(8BE2D872-86AA-4d47-B776-32CCA40C7018),
    object,
    version(1.0),
    pointer_default(ref)
]
interface IKnownFolderManager : IUnknown
{
    typedef [v1_enum] enum FFFP_MODE
    {
        FFFP_EXACTMATCH,
        FFFP_NEARESTPARENTMATCH,
    } FFFP_MODE;

    HRESULT FolderIdFromCsidl(
        [in] int nCsidl,
        [out] KNOWNFOLDERID *pfid);

    HRESULT FolderIdToCsidl(
        [in] REFKNOWNFOLDERID rfid,
        [out] int *pnCsidl);

    HRESULT GetFolderIds(
        [out, size_is( , *pCount)] KNOWNFOLDERID ** ppKFId,
        [in, out] UINT *pCount);

    HRESULT GetFolder(
        [in] REFKNOWNFOLDERID rfid,
        [out] IKnownFolder **ppkf);

    HRESULT GetFolderByName(
        [in, string] LPCWSTR pszCanonicalName,
        [out] IKnownFolder **ppkf);

    HRESULT RegisterFolder(
        [in] REFKNOWNFOLDERID rfid,
        [in] KNOWNFOLDER_DEFINITION const *pKFD);

    HRESULT UnregisterFolder([in] REFKNOWNFOLDERID rfid);

    HRESULT FindFolderFromPath(
        [in, string] LPCWSTR pszPath,
        [in] FFFP_MODE mode,
        [out] IKnownFolder **ppkf);

    HRESULT FindFolderFromIDList(
        [in] PCIDLIST_ABSOLUTE pidl,
        [out] IKnownFolder **ppkf);

    [local]
    HRESULT Redirect(
        [in, annotation("_In_")] REFKNOWNFOLDERID rfid,
        [in, unique, annotation("_In_opt_")] HWND hwnd,
        [in, annotation("_In_")] KF_REDIRECT_FLAGS flags,
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszTargetPath,
        [in, annotation("_In_")] UINT cFolders,
        [in, size_is(cFolders), unique, annotation("_In_reads_opt_(cFolders)")] KNOWNFOLDERID const *pExclusion,
        [out, string, annotation("_Outptr_opt_result_maybenull_")] LPWSTR* ppszError);

    [call_as(Redirect)]
    HRESULT RemoteRedirect(
        [in] REFKNOWNFOLDERID rfid,
        [in, unique] HWND hwnd,
        [in] KF_REDIRECT_FLAGS flags,
        [in, unique, string] LPCWSTR pszTargetPath,
        [in] UINT cFolders,
        [in, size_is(cFolders), unique] GUID const *pExclusion,
        [out, string] LPWSTR* ppszError);
}

// use this to free the allocated fields in the result from IKnownFolderManager::GetFolderDefinition(&kfd)
cpp_quote("__inline void FreeKnownFolderDefinitionFields(_In_ KNOWNFOLDER_DEFINITION *pKFD)")
cpp_quote("{")
cpp_quote("    CoTaskMemFree(pKFD->pszName);")
cpp_quote("    CoTaskMemFree(pKFD->pszDescription);")
cpp_quote("    CoTaskMemFree(pKFD->pszRelativePath);")
cpp_quote("    CoTaskMemFree(pKFD->pszParsingName);")
cpp_quote("    CoTaskMemFree(pKFD->pszTooltip);")
cpp_quote("    CoTaskMemFree(pKFD->pszLocalizedName);")
cpp_quote("    CoTaskMemFree(pKFD->pszIcon);")
cpp_quote("    CoTaskMemFree(pKFD->pszSecurity);")
cpp_quote("}")

typedef [v1_enum] enum SHARE_ROLE
{
    SHARE_ROLE_INVALID = -1,
    SHARE_ROLE_READER = 0,
    SHARE_ROLE_CONTRIBUTOR = 1,
    SHARE_ROLE_CO_OWNER = 2,
    SHARE_ROLE_OWNER = 3,
    SHARE_ROLE_CUSTOM = 4,
    SHARE_ROLE_MIXED = 5,
}
SHARE_ROLE;

typedef [v1_enum] enum DEF_SHARE_ID
{
    DEFSHAREID_USERS = 1,
    DEFSHAREID_PUBLIC = 2,
}
DEF_SHARE_ID;

// Sharing Configuration Manager
[
    object,
    uuid(B4CD448A-9C86-4466-9201-2E62105B87AE)
]
interface ISharingConfigurationManager : IUnknown
{
    HRESULT CreateShare(
        [in] DEF_SHARE_ID dsid,
        [in] SHARE_ROLE role);

    HRESULT DeleteShare([in] DEF_SHARE_ID dsid);

    // returns S_OK if the share exists, S_FALSE otherwise
    HRESULT ShareExists([in] DEF_SHARE_ID dsid);

    HRESULT GetSharePermissions(
        [in] DEF_SHARE_ID dsid,
        [out] SHARE_ROLE* pRole);

    HRESULT SharePrinters();

    HRESULT StopSharingPrinters();

    HRESULT ArePrintersShared();
}

cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

// Base interface from which to derive "related items"
// with specific relationships, and identical method signatures.
//
// Use with
// IShellItem::BindToHandler, BHID_SFObject
// IShellFolder::BindToObject
[
    object,
    uuid(a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0),
    pointer_default(unique)
]
interface IRelatedItem : IUnknown
{
    HRESULT GetItemIDList([out] PIDLIST_ABSOLUTE *ppidl);

    HRESULT GetItem([out] IShellItem **ppsi);
}

// Used to obtain the true identity of the item, so it can be
// determined if two items actually represent the same item.
[
    object,
    uuid(7d903fca-d6f9-4810-8332-946c0177e247),
    pointer_default(unique)
]
interface IIdentityName : IRelatedItem
{
}

// Used to obtain the delegate item of an item, where the
// item is delegating to the underlying "delegate" item.
// Unlike IIdentityName, IDelegateItem only "unwraps" one
// level of aliasing.
[
    object,
    uuid(3c5a1c94-c951-4cb7-bb6d-3b93f30cce93),
    pointer_default(unique)
]
interface IDelegateItem : IRelatedItem
{
}

// If an item represents a snapshot of an item taken at a previous time,
// ICurrentItem will let you obtain the current version of the item.
[
    object,
    uuid(240a7174-d653-4a1d-a6d3-d4943cfbfe3d),
    pointer_default(unique)
]
interface ICurrentItem : IRelatedItem
{
}

// used to find the transfer object. that is the object that should be
// queried and enumerated for copy/move/delete.
[
    object,
    uuid(77f295d5-2d6f-4e19-b8ae-322f3e721ab5),
    pointer_default(unique)
]
interface ITransferMediumItem : IRelatedItem
{
}

// IDisplayItem provides the item to show UI on (used by the copy engine dialogs)
[
    object,
    uuid(c6fd5997-9f6b-4888-8703-94e80e8cde3f),
    pointer_default(unique)
]
interface IDisplayItem : IRelatedItem
{
}

// IViewStateIdentityItem is used to provide a canonical persistence item
// This is item for which view customizations will be remembered
// (example: the orignal folder item minus the search query)
[
    object,
    uuid(9D264146-A94F-4195-9F9F-3BB12CE0C955),
    pointer_default(unique)
]
interface IViewStateIdentityItem : IRelatedItem
{
}

// IPreviewItem provides an item to show in the preview pane
[
    object,
    uuid(36149969-0A8F-49c8-8B00-4AECB20222FB),
    pointer_default(unique)
]
interface IPreviewItem : IRelatedItem
{
}

cpp_quote("#endif  // NTDDI_VISTA")

[
    uuid(8a87781b-39a7-4a1f-aab3-a39b9c34a7d9),
    object,
    pointer_default(unique)
]
interface IDestinationStreamFactory : IUnknown
{
    HRESULT GetDestinationStream([out] IStream **ppstm);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

// SID_ExecuteCreatingProcess/ICreatingProcess
// A service implemented by callers of ShellExecute that lets them modify the inputs
// of CreateProcess before it is called.
// See SEE_MASK_FLAG_HINST_IS_SITE for details on how to provide this service.
[
    object,
    uuid(F6EF6140-E26F-4D82-bAC4-E9BA5FD239A8),
    pointer_default(unique),
    local
]
interface ICreateProcessInputs : IUnknown
{
    // CreateProcess() dwCreationFlags parameter
    HRESULT GetCreateFlags([out, annotation("_Out_")] DWORD *pdwCreationFlags);
    HRESULT SetCreateFlags([in, annotation("_In_")] DWORD dwCreationFlags);
    HRESULT AddCreateFlags([in, annotation("_In_")] DWORD dwCreationFlags);

    HRESULT SetHotKey([in, annotation("_In_")] WORD wHotKey);

    // STARTUPINFO.dwFlags
    HRESULT AddStartupFlags([in, annotation("_In_")] DWORD dwStartupInfoFlags);
    HRESULT SetTitle([in, string, annotation("_In_")] LPCWSTR pszTitle);
    HRESULT SetEnvironmentVariable(
        [in, string, annotation("_In_")] LPCWSTR pszName,
        [in, string, annotation("_In_")] LPCWSTR pszValue);
}

[ uuid(c2b937a9-3110-4398-8a56-f34c6342d244), local ]
interface ICreatingProcess : IUnknown
{
    HRESULT OnCreating([in, annotation("_In_")] ICreateProcessInputs *pcpi);
}

cpp_quote("#define SID_ExecuteCreatingProcess __uuidof(ICreatingProcess)")

cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN10_RS4)") // not yet functional

// SID_LaunchUIContextProvider/ILaunchUIContextProvider
// A service implemented by callers of ShellExecute or other launching APIs that
// allows them to specify information that controls the window management user experience
// of the window created as the result of the launch. This includes
// the associated window and controlling tabbing behavior.
// See SEE_MASK_FLAG_HINST_IS_SITE for details on how to provide this service.

[uuid(1791e8f6-21c7-4340-882a-a6a93e3fd73b)]
interface ILaunchUIContext : IUnknown
{
    HRESULT SetAssociatedWindow([in] HWND value);
    HRESULT SetTabGroupingPreference([in] DWORD /* Windows::UI::ViewManagement::ViewGrouping */ value);
}

[uuid(0d12c4c8-a3d9-4e24-94c1-0e20c5a956c4)]
interface ILaunchUIContextProvider : IUnknown
{
    HRESULT UpdateContext([in] ILaunchUIContext* context);
}

cpp_quote("#define SID_LaunchUIContextProvider __uuidof(ILaunchUIContextProvider)")

cpp_quote("#endif  // (NTDDI_VERSION >= NTDDI_WIN10_RS4)")

[v1_enum] enum _NMCII_FLAGS
{
    NMCII_NONE         = 0x0000, // New for NTDDI_WIN8
    NMCII_ITEMS        = 0x0001,
    NMCII_FOLDERS      = 0x0002,
};
typedef int NMCII_FLAGS;

[v1_enum] enum _NMCSAEI_FLAGS
{
    NMCSAEI_SELECT      = 0x0000,
    NMCSAEI_EDIT        = 0x0001,
};
typedef int NMCSAEI_FLAGS;

[
    uuid(dcb07fdc-3bb5-451c-90be-966644fed7b0),
    pointer_default(unique)
]
interface INewMenuClient : IUnknown
{
    HRESULT IncludeItems([out] NMCII_FLAGS *pflags);

    HRESULT SelectAndEditItem(
        [in] PCIDLIST_ABSOLUTE pidlItem,
        [in] NMCSAEI_FLAGS flags);
}

cpp_quote("#define SID_SNewMenuClient   IID_INewMenuClient")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

[
    object,
    uuid(71c0d2bc-726d-45cc-a6c0-2e31c1db2159),
    pointer_default(unique)
]
interface IInitializeWithBindCtx : IUnknown
{
    HRESULT Initialize([in] IBindCtx *pbc);
}

[
    object,
    uuid(2659B475-EEB8-48b7-8F07-B378810F48CF),
    pointer_default(unique)
]
interface IShellItemFilter : IUnknown
{
    HRESULT IncludeItem([in] IShellItem *psi);

    HRESULT GetEnumFlagsForItem(
        [in] IShellItem *psi,
        [out] SHCONTF *pgrfFlags);
}

cpp_quote("#endif  // (_WIN32_IE >= _WIN32_IE_IE70)")

[
    object,
    uuid(028212A3-B627-47e9-8856-C14265554E4F)
]
interface INameSpaceTreeControl : IUnknown
{
    [v1_enum] enum _NSTCSTYLE
    {
        NSTCS_HASEXPANDOS           = 0x00000001,
        NSTCS_HASLINES              = 0x00000002,
        NSTCS_SINGLECLICKEXPAND     = 0x00000004,
        NSTCS_FULLROWSELECT         = 0x00000008,
        NSTCS_SPRINGEXPAND          = 0x00000010,
        NSTCS_HORIZONTALSCROLL      = 0x00000020,
        NSTCS_ROOTHASEXPANDO        = 0x00000040,
        NSTCS_SHOWSELECTIONALWAYS   = 0x00000080,
        NSTCS_NOINFOTIP             = 0x00000200,
        NSTCS_EVENHEIGHT            = 0x00000400,
        NSTCS_NOREPLACEOPEN         = 0x00000800,
        NSTCS_DISABLEDRAGDROP       = 0x00001000,
        NSTCS_NOORDERSTREAM         = 0x00002000,
        NSTCS_RICHTOOLTIP           = 0x00004000,
        NSTCS_BORDER                = 0x00008000,
        NSTCS_NOEDITLABELS          = 0x00010000,
        NSTCS_TABSTOP               = 0x00020000,
        NSTCS_FAVORITESMODE         = 0x00080000,  // temporary
        NSTCS_AUTOHSCROLL           = 0x00100000,
        NSTCS_FADEINOUTEXPANDOS     = 0x00200000,
        NSTCS_EMPTYTEXT             = 0x00400000,  // insert empty text when folder is empty
        NSTCS_CHECKBOXES            = 0x00800000,
        NSTCS_PARTIALCHECKBOXES     = 0x01000000,
        NSTCS_EXCLUSIONCHECKBOXES   = 0x02000000,
        NSTCS_DIMMEDCHECKBOXES      = 0x04000000,
        NSTCS_NOINDENTCHECKS        = 0x08000000,
        NSTCS_ALLOWJUNCTIONS        = 0x10000000,
        NSTCS_SHOWTABSBUTTON        = 0x20000000,
        NSTCS_SHOWDELETEBUTTON      = 0x40000000,
        NSTCS_SHOWREFRESHBUTTON     = (int) 0x80000000,
    };
    typedef DWORD NSTCSTYLE;

    [v1_enum] enum _NSTCROOTSTYLE
    {
        NSTCRS_VISIBLE      = 0x0000,
        NSTCRS_HIDDEN       = 0x0001,
        NSTCRS_EXPANDED     = 0x0002,
    };
    typedef DWORD NSTCROOTSTYLE;

    [v1_enum] enum _NSTCITEMSTATE
    {
        NSTCIS_NONE             = 0x0000,
        NSTCIS_SELECTED         = 0x0001,
        NSTCIS_EXPANDED         = 0x0002,
        NSTCIS_BOLD             = 0x0004,
        NSTCIS_DISABLED         = 0x0008,
        NSTCIS_SELECTEDNOEXPAND = 0x0010,
    };
    typedef DWORD NSTCITEMSTATE;

    typedef [v1_enum] enum NSTCGNI
    {
        NSTCGNI_NEXT            = 0,
        NSTCGNI_NEXTVISIBLE     = 1,
        NSTCGNI_PREV            = 2,
        NSTCGNI_PREVVISIBLE     = 3,
        NSTCGNI_PARENT          = 4,
        NSTCGNI_CHILD           = 5,
        NSTCGNI_FIRSTVISIBLE    = 6,
        NSTCGNI_LASTVISIBLE     = 7,
    } NSTCGNI;

    HRESULT Initialize(
        [in] HWND hwndParent,
        [in, unique] RECT *prc,
        [in] NSTCSTYLE nsctsFlags);

    HRESULT TreeAdvise(
        [in] IUnknown *punk,
        [out] DWORD *pdwCookie);

    HRESULT TreeUnadvise([in] DWORD dwCookie);

    HRESULT AppendRoot(
        [in] IShellItem *psiRoot,
        [in] SHCONTF grfEnumFlags,
        [in] NSTCROOTSTYLE grfRootStyle,
        [in, unique] IShellItemFilter *pif);

    HRESULT InsertRoot(
        [in] int iIndex,
        [in] IShellItem *psiRoot,
        [in] SHCONTF grfEnumFlags,
        [in] NSTCROOTSTYLE grfRootStyle,
        [in, unique] IShellItemFilter *pif);

    HRESULT RemoveRoot([in] IShellItem *psiRoot);

    HRESULT RemoveAllRoots();

    HRESULT GetRootItems([out] IShellItemArray **ppsiaRootItems);

    HRESULT SetItemState(
        [in] IShellItem *psi,
        [in] NSTCITEMSTATE nstcisMask,
        [in] NSTCITEMSTATE nstcisFlags);

    HRESULT GetItemState(
        [in] IShellItem *psi,
        [in] NSTCITEMSTATE nstcisMask,
        [out] NSTCITEMSTATE *pnstcisFlags);

    HRESULT GetSelectedItems([out] IShellItemArray **psiaItems);

    HRESULT GetItemCustomState(
        [in] IShellItem *psi,
        [out] int *piStateNumber);

    HRESULT SetItemCustomState(
        [in] IShellItem *psi,
        [in] int iStateNumber);

    HRESULT EnsureItemVisible([in] IShellItem *psi);

    HRESULT SetTheme([in, string] LPCWSTR pszTheme);

    HRESULT GetNextItem(
        [in, unique] IShellItem *psi,
        [in] NSTCGNI nstcgi,
        [out] IShellItem **ppsiNext);

    HRESULT HitTest(
        [in] POINT *ppt,
        [out] IShellItem **ppsiOut);

    HRESULT GetItemRect(
        [in] IShellItem *psi,
        [out] RECT *prect);

    HRESULT CollapseAll();
}

cpp_quote("#define SID_SNavigationPane IID_INameSpaceTreeControl   // nearest service that you can proffer to")

//cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
[
    object,
    uuid(e9701183-e6b3-4ff2-8568-813615fec7be),
    local
]
interface INameSpaceTreeControlFolderCapabilities : IUnknown
{
    typedef [v1_enum] enum NSTCFOLDERCAPABILITIES
    {
        NSTCFC_NONE                    = 0x00000000,
        NSTCFC_PINNEDITEMFILTERING     = 0x00000001, // Supports filtering based on PKEY_IsPinnedToNameSpaceTree
        NSTCFC_DELAY_REGISTER_NOTIFY   = 0x00000002, // Delays registration for change notifications until expanded in navigation pane
    } NSTCFOLDERCAPABILITIES;
    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(NSTCFOLDERCAPABILITIES)")

    HRESULT GetFolderCapabilities([in, annotation("_In_")] NSTCFOLDERCAPABILITIES nfcMask, [out, annotation("_Out_")] NSTCFOLDERCAPABILITIES *pnfcValue);
}

cpp_quote("#endif  // NTDDI_VISTA")

// New for Vista, but used by downlevel code
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
// IPreviewHandler::DoPreview error codes
cpp_quote("#define E_PREVIEWHANDLER_DRM_FAIL _HRESULT_TYPEDEF_(0x86420001L)") // blocked by digital rights management
cpp_quote("#define E_PREVIEWHANDLER_NOAUTH   _HRESULT_TYPEDEF_(0x86420002L)") // blocked by file permissions
cpp_quote("#define E_PREVIEWHANDLER_NOTFOUND _HRESULT_TYPEDEF_(0x86420003L)") // item was not found
cpp_quote("#define E_PREVIEWHANDLER_CORRUPT  _HRESULT_TYPEDEF_(0x86420004L)") // item was corrupt

[
    object,
    uuid(8895b1c6-b41f-4c1c-a562-0d564250836f),
]
interface IPreviewHandler : IUnknown
{
    HRESULT SetWindow(
        [in] HWND hwnd,
        [in] const RECT *prc);

    HRESULT SetRect([in] const RECT *prc);

    HRESULT DoPreview();

    HRESULT Unload();

    HRESULT SetFocus();

    HRESULT QueryFocus([out] HWND* phwnd);

    HRESULT TranslateAccelerator([in] MSG* pmsg);
}

[
    object,
    uuid(fec87aaf-35f9-447a-adb7-20234491401a),
    pointer_default(unique)
]
interface IPreviewHandlerFrame: IUnknown
{
    typedef struct PREVIEWHANDLERFRAMEINFO
    {
        HACCEL haccel;
        UINT   cAccelEntries;
    } PREVIEWHANDLERFRAMEINFO;

    HRESULT GetWindowContext([out] PREVIEWHANDLERFRAMEINFO* pinfo);

    HRESULT TranslateAccelerator([in] MSG* pmsg);
}
//cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")

typedef GUID EXPLORERPANE; // identifies panes

// these typedefs are used only for the MIDL pass, everyone else gets the cpp_quote stuff
cpp_quote("#if 0")
    typedef EXPLORERPANE *REFEXPLORERPANE;
cpp_quote("#endif // 0")

cpp_quote("#ifdef __cplusplus")
cpp_quote("#define REFEXPLORERPANE const EXPLORERPANE &")
cpp_quote("#else // !__cplusplus")
cpp_quote("#define REFEXPLORERPANE const EXPLORERPANE * __MIDL_CONST")
cpp_quote("#endif // __cplusplus")

[
    object,
    uuid(e07010ec-bc17-44c0-97b0-46c7c95b9edc),
    local,
    pointer_default(unique)
]
interface IExplorerPaneVisibility : IUnknown
{
    [v1_enum] enum _EXPLORERPANESTATE
    {
        // ordinals
        EPS_DONTCARE     = 0x0000,  // don't impact the pane at all
        EPS_DEFAULT_ON   = 0x0001,  // set its default state to "on", however user-modified persisted state is respected.
        EPS_DEFAULT_OFF  = 0x0002,  //  "   "   "  "off".
        EPS_STATEMASK    = 0xFFFF,

        // flags
        // not all ExplorerPanes will necessarily respect these flags
        EPS_INITIALSTATE      = 0x00010000,  // ignore persisted state from the user, but user can still modify the state.
        EPS_FORCE             = 0x00020000,  // user can't modify the state (i.e. hide affordances for show/hide).  implies EPS_INITIALSTATE.
    };
    typedef DWORD EXPLORERPANESTATE;

    // each pane has its own semantic, for example the NavPane is opt-out, so EPS_DONTCARE means you'll typically have the
    // NavPane displayed, clients who want it to never show will pass EPS_DEFAULT_OFF | EPS_FORCE.
    // QueryPane is opt-in, so it will only show for clients who pass EPS_DEFAULT_ON.  however its default persisted state
    // is "off" so if you want to force it on you have to pass EPS_DEFAULT_ON | EPS_INITIALSTATE.

    // IExplorerPaneVisibility client can provide default states by returning EXPLORERPANESTATE here,
    // failure of GetPaneState corresponds to EPS_DONTCARE.
    HRESULT GetPaneState([in, annotation("_In_")] REFEXPLORERPANE ep, [out, annotation("_Out_")] EXPLORERPANESTATE *peps);
}
cpp_quote("#define SID_ExplorerPaneVisibility IID_IExplorerPaneVisibility")

// controls the behavior of the SHCreateDefaultContextMenu()

[
    object,
    uuid(3409E930-5A39-11d1-83FA-00A0C90DC849),
    pointer_default(unique),
    local
]
interface IContextMenuCB : IUnknown
{
    // uMsg is one of DFM_XXX values
    HRESULT CallBack(
        [in, unique, annotation("_In_opt_")] IShellFolder *psf,
        [in, unique, annotation("_In_opt_")] HWND hwndOwner,
        [in, unique, annotation("_In_opt_")] IDataObject *pdtobj,
        [in, annotation("_In_")] UINT uMsg,
        [in, annotation("_In_")] WPARAM wParam,
        [in, annotation("_In_")] LPARAM lParam);
}

cpp_quote("#endif  // NTDDI_VISTA")

[
    object,
    uuid(41ded17d-d6b3-4261-997d-88c60e4b1d58),
    local,
    pointer_default(unique)
]
interface IDefaultExtractIconInit : IUnknown
{
    // set IExtractIcon GIL_XXX flags
    HRESULT SetFlags([in, annotation("_In_")] UINT uFlags);

    // set the registry key to load "DefaultIcon" value from
    HRESULT SetKey([in, annotation("_In_")] HKEY hkey);

    // set the various forms of icons, if pszFile is NULL iIcon is SHSTOCKICONID (SIID_) value
    HRESULT SetNormalIcon(
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszFile,
        [in, annotation("_In_")] int iIcon);

    HRESULT SetOpenIcon(
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszFile,
        [in, annotation("_In_")] int iIcon);

    HRESULT SetShortcutIcon(
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszFile,
        [in, annotation("_In_")] int iIcon);

    HRESULT SetDefaultIcon(
        [in, unique, string, annotation("_In_opt_")] LPCWSTR pszFile,
        [in, annotation("_In_")] int iIcon);
}

// "Default" IExtractIcon implementation useful for implementation of ::GetUIObjectOf(IID_IExtractIcon)
cpp_quote("STDAPI SHCreateDefaultExtractIcon(_In_ REFIID riid, _Outptr_ void **ppv);")

interface IEnumExplorerCommand;

[
    uuid(a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9),
    pointer_default(unique)
]
interface IExplorerCommand : IUnknown
{
    [v1_enum] enum _EXPCMDSTATE
    {
        ECS_ENABLED     = 0x00,
        ECS_DISABLED    = 0x01,
        ECS_HIDDEN      = 0x02,
        ECS_CHECKBOX    = 0x04,
        ECS_CHECKED     = 0x08,
        ECS_RADIOCHECK  = 0x10,
    };
    typedef DWORD EXPCMDSTATE;

    [v1_enum] enum _EXPCMDFLAGS
    {
        ECF_DEFAULT =          0x000,
        ECF_HASSUBCOMMANDS =   0x001,
        ECF_HASSPLITBUTTON =   0x002,
        ECF_HIDELABEL =        0x004,
        ECF_ISSEPARATOR =      0x008,
        ECF_HASLUASHIELD =     0x010,
        ECF_SEPARATORBEFORE =  0x020,
        ECF_SEPARATORAFTER =   0x040,
        ECF_ISDROPDOWN =       0x080,
        ECF_TOGGLEABLE =       0x100, // New for NTDDI_WIN8
        ECF_AUTOMENUICONS =    0x200, // New for NTDDI_WIN8
    };
    typedef DWORD EXPCMDFLAGS;

    HRESULT GetTitle([in, unique] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszName);

    // fill in ppszIcon with an icon resource strings format, for example "shell32,-123"
    HRESULT GetIcon([in, unique] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszIcon);

    HRESULT GetToolTip([in, unique] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszInfotip);

    HRESULT GetCanonicalName([out] GUID *pguidCommandName);

    // Compute the visibility state of the verb here
    // When "fOkToBeSlow" is FALSE this method must return quickly, in this case you can
    // return E_PENDING and this object will be recreated on a background thread and called with
    // fOkToBeSlow == TRUE where you can do expensive work.
    HRESULT GetState([in, unique] IShellItemArray *psiItemArray, [in] BOOL fOkToBeSlow, [out] EXPCMDSTATE *pCmdState);

    HRESULT Invoke([in, unique] IShellItemArray *psiItemArray, [in, unique] IBindCtx *pbc);

    HRESULT GetFlags([out] EXPCMDFLAGS *pFlags);

    // If GetFlags() returned ECF_HASSUBCOMMANDS this will be used to discover the sub commands.
    HRESULT EnumSubCommands([out] IEnumExplorerCommand **ppEnum);
}

[
    uuid(bddacb60-7657-47ae-8445-d23e1acf82ae),
    object,
    pointer_default(unique)
]
interface IExplorerCommandState : IUnknown
{
    // Compute the visibility state of the verb here
    // When "fOkToBeSlow" is FALSE this method must return quickly, in this case you can
    // return E_PENDING and this object will be recreated on a background thread and called with
    // fOkToBeSlow == TRUE where you can do expensive work.
    // this method has the same semantics as IExplorerCommand::GetState()
    HRESULT GetState([in] IShellItemArray *psiItemArray, [in] BOOL fOkToBeSlow, [out] EXPCMDSTATE *pCmdState);
}

[
    object,
    uuid(85075acf-231f-40ea-9610-d26b7b58f638),
    pointer_default(unique)
]
interface IInitializeCommand : IUnknown
{
    // pszCommandName - This parameter is the verb that this handler instance is
    // being created for. If the same handler is used for different verbs this lets the
    // handler have different behavior for different verbs.
    //
    // ppb - This parameter provides access to values stored in the registry under the verb.
    // These values can be used to control the behavior of the verb handler for
    // different verb isntances.
    //
    // Another property bag can be used to share state between handler instances. This can be
    // accessed by implementing IObjectWithSite and then querying the site for SID_CommandsPropertyBag.
    HRESULT Initialize([in, string] LPCWSTR pszCommandName, [in] IPropertyBag *ppb);
}

[
    uuid(a88826f8-186f-4987-aade-ea0cef8fbfe8),
    object,
    pointer_default(unique)
]
interface IEnumExplorerCommand : IUnknown
{
    [local]
    HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched), annotation("_Out_writes_to_(celt, *pceltFetched)")] IExplorerCommand** pUICommand,
        [out, annotation("_Out_opt_ _Deref_out_range_(0, celt)")] ULONG *pceltFetched);

    [call_as(Next)]
    HRESULT RemoteNext(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] IExplorerCommand** pUICommand,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumExplorerCommand **ppenum);
}

[
    uuid(64961751-0835-43c0-8ffe-d57686530e64),
    pointer_default(unique)
]
interface IExplorerCommandProvider : IUnknown
{
    // IEnumExplorerCommand
    HRESULT GetCommands(
        [in] IUnknown *punkSite,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // IExplorerCommand
    HRESULT GetCommand(
        [in] REFGUID rguidCommandId,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
}

typedef HANDLE HTHEME;

typedef [v1_enum] enum CPVIEW
{
    CPVIEW_CLASSIC   = 0,
    CPVIEW_ALLITEMS  = CPVIEW_CLASSIC,
    CPVIEW_CATEGORY  = 1,
    CPVIEW_HOME      = CPVIEW_CATEGORY,
} CPVIEW;

[
    object,
    uuid(D11AD862-66DE-4DF4-BF6C-1F5621996AF1),
]
interface IOpenControlPanel : IUnknown
{
    HRESULT Open(
        [in, unique, string] LPCWSTR pszName,
        [in, unique, string] LPCWSTR pszPage,
        [in, unique] IUnknown *punkSite);

    HRESULT GetPath(
        [in, unique, string] LPCWSTR pszName,
        [out, string, size_is(cchPath)] LPWSTR pszPath,
        [in] UINT cchPath);

    HRESULT GetCurrentView([out] CPVIEW *pView);
}

// IShellFolder IBindCtx parameter: "File System Bind Data".
//
// The IUnknown for this is accessed through IBindCtx::RegisterObjectParam/GetObjectParam.
//
// Use this to provide the data needed to create IDLists through IShellFolder::ParseDisplayName().
//
// This data applies to the last element of the name that is parsed (c:\folder\file.txt,
// data applies to file.txt).
//
// This makes creating these IDLists much faster than supplying the name only.
// This is sometimes referred to as "simple parsing".

cpp_quote("#define STR_FILE_SYS_BIND_DATA      L\"File System Bind Data\"")

cpp_quote("#define STR_FILE_SYS_BIND_DATA_WIN7_FORMAT  L\"Win7FileSystemIdList\"")

[
    object,
    uuid(01E18D10-4D8B-11d2-855D-006008059367),
    pointer_default(unique),
    local
]
interface IFileSystemBindData : IUnknown
{
    HRESULT SetFindData([in] const WIN32_FIND_DATAW *pfd);
    HRESULT GetFindData([out] WIN32_FIND_DATAW *pfd);
}

[
    object,
    uuid(3acf075f-71db-4afa-81f0-3fc4fdf2a5b8),
    pointer_default(unique),
    local
]
interface IFileSystemBindData2 : IFileSystemBindData
{
    HRESULT SetFileID([in] LARGE_INTEGER liFileID);
    HRESULT GetFileID([out] LARGE_INTEGER *pliFileID);
    HRESULT SetJunctionCLSID([in] REFCLSID clsid);
    HRESULT GetJunctionCLSID([out] CLSID *pclsid);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN7)")

// Custom Destination List
[
    uuid(6332debf-87b5-4670-90c0-5e57b408a49e),
    object,
    pointer_default(unique),
]
interface ICustomDestinationList : IUnknown
{
    typedef [v1_enum] enum KNOWNDESTCATEGORY
    {
        KDC_FREQUENT = 1,
        KDC_RECENT,
    } KNOWNDESTCATEGORY;

    HRESULT SetAppID([in, string] LPCWSTR pszAppID);
    // Retrieve IObjectArray of IShellItems or IShellLinks that represent removed destinations
    HRESULT BeginList(
        [out] UINT *pcMinSlots,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
    HRESULT AppendCategory(
        [in, string] LPCWSTR pszCategory,
        [in] IObjectArray *poa);
    HRESULT AppendKnownCategory([in] KNOWNDESTCATEGORY category);
    HRESULT AddUserTasks([in] IObjectArray *poa);
    HRESULT CommitList();
    // Retrieve IObjectCollection of IShellItems
    HRESULT GetRemovedDestinations(
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
    HRESULT DeleteList([in, unique, string] LPCWSTR pszAppID);
    HRESULT AbortList();
}

// Used to remove items from the automatic destination lists created when apps or the system call SHAddToRecentDocs to report usage of a document.
[
    uuid(12337d35-94c6-48a0-bce7-6a9c69d4d600),
    object,
    pointer_default(unique),
]
interface IApplicationDestinations : IUnknown
{
    // Set the App User Model ID for the application removing destinations from its list.  If an AppID is not provided
    // via this method, the system will use a heuristically determined ID.  This method must be called before
    // RemoveDestination or RemoveAllDestinations.
    HRESULT SetAppID([in] LPCWSTR pszAppID);
    // Remove an IShellItem or an IShellLink from the automatic destination list
    HRESULT RemoveDestination([in] IUnknown *punk);
    // Clear the frequent and recent destination lists for this application.
    HRESULT RemoveAllDestinations();
}

// Allows an application to retrieve the most recent and frequent documents opened in that app, as reported via SHAddToRecentDocs
[
    uuid(3c594f9f-9f30-47a1-979a-c9e83d3d0a06),
    object,
    pointer_default(unique),
]
interface IApplicationDocumentLists : IUnknown
{
    typedef [v1_enum] enum APPDOCLISTTYPE
    {
        ADLT_RECENT = 0,   // The recently used documents list
        ADLT_FREQUENT,     // The frequently used documents list
    } APPDOCLISTTYPE;

    // Set the App User Model ID for the application retrieving this list.  If an AppID is not provided via this method,
    // the system will use a heuristically determined ID.  This method must be called before GetList.
    HRESULT SetAppID([in] LPCWSTR pszAppID);
    // Retrieve an IEnumObjects or IObjectArray for IShellItems and/or IShellLinks.
    // Items may appear in both the frequent and recent lists.
    HRESULT GetList([in] APPDOCLISTTYPE listtype, [in] UINT cItemsDesired, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
}

// Provides access to the App User Model ID on objects supporting this value
[
    uuid(36db0196-9665-46d1-9ba7-d3709eecf9ed),
    object,
    pointer_default(unique)
]
interface IObjectWithAppUserModelID : IUnknown
{
    HRESULT SetAppID([in, string] LPCWSTR pszAppID);
    HRESULT GetAppID([out, string] LPWSTR *ppszAppID);
}

// Provides access to the ProgID associated with an object
[
    uuid(71e806fb-8dee-46fc-bf8c-7748a8a1ae13),
    object,
    pointer_default(unique)
]
interface IObjectWithProgID : IUnknown
{
    HRESULT SetProgID([in, string] LPCWSTR pszProgID);
    HRESULT GetProgID([out, string] LPWSTR *ppszProgID);
}

[
    uuid(6589b6d2-5f8d-4b9e-b7e0-23cdd9717d8c),
    local,
    pointer_default(unique)
]
interface IUpdateIDList : IUnknown
{
    // Implemented by an IShellFolder implementation, this method updates the provided child IDList based on the
    // parameters specified by the provided IBindCtx.  If pbc is NULL, or does not contain any parameters that
    // apply to the current Shell Folder, pidlIn should simply be cloned into ppidlOut.
    HRESULT Update(
        [in, unique, annotation("_In_opt_")] IBindCtx *pbc,
        [in, annotation("_In_")] PCUITEMID_CHILD pidlIn,
        [out, annotation("_Outptr_")] PITEMID_CHILD *ppidlOut);
}

// Sets the User Model AppID for the current process, enabling Windows to retrieve this ID
cpp_quote("SHSTDAPI SetCurrentProcessExplicitAppUserModelID(_In_ PCWSTR AppID);")

// Retrieves the User Model AppID that has been explicitly set for the current process via
// SetCurrentProcessExplicitAppUserModelID
cpp_quote("SHSTDAPI GetCurrentProcessExplicitAppUserModelID(_Outptr_ PWSTR *AppID);")

cpp_quote("#endif // NTDDI_WIN7")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")

// IDesktopWallpaper
[
    uuid(B92B56A9-8B55-4E14-9A89-0199BBB6F93B),
    object
]
interface IDesktopWallpaper : IUnknown
{
    // This enumeration is used to set and get slideshow options.
    typedef [v1_enum] enum DESKTOP_SLIDESHOW_OPTIONS
    {
        DSO_SHUFFLEIMAGES = 0x01,     // When set, indicates that the order in which images in the slideshow are displayed can be randomized.
    } DESKTOP_SLIDESHOW_OPTIONS;

    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(DESKTOP_SLIDESHOW_OPTIONS)")

    // This enumeration is used by GetStatus to indicate the current status of the slideshow.
    typedef [v1_enum] enum DESKTOP_SLIDESHOW_STATE
    {
        DSS_ENABLED = 0x01,                    // Slideshows are enabled. This is normally true, unless the Enable method is used.
        DSS_SLIDESHOW = 0x02,                  // A slideshow is currently configured (e.g., using SetSlideshow).
        DSS_DISABLED_BY_REMOTE_SESSION = 0x04  // A remote session has temporarily disabled the slideshow
    } DESKTOP_SLIDESHOW_STATE;

    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(DESKTOP_SLIDESHOW_STATE)")

    // This enumeration is used by the AdvanceSlideshow method to indicate whether to advance the slideshow forward or backward.
    typedef [v1_enum] enum DESKTOP_SLIDESHOW_DIRECTION
    {
        DSD_FORWARD = 0,              // Advance slideshow forward.
        DSD_BACKWARD = 1,             // Advance slideshow backward.
    } DESKTOP_SLIDESHOW_DIRECTION;

    // This enumeration indicates the wallpaper position for all monitors. (This includes when slideshows are running.)
    // The wallpaper position specifies how the image that is assigned to a monitor should be displayed.
    typedef [v1_enum] enum DESKTOP_WALLPAPER_POSITION
    {
        DWPOS_CENTER = 0,             // Center the image, do not stretch (WPSTYLE_CENTER in IActiveDesktop).
        DWPOS_TILE = 1,               // Tile the image across all monitors (WPSTYLE_TILE in IActiveDesktop).
        DWPOS_STRETCH = 2,            // Stretch the image to exactly fit on the monitor (WPSTYLE_STRETCH in IActiveDesktop).
        DWPOS_FIT = 3,                // Stretch the image to exactly the height or width of the monitor without
                                      // changing its aspect ratio or cropping (WPSTYLE_KEEPASPECT in IActiveDesktop).
                                      // This often results in letterbox bars on the sides or top/bottom of the image.
        DWPOS_FILL = 4,               // Like DWPOS_FIT, but stretches the image until it completely fills the screen, allowing
                                      // cropping to avoid letterbox bars (WPSTYLE_CROPTOFIT in IActiveDesktop).
        DWPOS_SPAN = 5,               // Spans a single image across all monitors (new, no IActiveDesktop equivalent).
    } DESKTOP_WALLPAPER_POSITION;


    // These methods allow the wallpaper to be set and get for each monitor. The first parameter indicates the monitor by its
    // identifier (obtained with GetMonitorDevicePathAt) and the second a path to the wallpaper. If NULL is passed as the monitor
    // identifier to SetWallpaper, then that wallpaper will be set for all monitors. Passing NULL as the monitor identifier to
    // GetWallpaper will return S_OK and a valid wallpaper path if all monitors are displaying the same image, or S_FALSE and an
    // empty string if they are not (i.e., there are multiple static images on each monitor or a slideshow is running). An empty
    // wallpaper string indicates no image, or a monitor that is displaying the system color for the background.
    HRESULT SetWallpaper([in, unique] LPCWSTR monitorID, [in] LPCWSTR wallpaper);
    HRESULT GetWallpaper([in, unique] LPCWSTR monitorID, [out, string] LPWSTR *wallpaper);

    // These methods allow the monitor count and a unique identifier for each monitor to be obtained.
    // This includes monitors that are currently detached but have an image assigned to them; such a monitor
    // would display its assigned image when it is reattached. Use GetMonitorRECT to distinguish between
    // attached and detached monitors.
    // Note that these methods wrap existing CCD library functionality.
    HRESULT GetMonitorDevicePathAt([in] UINT monitorIndex, [out, string] LPWSTR *monitorID);
    HRESULT GetMonitorDevicePathCount([out] UINT *count);

    // This method allows the display rectangle of the specified monitor to be obtained, in screen coordinates. If the monitor
    // is not currently attached, it will return S_FALSE and an empty RECT. Checking for S_FALSE is a valid way to determine
    // which monitors are currently attached to the system.
    HRESULT GetMonitorRECT([in] LPCWSTR monitorID, [out] RECT *displayRect);

    // These are callthroughs to SetSysColor(COLOR_BACKGROUND) and GetSysColor(COLOR_BACKGROUND).
    // This is the color that is visible on the desktop when no image is currently displayed or when the
    // Enable method is used to disable the background. The color will also be visible when the wallpaper does not
    // fill the entire monitor (e.g., often when the wallpaper position is Fit or Center).
    HRESULT SetBackgroundColor([in] COLORREF color);
    HRESULT GetBackgroundColor([out] COLORREF *color);

    // These methods allow the wallpaper position to be set and get, as indicated by the DESKTOP_WALLPAPER_POSITION enumeration.
    HRESULT SetPosition([in] DESKTOP_WALLPAPER_POSITION position);
    HRESULT GetPosition([out] DESKTOP_WALLPAPER_POSITION *position);

    // These methods are used to set and get the items that will be displayed in a slideshow. When setting the slideshow,
    // the IShellItemArray can specify either a set of items that are all part of the same container or a single item that
    // is itself a container; any other IShellItemArray will cause SetSlideshow to fail.
    HRESULT SetSlideshow([in] IShellItemArray *items);
    HRESULT GetSlideshow([out] IShellItemArray **items);

    // These methods are used to set and get the slideshow options that are part of the DESKTOP_SLIDESHOW_OPTIONS
    // enumeration, as well as the slideshow "tick" (the interval between slideshow background image transitions), in milliseconds.
    HRESULT SetSlideshowOptions([in] DESKTOP_SLIDESHOW_OPTIONS options, [in] UINT slideshowTick);
    HRESULT GetSlideshowOptions([out] DESKTOP_SLIDESHOW_OPTIONS *options, [out] UINT *slideshowTick);

    // Call this method to advance the slideshow. The first parameter indicates the monitor to change; when NULL, it advances the
    // monitor that would be expected to change on the next tick of the slideshow. The second parameter uses the
    // DESKTOP_SLIDESHOW_DIRECTION enumeration to indicate whether to advance the slideshow forward or backward.
    HRESULT AdvanceSlideshow([in, unique] LPCWSTR monitorID, [in] DESKTOP_SLIDESHOW_DIRECTION direction);

    // This method returns the current status of the slideshow, as indicated by the
    // DESKTOP_SLIDESHOW_STATE enumeration.
    HRESULT GetStatus([out] DESKTOP_SLIDESHOW_STATE *state);

    // This method allows the desktop background to be enabled or disabled, depending on the
    // value of the argument. This is primarily intended for situations such as terminal server
    // where it may be desirable to disable the background for performance reasons.
    // Note that a call to SetWallpaper or SetSlideshow will re-enable the background even if it
    // is disabled by this method.
    HRESULT Enable([in] BOOL enable);
}

cpp_quote("#endif // NTDDI_WIN8")

cpp_quote("#define HOMEGROUP_SECURITY_GROUP_MULTI L\"HUG\"")
cpp_quote("#define HOMEGROUP_SECURITY_GROUP L\"HomeUsers\"")

// IHomeGroup
[
    uuid(7a3bd1d9-35a9-4fb3-a467-f48cac35e2d0),
    object,
    local
]
interface IHomeGroup : IUnknown
{
    typedef [v1_enum] enum HOMEGROUPSHARINGCHOICES
    {
        HGSC_NONE             = 0x00000000,
        HGSC_MUSICLIBRARY     = 0x00000001,
        HGSC_PICTURESLIBRARY  = 0x00000002,
        HGSC_VIDEOSLIBRARY    = 0x00000004,
        HGSC_DOCUMENTSLIBRARY = 0x00000008,
        HGSC_PRINTERS         = 0x00000010,
    } HOMEGROUPSHARINGCHOICES;
    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(HOMEGROUPSHARINGCHOICES)")

    HRESULT IsMember([out] BOOL *member);
    HRESULT ShowSharingWizard([in] HWND owner, [out] HOMEGROUPSHARINGCHOICES *sharingchoices);
}

[
    helpstring("Initialize With IPropertyStore"),
    uuid(C3E12EB5-7D8D-44f8-B6DD-0E77B34D6DE4),
    object,
    pointer_default(unique)
]
interface IInitializeWithPropertyStore : IUnknown
{
    HRESULT Initialize([in] IPropertyStore *pps);
}

[
    helpstring("OpenSearch Data Source API"),
    uuid(F0EE7333-E6FC-479b-9F25-A860C234A38E),
    object,
    pointer_default(unique),
]
interface IOpenSearchSource : IUnknown
{
    HRESULT GetResults(
                [in] HWND hwnd,
                [in] LPCWSTR pszQuery,
                [in] DWORD dwStartIndex,
                [in] DWORD dwCount,
                [in] REFIID riid,
                [out, iid_is(riid)] void **ppv);  // return IStream

}

// Library API
[
    helpstring("Shell Library API"),
    uuid(11a66efa-382e-451a-9234-1e0e12ef3085),
    object,
    pointer_default(unique),
]
interface IShellLibrary : IUnknown
{
    typedef [v1_enum] enum LIBRARYFOLDERFILTER
    {
        LFF_FORCEFILESYSTEM       = 1,  // Return only file system items.
        LFF_STORAGEITEMS          = 2,  // Return any items that can be bound to an IStorage. (default)
        LFF_ALLITEMS              = 3,  // Return all items.
    } LIBRARYFOLDERFILTER;

    typedef [v1_enum] enum LIBRARYOPTIONFLAGS
    {
        LOF_DEFAULT          = 0x00000000,
        LOF_PINNEDTONAVPANE  = 0x00000001,  // Specifies that this library is pinned to the navigation pane.
        LOF_MASK_ALL         = 0x00000001,
    } LIBRARYOPTIONFLAGS;

    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(LIBRARYOPTIONFLAGS)")

    typedef [v1_enum] enum DEFAULTSAVEFOLDERTYPE
    {
        DSFT_DETECT = 1,  // Specifies the save folder for the current user depending on whether or not they are the owner of the library
        DSFT_PRIVATE,     // Specifies the private save folder for the owner of the library
        DSFT_PUBLIC,      // Specifies the public save folder for non-owners of the library
    } DEFAULTSAVEFOLDERTYPE;

    typedef [v1_enum] enum LIBRARYSAVEFLAGS
    {
        LSF_FAILIFTHERE         = 0x00000000,   // if a library with the same name exists fail to save
        LSF_OVERRIDEEXISTING    = 0x00000001,   // will override existing library with the same name if there or create a new one if not
        LSF_MAKEUNIQUENAME      = 0x00000002,   // if a library with the same name exists create a unique name by adding a number in parenthesis
    } LIBRARYSAVEFLAGS;

    cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(LIBRARYSAVEFLAGS)")

    HRESULT LoadLibraryFromItem([in] IShellItem *psiLibrary, [in] DWORD grfMode);
    HRESULT LoadLibraryFromKnownFolder([in] REFKNOWNFOLDERID kfidLibrary, [in] DWORD grfMode);

    HRESULT AddFolder([in] IShellItem *psiLocation);
    HRESULT RemoveFolder([in] IShellItem *psiLocation);

    // may return S_FALSE if some folders were omitted due to errors during enumeration
    HRESULT GetFolders(
        [in] LIBRARYFOLDERFILTER lff,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv); // returns IShellItemArray

    // returns S_FALSE if no resolution was necessary; resolved folder will not be saved until Save[InKnownFolder] or Commit is called
    HRESULT ResolveFolder(
        [in] IShellItem *psiFolderToResolve,
        [in] DWORD dwTimeout,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv); // returns IShellItem

    HRESULT GetDefaultSaveFolder(
        [in] DEFAULTSAVEFOLDERTYPE dsft,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv); // returns IShellItem

    HRESULT SetDefaultSaveFolder([in] DEFAULTSAVEFOLDERTYPE dsft, [in] IShellItem *psi);

    HRESULT GetOptions([out] LIBRARYOPTIONFLAGS *plofOptions);
    HRESULT SetOptions([in] LIBRARYOPTIONFLAGS lofMask, [in] LIBRARYOPTIONFLAGS lofOptions);

    HRESULT GetFolderType([out] FOLDERTYPEID *pftid);
    HRESULT SetFolderType([in] REFFOLDERTYPEID ftid);

    HRESULT GetIcon([out, string] LPWSTR *ppszIcon);
    HRESULT SetIcon([in, string] LPCWSTR pszIcon);

    HRESULT Commit();

    HRESULT Save(
        [in] IShellItem *psiFolderToSaveIn,
        [in, string] LPCWSTR pszLibraryName,    // name without an extension
        [in] LIBRARYSAVEFLAGS lsf,
        [out] IShellItem **ppsiSavedTo);

    HRESULT SaveInKnownFolder(
        [in] REFKNOWNFOLDERID kfidToSaveIn,
        [in, string] LPCWSTR pszLibraryName,    // name without an extension
        [in] LIBRARYSAVEFLAGS lsf,
        [out] IShellItem **ppsiSavedTo);
}

typedef [v1_enum] enum DEFAULT_FOLDER_MENU_RESTRICTIONS
{
    DFMR_DEFAULT                                = 0x0000,   // default, no restrictions
    DFMR_NO_STATIC_VERBS                        = 0x0008,   // don't use the handler for static verbs
    DFMR_STATIC_VERBS_ONLY                      = 0x0010,   // static verbs only, no dynamic IContextMenu verbs allowed
    DFMR_NO_RESOURCE_VERBS                      = 0x0020,   // don't add cut/copy/paste/link/del/rename/properties
    DFMR_OPTIN_HANDLERS_ONLY                    = 0x0040,   // only load the handlers that have registry value "ContextMenuOptIn" under HKCR\CLSID\<handler clsid>
    DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY         = 0x0080,   // only load resource verbs cut/copy/paste/link/del/rename/properties and folder verbs added by IContextMenuCB
    DFMR_USE_SPECIFIED_HANDLERS                 = 0X0100,   // this flag is specified if a handler clsid is added through SetHandlerClsid
    DFMR_USE_SPECIFIED_VERBS                    = 0X0200,   // only load handlers that support the specified verbs
    DFMR_NO_ASYNC_VERBS                         = 0x0400,   // ignore async verbs
    DFMR_NO_NATIVECPU_VERBS                     = 0x0800,   // ignore verbs that are registered for the native CPU architecture
} DEFAULT_FOLDER_MENU_RESTRICTIONS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(DEFAULT_FOLDER_MENU_RESTRICTIONS)")

[
    object,
    uuid(7690aa79-f8fc-4615-a327-36f7d18f5d91),
    pointer_default(unique),
    local,
]
interface IDefaultFolderMenuInitialize : IUnknown
{
    // Set context menu info (equivalent to struct DEFCONTEXTMENU).
    // Do not use this method to reinitialize a context menu. Use IShellExtInit::Initialize instead.
    HRESULT Initialize(
        [in] HWND hwnd,
        [in, unique, annotation("_In_opt_")] IContextMenuCB *pcmcb,         // Optional: callback object
        [in, unique, annotation("_In_opt_")] PCIDLIST_ABSOLUTE pidlFolder,  // Optional: IDList to folder of the items, computed from psf if NULL
        [in, unique, annotation("_In_opt_")] IShellFolder *psf,             // Optional: folder of the items
        [in] UINT cidl,                                                     // Count of items in apidl
        [in, unique, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,            // Items operating on, used to get IDataObject and IAssociationArray
        [in, unique, annotation("_In_opt_")] IUnknown *punkAssociation,     // Optional: IQueryAssociations, specifies where to load extensions from, computed from apidl if NULL
        [in] UINT cKeys,                                                    // Count of items in aKeys, may be zero
        [in, unique, size_is(cKeys), annotation("_In_opt_")] const HKEY *aKeys);    // Optional: specifies where to load extensions from

    // Control behavior of menu
    HRESULT SetMenuRestrictions(
        [in] DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrValues);

    HRESULT GetMenuRestrictions(
        [in] DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrMask,
        [out] DEFAULT_FOLDER_MENU_RESTRICTIONS *pdfmrValues);

    // Specify the handler to be used
    HRESULT SetHandlerClsid([in] REFCLSID rclsid);
}

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")

typedef [v1_enum] enum ACTIVATEOPTIONS
{
    AO_NONE           = 0x00000000,  // No flags set
    AO_DESIGNMODE     = 0x00000001,  // The application is being activated for design mode, and thus will not be able to
                                     // to create an immersive window. Window creation must be done by design tools which
                                     // load the necessary components by communicating with a designer-specified service on
                                     // the site chain established on the activation manager.  The splash screen normally
                                     // shown when an application is activated will also not appear.  Most activations
                                     // will not use this flag.
    AO_NOERRORUI      = 0x00000002,  // Do not show an error dialog if the app fails to activate.
    AO_NOSPLASHSCREEN = 0x00000004,  // Do not show the splash screen when activating the app.
    AO_PRELAUNCH      = 0x02000000,  // The application is being activated in Prelaunch mode.
} ACTIVATEOPTIONS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(ACTIVATEOPTIONS)")

// IApplicationActivationManger is used to activate an immersive application identified by its Application User Model Id.
//
// Developers who are interested in using the Application Activation Manager do not need to implement the following
// interface. An implementation is provided through the CoCreatable Object with CLSID_ApplicationActivationManager.
[
    object,
    uuid(2e941141-7f97-4756-ba1d-9decde894a3d),
    pointer_default(unique)
]
interface IApplicationActivationManager : IUnknown
{
    // Activates the specified immersive application for the "Launch" contract, passing the provided arguments
    // string into the application.  Callers can obtain the process Id of the application instance fulfilling this contract.
    HRESULT ActivateApplication(
        [in] LPCWSTR appUserModelId,
        [in, unique] LPCWSTR arguments,
        [in] ACTIVATEOPTIONS options,
        [out] DWORD *processId);
    HRESULT ActivateForFile(
        [in] LPCWSTR appUserModelId,
        [in] IShellItemArray *itemArray,
        [in, unique] LPCWSTR verb,
        [out] DWORD *processId);
    HRESULT ActivateForProtocol(
        [in] LPCWSTR appUserModelId,
        [in] IShellItemArray *itemArray,
        [out] DWORD *processId);
}

cpp_quote("#endif // NTDDI_WIN8")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)")

[
    uuid(a5cd92ff-29be-454c-8d04-d82879fb3f1b),
    object,
]
interface IVirtualDesktopManager : IUnknown
{
    HRESULT IsWindowOnCurrentVirtualDesktop([in] HWND topLevelWindow, [out] BOOL *onCurrentDesktop);
    HRESULT GetWindowDesktopId([in] HWND topLevelWindow, [out] GUID* desktopId);
    HRESULT MoveWindowToDesktop([in] HWND topLevelWindow, [in] REFGUID desktopId);
}

cpp_quote("#endif // NTDDI_WINTHRESHOLD")

//  NOTE - this typelib is never registered anywhere
[
    uuid(56f9f44f-f74c-4e38-99bc-9f3ebd3d696a),
    lcid(0x0000),
    version(1.0)
]
library ShellCoreObjects
{
    // CLSID_DesktopWallpaper
    [uuid(C2CF3110-460E-4fc1-B9D0-8A1C0C9CC4BD)] coclass DesktopWallpaper { interface IDesktopWallpaper; }

    // CLSID_ShellDesktop
    [ uuid(00021400-0000-0000-C000-000000000046) ] coclass ShellDesktop { interface IShellFolder2; }

    // CLSID_ShellFSFolder
    [ uuid(F3364BA0-65B9-11CE-A9BA-00AA004AE837) ] coclass ShellFSFolder { interface IShellFolder2; }

    // CLSID_NetworkPlaces
    [ uuid(208D2C60-3AEA-1069-A2D7-08002B30309D) ] coclass NetworkPlaces { interface IShellFolder2; }

    // CLSID_ShellLink
    [ uuid(00021401-0000-0000-C000-000000000046) ] coclass ShellLink { interface IShellLinkW; }

    // CLSID_DriveSizeCategorizer
    [ uuid(94357B53-CA29-4b78-83AE-E8FE7409134F) ] coclass DriveSizeCategorizer { interface ICategorizer; }

    // CLSID_DriveTypeCategorizer
    [ uuid(B0A8F3CF-4333-4bab-8873-1CCB1CADA48B) ] coclass DriveTypeCategorizer { interface ICategorizer; }

    // CLSID_FreeSpaceCategorizer
    [ uuid(B5607793-24AC-44c7-82E2-831726AA6CB7) ] coclass FreeSpaceCategorizer { interface ICategorizer; }

    // CLSID_SizeCategorizer
    [ uuid(55d7b852-f6d1-42f2-aa75-8728a1b2d264) ] coclass SizeCategorizer { interface ICategorizer; }

    // CLSID_PropertiesUI
    [ uuid(d912f8cf-0396-4915-884e-fb425d32943b) ] coclass PropertiesUI { interface IPropertyUI; }

    // CLSID_UserNotification
    [ uuid(0010890e-8789-413c-adbc-48f5b511b3af) ] coclass UserNotification { interface IUserNotification; }

    // CLSID_TaskbarList
    [ uuid(56FDF344-FD6D-11d0-958A-006097C9A090) ] coclass TaskbarList { interface ITaskbarList4; }

    // CLSID_ShellItem
    [ uuid(9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917) ] coclass ShellItem { interface IShellItem2; }

    // CLSID_NamespaceWalker
    [ uuid(72eb61e0-8672-4303-9175-f2e4c68b2e7c) ] coclass NamespaceWalker { interface INamespaceWalk; }

    // CLSID_FileOperation
    [ uuid(3ad05575-8857-4850-9277-11b85bdb8e09) ] coclass FileOperation { interface IFileOperation; }

    // CLSID_FileOpenDialog
    [ uuid(DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7) ] coclass FileOpenDialog { interface IFileOpenDialog; }

    // CLSID_FileSaveDialog
    [ uuid(C0B4E2F3-BA21-4773-8DBA-335EC946EB8B) ] coclass FileSaveDialog { interface IFileSaveDialog; }

    // CLSID_KnownFolderManager
    [ uuid(4df0c730-df9d-4ae3-9153-aa6b82e9795a) ] coclass KnownFolderManager { interface IKnownFolderManager; }

    // CLSID_SharingConfigurationManager
    [ uuid(49F371E1-8C5C-4d9c-9A3B-54A6827F513C) ] coclass SharingConfigurationManager { interface ISharingConfigurationManager; }

    // CLSID_NetworkConnections
    [ uuid(7007ACC7-3202-11D1-AAD2-00805FC1270E) ] coclass NetworkConnections { interface IShellFolder2; }

    // CLSID_ScheduledTasks
    [ uuid(D6277990-4C6A-11CF-8D87-00AA0060F5BF) ] coclass ScheduledTasks { interface IShellFolder2; }

    // CLSID_ApplicationAssociationRegistration
    [ uuid(591209c7-767b-42b2-9fba-44ee4615f2c7) ] coclass ApplicationAssociationRegistration { interface IApplicationAssociationRegistration; }

    // CLSID_SearchFolderItemFactory
    [ uuid(14010e02-bbbd-41f0-88e3-eda371216584) ] coclass SearchFolderItemFactory { interface ISearchFolderItemFactory; }

    // CLSID_OpenControlPanel
    [ uuid(06622D85-6856-4460-8DE1-A81921B41C4B) ] coclass OpenControlPanel { interface IOpenControlPanel; }

    // CLSID_MailRecipient
    [ uuid(9E56BE60-C50F-11CF-9A2C-00A0C90A90CE) ] coclass MailRecipient { interface IDropTarget; }

    // CLSID_NetworkExplorerFolder
    [ uuid(F02C1A0D-BE21-4350-88B0-7367FC96EF3C) ] coclass NetworkExplorerFolder { interface IShellFolder2; }

    // CLSID_DestinationList
    [ uuid(77f10cf0-3db5-4966-b520-b7c54fd35ed6) ] coclass DestinationList { interface ICustomDestinationList; }

    // CLSID_ApplicationDestinations
    [ uuid(86c14003-4d6b-4ef3-a7b4-0506663b2e68) ] coclass ApplicationDestinations { interface IApplicationDestinations; }

    // CLSID_ApplicationDocumentLists
    [ uuid(86bec222-30f2-47e0-9f25-60d11cd75c28) ] coclass ApplicationDocumentLists { interface IApplicationDocumentLists; }

    // CLSID_HomeGroup
    [ uuid(DE77BA04-3C92-4d11-A1A5-42352A53E0E3) ] coclass HomeGroup { interface IHomeGroup; }

    // CLSID_ShellLibrary
    [ uuid(d9b3211d-e57f-4426-aaef-30a806add397) ] coclass ShellLibrary { interface IShellLibrary; }

    // CLSID_AppStartupLink
    [ uuid(273eb5e7-88b0-4843-bfef-e2c81d43aae5) ] coclass AppStartupLink { interface IShellLinkW; }

    // CLSID_EnumerableObjectCollection
    [ uuid(2d3468c1-36a7-43b6-ac24-d3f02fd9607a) ] coclass EnumerableObjectCollection { interface IEnumObjects; }

    // CLSID_FrameworkInputPane
    [ uuid(D5120AA3-46BA-44C5-822D-CA8092C1FC72) ] coclass FrameworkInputPane { interface IFrameworkInputPane; }

    // CLSID_DefFolderMenu
    [ uuid(c63382be-7933-48d0-9ac8-85fb46be2fdd) ] coclass DefFolderMenu { interface IDefaultFolderMenuInitialize; }

    // CLSID_AppVisibility
    [ uuid(7E5FE3D9-985F-4908-91F9-EE19F9FD1514)] coclass AppVisibility { interface IAppVisibility; }

    // CLSID_AppShellVerbHandler
    [ uuid(4ED3A719-CEA8-4BD9-910D-E252F997AFC2)] coclass AppShellVerbHandler { interface IExecuteCommand; }

    // CLSID_ExecuteUnknown
    [ uuid(e44e9428-bdbc-4987-a099-40dc8fd255e7) ] coclass ExecuteUnknown { interface IExecuteCommand; }

    // CLSID_PackageDebugSettings
    [ uuid(B1AEC16F-2383-4852-B0E9-8F0B1DC66B4D)] coclass PackageDebugSettings { interface IPackageDebugSettings2; }

    // CLSID_SuspensionDependencyManager
    [ uuid(6B273FC5-61FD-4918-95A2-C3B5E9D7F581)] coclass SuspensionDependencyManager { interface ISuspensionDependencyManager; }

    // CLSID_ApplicationActivationManager
    [ uuid(45BA127D-10A8-46EA-8AB7-56EA9078943C) ] coclass ApplicationActivationManager { interface IApplicationActivationManager; }

    // CLSID_ApplicationDesignModeSettings
    [ uuid(958a6fb5-dcb2-4faf-aafd-7fb054ad1a3b) ] coclass ApplicationDesignModeSettings { interface IApplicationDesignModeSettings2; }
};

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
cpp_quote("SHSTDAPI SHGetTemporaryPropertyForItem(_In_ IShellItem *psi, _In_ REFPROPERTYKEY propkey, _Out_ PROPVARIANT *ppropvar);")
cpp_quote("SHSTDAPI SHSetTemporaryPropertyForItem(_In_ IShellItem *psi, _In_ REFPROPERTYKEY propkey, _In_ REFPROPVARIANT propvar);")
cpp_quote("#endif  // NTDDI_VISTA")

// helper APIs to simplify initializing an instance of IShellLibrary and working with file system paths
cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN7)")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

typedef [v1_enum] enum LIBRARYMANAGEDIALOGOPTIONS
{
    LMD_DEFAULT                             = 0x00000000,
    LMD_ALLOWUNINDEXABLENETWORKLOCATIONS    = 0x00000001,   // The caller of SHShowManageLibraryUI does not want to show any warning dialogs about network locations that cannot be indexed
} LIBRARYMANAGEDIALOGOPTIONS;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(LIBRARYMANAGEDIALOGOPTIONS)")

cpp_quote("STDAPI SHShowManageLibraryUI(_In_ IShellItem *psiLibrary, _In_ HWND hwndOwner, _In_opt_ LPCWSTR pszTitle, _In_opt_ LPCWSTR pszInstruction, _In_ LIBRARYMANAGEDIALOGOPTIONS lmdOptions);")
cpp_quote("STDAPI SHResolveLibrary(_In_ IShellItem *psiLibrary);")
cpp_quote("#if defined(__cplusplus) && !defined(CINTERFACE)")
cpp_quote("")
cpp_quote("// These functions properly initialize their _Outptr_ parameters to NULL, and only return NULL")
cpp_quote("// on failure, but /analyze can't presently distinguish the failure case from the success case, and")
cpp_quote("// throws warning C6387 anyway.  Thus, the warning is disabled to avoid generating noise for code")
cpp_quote("// that includes shobjidl.h and compiles with /analyze.")
cpp_quote("#pragma warning(push)")
cpp_quote("#pragma warning(disable:6387)")
cpp_quote("")
cpp_quote("__inline HRESULT SHCreateLibrary(_In_ REFIID riid, _Outptr_ void **ppv)")
cpp_quote("{")
cpp_quote("    return CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, riid, ppv);")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHLoadLibraryFromItem(_In_ IShellItem *psiLibrary, _In_ DWORD grfMode, _In_ REFIID riid, _Outptr_ void **ppv)")
cpp_quote("{")
cpp_quote("    *ppv = NULL;")
cpp_quote("    IShellLibrary *plib;")
cpp_quote("    HRESULT hr = CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&plib));")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        hr = plib->LoadLibraryFromItem(psiLibrary, grfMode);")
cpp_quote("        if (SUCCEEDED(hr))")
cpp_quote("        {")
cpp_quote("            hr = plib->QueryInterface(riid, ppv);")
cpp_quote("        }")
cpp_quote("        plib->Release();")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHLoadLibraryFromKnownFolder(_In_ REFKNOWNFOLDERID kfidLibrary, _In_ DWORD grfMode, _In_ REFIID riid, _Outptr_ void **ppv)")
cpp_quote("{")
cpp_quote("    *ppv = NULL;")
cpp_quote("    IShellLibrary *plib;")
cpp_quote("    HRESULT hr = CoCreateInstance(CLSID_ShellLibrary, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&plib));")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        hr = plib->LoadLibraryFromKnownFolder(kfidLibrary, grfMode);")
cpp_quote("        if (SUCCEEDED(hr))")
cpp_quote("        {")
cpp_quote("            hr = plib->QueryInterface(riid, ppv);")
cpp_quote("        }")
cpp_quote("        plib->Release();")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHLoadLibraryFromParsingName(_In_ PCWSTR pszParsingName, _In_ DWORD grfMode, _In_ REFIID riid, _Outptr_ void **ppv)")
cpp_quote("{")
cpp_quote("    *ppv = NULL;")
cpp_quote("    IShellItem *psiLibrary;")
cpp_quote("    HRESULT hr = SHCreateItemFromParsingName(pszParsingName, NULL, IID_PPV_ARGS(&psiLibrary));")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        hr = SHLoadLibraryFromItem(psiLibrary, grfMode, riid, ppv);")
cpp_quote("        psiLibrary->Release();")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHAddFolderPathToLibrary(_In_ IShellLibrary *plib, _In_ PCWSTR pszFolderPath)")
cpp_quote("{")
cpp_quote("    IShellItem *psiFolder;")
cpp_quote("    HRESULT hr = SHCreateItemFromParsingName(pszFolderPath, NULL, IID_PPV_ARGS(&psiFolder));")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        hr = plib->AddFolder(psiFolder);")
cpp_quote("        psiFolder->Release();")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHRemoveFolderPathFromLibrary(_In_ IShellLibrary *plib, _In_ PCWSTR pszFolderPath)")
cpp_quote("{")
cpp_quote("    PIDLIST_ABSOLUTE pidlFolder = SHSimpleIDListFromPath(pszFolderPath);")
cpp_quote("    HRESULT hr = pidlFolder ? S_OK : E_INVALIDARG;")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        IShellItem *psiFolder;")
cpp_quote("        hr = SHCreateItemFromIDList(pidlFolder, IID_PPV_ARGS(&psiFolder));")
cpp_quote("        if (SUCCEEDED(hr))")
cpp_quote("        {")
cpp_quote("            hr = plib->RemoveFolder(psiFolder);")
cpp_quote("            psiFolder->Release();")
cpp_quote("        }")
cpp_quote("        CoTaskMemFree(pidlFolder);")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("__inline HRESULT SHSaveLibraryInFolderPath(_In_ IShellLibrary *plib, _In_ PCWSTR pszFolderPath, _In_ PCWSTR pszLibraryName, _In_ LIBRARYSAVEFLAGS lsf, _Outptr_opt_ PWSTR *ppszSavedToPath)")
cpp_quote("{")
cpp_quote("    if (ppszSavedToPath)")
cpp_quote("    {")
cpp_quote("        *ppszSavedToPath = NULL;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    IShellItem *psiFolder;")
cpp_quote("    HRESULT hr = SHCreateItemFromParsingName(pszFolderPath, NULL, IID_PPV_ARGS(&psiFolder));")
cpp_quote("    if (SUCCEEDED(hr))")
cpp_quote("    {")
cpp_quote("        IShellItem *psiSavedTo;")
cpp_quote("        hr = plib->Save(psiFolder, pszLibraryName, lsf, &psiSavedTo);")
cpp_quote("        if (SUCCEEDED(hr))")
cpp_quote("        {")
cpp_quote("            if (ppszSavedToPath)")
cpp_quote("            {")
cpp_quote("                hr = psiSavedTo->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING, ppszSavedToPath);")
cpp_quote("            }")
cpp_quote("            psiSavedTo->Release();")
cpp_quote("        }")
cpp_quote("        psiFolder->Release();")
cpp_quote("    }")
cpp_quote("    return hr;")
cpp_quote("}")
cpp_quote("")
cpp_quote("#pragma warning(pop)")
cpp_quote("#endif  // __cplusplus && !CINTERFACE")
cpp_quote("#endif  // _WIN32_IE >= _WIN32_IE_IE70")
cpp_quote("#endif  // NTDDI_WIN7")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
//
//  SHAssocEnumHandlers returns an IEnumAssocHandlers object.
//
// Invoke an associated app handler
[
    uuid(92218CAB-ECAA-4335-8133-807FD234C2EE),
    object,
    pointer_default(unique),
    local
]
interface IAssocHandlerInvoker : IUnknown
{
    // Returns S_OK if selection is supported, S_FALSE if not.
    HRESULT SupportsSelection();

    HRESULT Invoke();
}

typedef [v1_enum] enum AHTYPE
{
    AHTYPE_UNDEFINED            = 0x0000,   // default
    AHTYPE_USER_APPLICATION     = 0x0008,   // user created association (e.g. "Find on this PC" via Open With)
    AHTYPE_ANY_APPLICATION      = 0x0010,   // applications found under HKCR\Applications
    AHTYPE_MACHINEDEFAULT       = 0x0020,   // association found under HKCR\.ext
    AHTYPE_PROGID               = 0x0040,   // association with a registered progId
    AHTYPE_APPLICATION          = 0x0080,   // application found under HKCR\.ext\OpenWithList
    AHTYPE_CLASS_APPLICATION    = 0X0100,
    AHTYPE_ANY_PROGID           = 0X0200,   // association with a registered progId for any (*) extension (modern apps)
} AHTYPE;

cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(AHTYPE)")

// Association handlers
//
[
    uuid(F04061AC-1659-4a3f-A954-775AA57FC083),
    object,
    pointer_default(unique),
    local
]
interface IAssocHandler : IUnknown
{
    HRESULT GetName([string, out, annotation("_Outptr_")] LPWSTR *ppsz);

    HRESULT GetUIName([string, out, annotation("_Outptr_")] LPWSTR *ppsz);

    HRESULT GetIconLocation(
        [string, out, annotation("_Outptr_")] LPWSTR *ppszPath,
        [out, annotation("_Out_")] int *pIndex);

    HRESULT IsRecommended();

    HRESULT MakeDefault([in, string, annotation("_In_")] LPCWSTR pszDescription);

    HRESULT Invoke([in, annotation("_In_")] IDataObject *pdo);

    HRESULT CreateInvoker(
        [in, annotation("_In_")] IDataObject *pdo,
        [out, annotation("_Outptr_")] IAssocHandlerInvoker **ppInvoker);
}

// Enumerate handlers
[
    uuid(973810ae-9599-4b88-9e4d-6ee98c9552da),
    object,
    pointer_default(unique),
    local
]
interface IEnumAssocHandlers : IUnknown
{
    HRESULT Next(
        [in, annotation("_In_")] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched), annotation("_Out_writes_to_(celt, *pceltFetched)")] IAssocHandler **rgelt,
        [out, annotation("_Out_opt_ _Deref_out_range_(0,celt)")] ULONG *pceltFetched);
}

typedef enum ASSOC_FILTER
{
    ASSOC_FILTER_NONE              = 0x0,
    ASSOC_FILTER_RECOMMENDED       = 0x1,
} ASSOC_FILTER;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(ASSOC_FILTER)")

cpp_quote("SHSTDAPI SHAssocEnumHandlers(_In_ PCWSTR pszExtra, _In_ ASSOC_FILTER afFilter, _Outptr_ IEnumAssocHandlers **ppEnumHandler);")
cpp_quote("#endif  // NTDDI_VISTA")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN7)")
cpp_quote("SHSTDAPI SHAssocEnumHandlersForProtocolByApplication(_In_ PCWSTR protocol, _In_ REFIID riid, _Outptr_ void **enumHandlers);")
cpp_quote("#endif  // NTDDI_WIN7")


// Sharing Platform interfaces
cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")
[
    object,
    uuid(3D25F6D6-4B2A-433c-9184-7C33AD35D001),
    pointer_default(unique)
]
interface IDataObjectProvider : IUnknown
{
    HRESULT GetDataObject([out] IDataObject **dataObject);
    [local] HRESULT SetDataObject([in, annotation("_In_")] IDataObject *dataObject);
}

[
    object,
    uuid(3A3DCD6C-3EAB-43DC-BCDE-45671CE800C8),
    pointer_default(unique)
]
interface IDataTransferManagerInterop : IUnknown
{
    HRESULT GetForWindow([in] HWND appWindow, [in] REFIID riid, [out, retval, iid_is(riid)] void **dataTransferManager);
    HRESULT ShowShareUIForWindow([in] HWND appWindow);
}

cpp_quote("#endif // NTDDI_WIN8")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")

// Application Framework developers who are interested
// in getting the position of the Input Pane (IHM) and in receiving Input Pane
// change notifications must implement the following handler interface.
[
    object,
    uuid(226C537B-1E76-4D9E-A760-33DB29922F18)
]
interface IFrameworkInputPaneHandler : IUnknown
{
    // This method is called right before the Input Pane is going to show
    // prcInputPaneScreenLocation - The screen location of the Input Pane in screen pixels
    // fEnsureFocusedElementInView - If true, the framework implementor should attempt to keep
    // the currently focused element (text box, for example) in view and unobscured by the RECT
    // specified in prcInputPaneScreenLocation
    HRESULT Showing([in] RECT *prcInputPaneScreenLocation, [in] BOOL fEnsureFocusedElementInView);

    // This is called right before the Input Pane is going to hide
    // fEnsureFocusedElementInView - If true, the framework implementor should attempt to keep
    // the currently focused element (text box, for example) in view. One thing
    // that a framework could do is move the focused element back
    // to its original location (pre-Showing())
    HRESULT Hiding([in] BOOL fEnsureFocusedElementInView);
}

// Application Framework creators can use this interface to:
// 1) Listen to Input Pane state changes
// 2) Get the current location of the Input Pane
[
    object,
    uuid(5752238B-24F0-495A-82F1-2FD593056796)
]
interface IFrameworkInputPane : IUnknown
{
    // This allows application frameworks to get callbacks on their handler
    // whenever an event triggers the Input Pane to show for the passed in ICoreWindow.
    // pWindow - This identifies the window for which the caller is interested in listening to Input Pane events.
    // Even though this is an IUnknown, it must be a pointer to an object that implements IWindow.
    // pHandler - The handler that will recieve callbacks for Input Pane Events
    // pdwCookie - A returned cookie that the application framework can later use to unregister
    HRESULT Advise([in] IUnknown *pWindow,
                   [in] IFrameworkInputPaneHandler *pHandler,
                   [out] DWORD *pdwCookie);

    // This is an alternative signature to Advise directly using an HWND as opposed to an ICoreWindow.
    HRESULT AdviseWithHWND([in] HWND hwnd,
                           [in] IFrameworkInputPaneHandler *pHandler,
                           [out] DWORD *pdwCookie);

    // This takes in an identifier returned from Advise(), and unregisters the handler
    // so that it will no longer recieve notifications
    // dwCookie - The registration cookie returned from a previous Advise() call
    HRESULT Unadvise([in] DWORD dwCookie);

    // This gets the current location of the Input Pane in screen coordinates
    // If the Input Pane is not visible this will be an empty rectangle.
    HRESULT Location([out] RECT *prcInputPaneScreenLocation);
}

cpp_quote("")
cpp_quote("#ifndef PROP_CONTRACT_DELEGATE")
cpp_quote("#define PROP_CONTRACT_DELEGATE     L\"ContractDelegate\"")
cpp_quote("#endif // PROP_CONTRACT_DELEGATE")
cpp_quote("")
cpp_quote("// For applications that use modern APIs and use a child or owned window")
cpp_quote("// that run on different threads this API must be used to indicate which")
cpp_quote("// window is the current main window. Call this API when those windows change their state.")
cpp_quote("")
cpp_quote("__inline void SetContractDelegateWindow(_In_ HWND hwndSource, _In_opt_ HWND hwndDelegate)")
cpp_quote("{")
cpp_quote("    if (hwndDelegate != NULL)")
cpp_quote("    {")
cpp_quote("        SetPropW(hwndSource, PROP_CONTRACT_DELEGATE, (HANDLE)hwndDelegate);")
cpp_quote("    }")
cpp_quote("    else")
cpp_quote("    {")
cpp_quote("        RemovePropW(hwndSource, PROP_CONTRACT_DELEGATE);")
cpp_quote("    }")
cpp_quote("}")
cpp_quote("")

cpp_quote("#endif // NTDDI_WIN8")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN8)")

typedef [v1_enum] enum MONITOR_APP_VISIBILITY
{
   MAV_UNKNOWN = 0,         // The mode for the monitor is unknown
   MAV_NO_APP_VISIBLE = 1,
   MAV_APP_VISIBLE = 2
} MONITOR_APP_VISIBILITY;

[
    object,
    uuid(6584CE6B-7D82-49C2-89C9-C6BC02BA8C38)
]
interface IAppVisibilityEvents: IUnknown
{
   HRESULT AppVisibilityOnMonitorChanged([in] HMONITOR hMonitor,
                              [in] MONITOR_APP_VISIBILITY previousMode,
                              [in] MONITOR_APP_VISIBILITY currentMode);

   HRESULT LauncherVisibilityChange([in] BOOL currentVisibleState);
}

[
    object,
    uuid(2246EA2D-CAEA-4444-A3C4-6DE827E44313)
]
interface IAppVisibility : IUnknown
{
   HRESULT GetAppVisibilityOnMonitor([in] HMONITOR hMonitor, [out] MONITOR_APP_VISIBILITY *pMode);
   HRESULT IsLauncherVisible([out] BOOL *pfVisible);
   HRESULT Advise([in] IAppVisibilityEvents*pCallback, [out] DWORD *pdwCookie);
   HRESULT Unadvise([in] DWORD dwCookie);
}

cpp_quote("#ifdef MIDL_PASS")
typedef WCHAR * PZZWSTR;
cpp_quote("#endif")

typedef [v1_enum] enum PACKAGE_EXECUTION_STATE
{
    PES_UNKNOWN    = 0,
    PES_RUNNING    = 1,
    PES_SUSPENDING = 2,
    PES_SUSPENDED  = 3,
    PES_TERMINATED = 4
} PACKAGE_EXECUTION_STATE;

[
    object,
    uuid(1BB12A62-2AD8-432B-8CCF-0C2C52AFCD5B)
]
interface IPackageExecutionStateChangeNotification : IUnknown
{
    HRESULT OnStateChanged([in, string] LPCWSTR pszPackageFullName, [in] PACKAGE_EXECUTION_STATE pesNewState);
}

[
    object,
    local,
    uuid(F27C3930-8029-4AD1-94E3-3DBA417810C1)
]
interface IPackageDebugSettings : IUnknown
{
    HRESULT EnableDebugging([in, annotation("_In_")] LPCWSTR packageFullName, [in, annotation("_In_opt_")] LPCWSTR debuggerCommandLine, [in, annotation("_In_opt_")] PZZWSTR environment);
    HRESULT DisableDebugging([in, annotation("_In_")] LPCWSTR packageFullName);

    HRESULT Suspend([in, annotation("_In_")] LPCWSTR packageFullName);
    HRESULT Resume([in, annotation("_In_")] LPCWSTR packageFullName);

    HRESULT TerminateAllProcesses([in, annotation("_In_")] LPCWSTR packageFullName);

    HRESULT SetTargetSessionId([in, annotation("_In_")] ULONG sessionId);

    HRESULT EnumerateBackgroundTasks(
        [in, annotation("_In_")] LPCWSTR packageFullName,
        [out, annotation("_Out_")] ULONG *taskCount,
        [out, size_is(,*taskCount), annotation("_Outptr_result_buffer_(*taskCount)")] LPCGUID *taskIds,
        [out, size_is(,*taskCount), annotation("_Outptr_result_buffer_(*taskCount)")] LPCWSTR **taskNames
        );

    HRESULT ActivateBackgroundTask([in, annotation("_In_")] LPCGUID taskId);

    HRESULT StartServicing([in, annotation("_In_")] LPCWSTR packageFullName);
    HRESULT StopServicing([in, annotation("_In_")] LPCWSTR packageFullName);

    HRESULT StartSessionRedirection([in, annotation("_In_")] LPCWSTR packageFullName, [in, annotation("_In_")] ULONG sessionId);
    HRESULT StopSessionRedirection([in, annotation("_In_")] LPCWSTR packageFullName);

    HRESULT GetPackageExecutionState([in, annotation("_In_")] LPCWSTR packageFullName, [out, annotation("_Out_")] PACKAGE_EXECUTION_STATE *packageExecutionState);

    HRESULT RegisterForPackageStateChanges([in, annotation("_In_")] LPCWSTR packageFullName, [in, annotation("_In_")] IPackageExecutionStateChangeNotification *pPackageExecutionStateChangeNotification, [out, annotation("_Out_")] DWORD *pdwCookie);
    HRESULT UnregisterForPackageStateChanges([in, annotation("_In_")] DWORD dwCookie);
}

[
    object,
    local,
    uuid(6E3194BB-AB82-4D22-93F5-FABDA40E7B16)
]
interface IPackageDebugSettings2 : IPackageDebugSettings
{
    HRESULT EnumerateApps(
        [in, annotation("_In_")] LPCWSTR packageFullName,
        [out, annotation("_Out_")] ULONG *appCount,
        [out, size_is(,*appCount), annotation("_Outptr_result_buffer_(*appCount)")] LPWSTR **appUserModelIds,
        [out, size_is(,*appCount), annotation("_Outptr_result_buffer_(*appCount)")] LPWSTR **appDisplayNames);
}

[
    object,
    local,
    uuid(52B83A42-2543-416A-81D9-C0DE7969C8B3)
]
interface ISuspensionDependencyManager: IUnknown
{
    HRESULT RegisterAsChild([in, annotation("_In_")] HANDLE processHandle);
    HRESULT GroupChildWithParent([in, annotation("_In_")] HANDLE childProcessHandle);
    HRESULT UngroupChildFromParent([in, annotation("_In_")] HANDLE childProcessHandle);
}

// These values specify the types of application host environment
typedef [v1_enum] enum AHE_TYPE
{
    AHE_DESKTOP     = 0,
    AHE_IMMERSIVE   = 1,
} AHE_TYPE;

[
    object,
    uuid(18B21AA9-E184-4FF0-9F5E-F882D03771B3)
]
interface IExecuteCommandApplicationHostEnvironment : IUnknown
{
    HRESULT GetValue([out] AHE_TYPE *pahe);
}

typedef [v1_enum] enum EC_HOST_UI_MODE
{
    ECHUIM_DESKTOP,
    ECHUIM_IMMERSIVE,
    ECHUIM_SYSTEM_LAUNCHER,
} EC_HOST_UI_MODE;

// IExecuteCommandHost is implemented by the host who invokes an ExplorerCommand based shell verb via
// ShellExecuteEx() or IContextMenu::InvokeCommand(). This interface is implemented on an object
// reachable via the site chain provided to ShellExecuteEx() or the context menu and retrieved by
// IServiceProvider::QueryService(..., SID_ExecuteCommandHost, ...).
// IExecuteCommandHost::GetUIMode is called by an ExplorerCommand based verb handler to query the host UI mode.
[
    object,
    uuid(4b6832a2-5f04-4c9d-b89d-727a15d103e7)
]
interface IExecuteCommandHost : IUnknown
{
    HRESULT GetUIMode([out] EC_HOST_UI_MODE *pUIMode);
}

cpp_quote("#define SID_ExecuteCommandHost IID_IExecuteCommandHost")

// This enum matches up exactly with the WinRT enum Windows.UI.ViewManagement.ApplicationViewState.
// Do NOT modify without updating it there as well.
typedef [v1_enum] enum APPLICATION_VIEW_STATE
{
    AVS_FULLSCREEN_LANDSCAPE = 0,
    AVS_FILLED,
    AVS_SNAPPED,
    AVS_FULLSCREEN_PORTRAIT,
} APPLICATION_VIEW_STATE;

// This enum matches up exactly with the WinRT enum Windows.UI.Input.EdgeGestureKind.
// Do NOT modify without updating it there as well.
typedef [v1_enum] enum EDGE_GESTURE_KIND
{
    EGK_TOUCH = 0,
    EGK_KEYBOARD,
    EGK_MOUSE,
} EDGE_GESTURE_KIND;

[
    object,
    uuid(2A3DEE9A-E31D-46D6-8508-BCC597DB3557)
]
interface IApplicationDesignModeSettings : IUnknown
{
    HRESULT SetNativeDisplaySize([in] SIZE nativeDisplaySizePixels);
    HRESULT SetScaleFactor([in] DEVICE_SCALE_FACTOR scaleFactor);
    HRESULT SetApplicationViewState([in] APPLICATION_VIEW_STATE viewState);
    HRESULT ComputeApplicationSize([out] SIZE *applicationSizePixels);
    HRESULT IsApplicationViewStateSupported(
        [in] APPLICATION_VIEW_STATE viewState,
        [in] SIZE nativeDisplaySizePixels,
        [in] DEVICE_SCALE_FACTOR scaleFactor,
        [out] BOOL *supported);
    HRESULT TriggerEdgeGesture([in] EDGE_GESTURE_KIND edgeGestureKind);
}

typedef [v1_enum] enum NATIVE_DISPLAY_ORIENTATION
{
    NDO_LANDSCAPE = 0,
    NDO_PORTRAIT,
} NATIVE_DISPLAY_ORIENTATION;

// This enum matches up exactly with the WinRT enum Windows.UI.ViewManagement.ApplicationViewOrientation.
// Do NOT modify without updating it there as well.
typedef [v1_enum] enum APPLICATION_VIEW_ORIENTATION
{
    AVO_LANDSCAPE = 0,
    AVO_PORTRAIT,
} APPLICATION_VIEW_ORIENTATION;

typedef [v1_enum] enum ADJACENT_DISPLAY_EDGES
{
    ADE_NONE    = 0,
    ADE_LEFT    = 0x1,
    ADE_RIGHT   = 0x2,
} ADJACENT_DISPLAY_EDGES;
cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(ADJACENT_DISPLAY_EDGES)")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINBLUE)")

typedef [v1_enum] enum APPLICATION_VIEW_MIN_WIDTH
{
    AVMW_DEFAULT    = 0,
    AVMW_320        = 1,
    AVMW_500        = 2,
} APPLICATION_VIEW_MIN_WIDTH;

[
    object,
    uuid(490514E1-675A-4D6E-A58D-E54901B4CA2F)
]

interface IApplicationDesignModeSettings2 : IApplicationDesignModeSettings
{
    HRESULT SetNativeDisplayOrientation([in] NATIVE_DISPLAY_ORIENTATION nativeDisplayOrientation);
    HRESULT SetApplicationViewOrientation([in] APPLICATION_VIEW_ORIENTATION viewOrientation);
    HRESULT SetAdjacentDisplayEdges([in] ADJACENT_DISPLAY_EDGES adjacentDisplayEdges);
    HRESULT SetIsOnLockScreen([in] BOOL isOnLockScreen);
    HRESULT SetApplicationViewMinWidth([in] APPLICATION_VIEW_MIN_WIDTH viewMinWidth);
    HRESULT GetApplicationSizeBounds([out] SIZE *minApplicationSizePixels, [out] SIZE *maxApplicationSizePixels);
    HRESULT GetApplicationViewOrientation([in] SIZE applicationSizePixels, [out] APPLICATION_VIEW_ORIENTATION *viewOrientation);
}


cpp_quote("DEFINE_GUID(SID_URLExecutionContext, 0xFB5F8EBC, 0xBBB6, 0x4D10, 0xA4, 0x61, 0x77, 0x72, 0x91, 0xA0, 0x90, 0x30);")
cpp_quote("#define STR_TAB_REUSE_IDENTIFIER   L\"Tab Reuse Identifier\"")
cpp_quote("#define STR_REFERRER_IDENTIFIER    L\"Referrer Identifier\"")

// Implemented by an immersive capable browser or any desktop application
// which uses CLSID_ApplicationActivationManager to launch a Windows Store
// application. The object which implements ILaunchTargetMonitor must be set
// on the site chain of CLSID_ApplicationActivationManager before any method
// on IApplicationActivationManager is called. The monitor specified by the
// ILaunchTargetMonitor interface tells Windows which monitor the launched
// application should be shown on.
[
    object,
    uuid(266FBC7E-490D-46ED-A96B-2274DB252003)
]
interface ILaunchTargetMonitor : IUnknown
{
    HRESULT GetMonitor([out] HMONITOR *monitor);
}

// SID_LaunchTargetMonitor: {8D547FA1-CC45-40C8-B7C1-D48C183F13F3}
// To avoid having to link in a somethinguuid.lib to get the definition, we define the SID as a __uuidof
// from a one-time structure so that the value is generated at compile time rather than resolved at link time.
cpp_quote("#define SID_LaunchTargetMonitor __uuidof((struct __declspec(uuid(\"8D547FA1-CC45-40C8-B7C1-D48C183F13F3\")) LaunchTargetMonitor*)0)")

// This enum exactly matches the WinRT enum Windows.UI.ViewManagement.ViewSizePreference.
typedef [v1_enum] enum APPLICATION_VIEW_SIZE_PREFERENCE
{
    AVSP_DEFAULT     = 0,
    AVSP_USE_LESS    = 1,
    AVSP_USE_HALF    = 2,
    AVSP_USE_MORE    = 3,
    AVSP_USE_MINIMUM = 4,
    AVSP_USE_NONE    = 5,
    AVSP_CUSTOM      = 6,
} APPLICATION_VIEW_SIZE_PREFERENCE;

// Implemented by an immersive capable browser (source app) which uses
// CLSID_ApplicationActivationManager to launch a Window Store application
// (target app). The object which implements ILaunchSourceViewSizePreference
// must be set on the site chain of CLSID_ApplicationActivationManager before
// any method on IApplicationActivationManager is called. The size preference
// information will be used by Windows in placing the source app window once
// the target app is shown on screen.
[
    object,
    uuid(E5AA01F7-1FB8-4830-8720-4E6734CBD5F3)
]
interface ILaunchSourceViewSizePreference : IUnknown
{
    HRESULT GetSourceViewToPosition([out] HWND *hwnd);
    HRESULT GetSourceViewSizePreference([out] APPLICATION_VIEW_SIZE_PREFERENCE *sourceSizeAfterLaunch);
}

// SID_LaunchSourceViewSizePreference: {80605492-67D9-414F-AF89-A1CDF1242BC1}
cpp_quote("DEFINE_GUID(SID_LaunchSourceViewSizePreference, 0x80605492, 0x67d9, 0x414f, 0xaf, 0x89, 0xa1, 0xcd, 0xf1, 0x24, 0x2b, 0xc1);")

// Implemented by an immersive capable browser and set on the site chain of
// CLSID_ApplicationActivationManager when the browser's IExecuteCommand
// handler receives the invocation and it is about to call
// IApplicationActivationManager to launch the browser itself. Windows will
// use the size preference information to decide how the browser window
// should be shown once it is launched.
[
    object,
    uuid(2F0666C6-12F7-4360-B511-A394A0553725)
]
interface ILaunchTargetViewSizePreference : IUnknown
{
    HRESULT GetTargetViewSizePreference([out] APPLICATION_VIEW_SIZE_PREFERENCE *targetSizeOnLaunch);
}

// SID_LaunchTargetViewSizePreference: {26DB2472-B7B7-406B-9702-730A4E20D3BF}
cpp_quote("DEFINE_GUID(SID_LaunchTargetViewSizePreference, 0x26db2472, 0xb7b7, 0x406b, 0x97, 0x2, 0x73, 0xa, 0x4e, 0x20, 0xd3, 0xbf);")

// Implemented by Windows. When a Windows Store app launches an immersive
// capable browser via association launch, an object implementing the
// ILaunchSourceAppUserModelId interface will be set on the site chain of
// the CoreApplication object of the browser. The browser may call
// QueryService(SID_LaunchSourceAppUserModelId, ...) on the site pointer
// to retrieve the interface from which the AppUserModelId of the app that
// launches the browser is available.
[
    object,
    uuid(989191AC-28FF-4CF0-9584-E0D078BC2396)
]
interface ILaunchSourceAppUserModelId : IUnknown
{
    HRESULT GetAppUserModelId([out, string] LPWSTR *launchingApp);
}

// SID_LaunchSourceAppUserModelId: {2CE78010-74DB-48BC-9C6A-10F372495723}
cpp_quote("DEFINE_GUID(SID_LaunchSourceAppUserModelId, 0x2ce78010, 0x74db, 0x48bc, 0x9c, 0x6a, 0x10, 0xf3, 0x72, 0x49, 0x57, 0x23);")

cpp_quote("#endif // NTDDI_WINBLUE")

// Implemented by objects the need to be provided a window, often an owner window for displaying UI.
// Used by clients of those objects to provide the window.
[
    uuid(3E68D4BD-7135-4D10-8018-9FB6D9F33FA1),
    object,
    pointer_default(unique)
]
interface IInitializeWithWindow : IUnknown
{
    HRESULT Initialize([in] HWND hwnd);
}

// Provided to the IHandlerActivationHost methods, provides information about the handler.
// May also be retrieved using IServiceProvider::QueryService(SID_HandlerInfo) on the site
// chain provided in ShellExecute and verb handler invocations.
[
    uuid(997706ef-f880-453b-8118-39e1a2d2655a),
    object,
    pointer_default(unique)
]
interface IHandlerInfo : IUnknown
{
    // Return the application display name suitable for display in UI. If not available this will
    // return the file name of the application .exe.
    HRESULT GetApplicationDisplayName([out] LPWSTR *value);
    // Return the application publisher suitable for display in UI. If not available this will fail.
    HRESULT GetApplicationPublisher([out] LPWSTR *value);
    // Return the application icon suitable for display in UI. If not available this will fail.
    HRESULT GetApplicationIconReference([out] LPWSTR *value);
}

// Used to retrieve an IHandlerInfo instance
cpp_quote("#define SID_HandlerInfo IID_IHandlerInfo")

[
    uuid(31cca04c-04d3-4ea9-90de-97b15e87a532),
    object,
    pointer_default(unique)
]
interface IHandlerInfo2 : IHandlerInfo
{
    // Get the AppId of the application that will be launched.
    HRESULT GetApplicationId([out] LPWSTR *value);
}

// Clients of shell item activation including callers of ShellExecuteEx() and
// IContextMenu::InvokeCommand() can implement IHandlerActivationHost
// to be given a chance to veto or perform some action before the activation of verb handlers.
// This interface is implemented by an object reachable through the site chain provided
// to ShellExecuteEx or the context menu handler. Applications will return this object
// in there IServiceProvider::QueryService() implementation when asked for the
// serviceId SID_SHandlerActivationHost.
//
// Handlers are identified by either a COM CLSID or the .exe file that will be passed to
// CreateProcess().
[
    uuid(35094a87-8bb1-4237-96c6-c417eebdb078),
    object,
    pointer_default(unique)
]
interface IHandlerActivationHost : IUnknown
{
    // Implementations of these methods return S_OK to enable the activation of the handler,
    // or an error code to cancel it. If the user canceled the operation
    // HRESULT_FROM_WIN32(ERROR_CANCELLED) should be returned. EXECUTE_E_LAUNCH_APPLICATION
    // can be returned to indicate that this verb implementation should be skipped and the next
    // one tried (if there is one). Generally these error codes will propagate out of the sub system activating the handlers.
    // handlerInfo implements IHandlerInfo2
    HRESULT BeforeCoCreateInstance([in] REFCLSID clsidHandler,
        [in] IShellItemArray *itemsBeingActivated, [in] IHandlerInfo *handlerInfo);
    // The applicationPath will normally be a fully qualified path to an application .exe
    // but it can also be a .dll in the case of rundll32.exe based handlers.
    HRESULT BeforeCreateProcess([in] LPCWSTR applicationPath,
        [in] LPCWSTR commandLine, [in] IHandlerInfo *handlerInfo);
}

cpp_quote("#define SID_SHandlerActivationHost IID_IHandlerActivationHost")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN10)")

// Retrieve an instance of this interface using IServierProvider::QueryService(SID_AppActivationUIInfo)
// on the site chain used in ShellExecute, verb handler invoke and Application Activation Manager.
[
    uuid(abad189d-9fa3-4278-b3ca-8ca448a88dcb),
    object,
    pointer_default(unique)
]
interface IAppActivationUIInfo : IUnknown
{
    // These methods will fail with E_NOT_SET if the values are not available.
    // The monitor that originated the activation. UI generated should go on the same monitor.
    HRESULT GetMonitor([out] HMONITOR* value);
    // Point in screen coordinates where the click or touch that originated the activation.
    HRESULT GetInvokePoint([out] POINT* value);
    // ShowWindow() values, SW_NORMAL, SW_SHOWMINIMIZED, etc.
    HRESULT GetShowCommand([out] int* value);
    // Indicates if UI should be displayed or not.
    HRESULT GetShowUI([out] BOOL* value);
    // State of shift and control keys at activation time: MK_SHIFT, MK_CONTROL.
    HRESULT GetKeyState([out] DWORD* value);
}
cpp_quote("#define SID_AppActivationUIInfo IID_IAppActivationUIInfo")

cpp_quote("#endif // NTDDI_WIN10")

cpp_quote("DEFINE_GUID(SID_ShellExecuteNamedPropertyStore, 0xeb84ada2, 0x00ff, 0x4992, 0x83, 0x24, 0xed, 0x5c, 0xe0, 0x61, 0xcb, 0x29);")

cpp_quote("#endif // NTDDI_WIN8")

// Contacts API
cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINBLUE)")

typedef [v1_enum] enum FLYOUT_PLACEMENT
{
    FP_DEFAULT = 0,
    FP_ABOVE,
    FP_BELOW,
    FP_LEFT,
    FP_RIGHT,
} FLYOUT_PLACEMENT;

[
    object,
    uuid(99eacba7-e073-43b6-a896-55afe48a0833),
    pointer_default(unique)
]
interface IContactManagerInterop : IUnknown
{
    // Default browser will use this method to launch contact card from its tab window, specified
    // by the appWindow parameter.
    HRESULT ShowContactCardForWindow(
        [in] HWND appWindow,
        // Must be a Windows::ApplicationModel::Contacts::IContact object.
        // Use IUnknown here because classic COM IDL cannot use WinRT types.
        [in] IUnknown *contact,
        [in] RECT const *selection,
        [in] FLYOUT_PLACEMENT preferredPlacement);
}

cpp_quote("#endif // NTDDI_WINBLUE")

// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier

[
    uuid(0c6c4200-c589-11d0-999a-00c04fd655e1),
    pointer_default(unique)
]
interface IShellIconOverlayIdentifier : IUnknown
{
    HRESULT IsMemberOf(
        [in, string] LPCWSTR pwszPath,
        [in] DWORD  dwAttrib);

    HRESULT GetOverlayInfo(
        [out, string, size_is(cchMax)] LPWSTR pwszIconFile,
        [in]  int   cchMax,
        [out] int   *pIndex,
        [out] DWORD *pdwFlags);

    HRESULT GetPriority(
        [out] int *pPriority);
}
cpp_quote("#define ISIOI_ICONFILE   0x00000001") // path is returned through pwszIconFile
cpp_quote("#define ISIOI_ICONINDEX  0x00000002") // icon index in pwszIconFile is returned through pIndex

cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN10_RS4)")
[
    object,
    uuid(8d7b2ba7-db05-46a8-823c-d2b6de08ee91),
    pointer_default(unique),
]
interface IBannerNotificationHandler : IUnknown
{
    typedef [v1_enum] enum BANNER_NOTIFICATION_EVENT
    {
        BNE_Rendered = 0,
        BNE_Hovered,
        BNE_Closed,      // Implicit close due to navigation
        BNE_Dismissed,   // Explicit close by user using dismiss button
        BNE_Button1Clicked,
        BNE_Button2Clicked
    } BANNER_NOTIFICATION_EVENT;

    typedef struct BANNER_NOTIFICATION
    {
        BANNER_NOTIFICATION_EVENT event;
        LPCWSTR providerIdentity;
        LPCWSTR contentId;
    } BANNER_NOTIFICATION;

    HRESULT OnBannerEvent([in] BANNER_NOTIFICATION const* notification);
}
cpp_quote("#endif // NTDDI_WIN10_RS4")

cpp_quote("#if (NTDDI_VERSION >= NTDDI_VISTA)")
[v1_enum] enum SORT_ORDER_TYPE
{
    SOT_DEFAULT             = 0,
    SOT_IGNORE_FOLDERNESS   = 1,
};

[
    object,
    uuid(6dfc60fb-f2e9-459b-beb5-288f1a7c7d54),
    pointer_default(unique),
]
interface ISortColumnArray : IUnknown
{
    HRESULT GetCount([out] UINT* columnCount);
    HRESULT GetAt([in] UINT index, [out] SORTCOLUMN* sortcolumn);
    HRESULT GetSortType([out] enum SORT_ORDER_TYPE* type);
}
cpp_quote("#endif // (NTDDI_VERSION >= NTDDI_VISTA)")

[
   object,
   uuid(75BD59AA-F23B-4963-ABA4-0B355752A91B),
   pointer_default(unique)
]
interface IPropertyKeyStore : IUnknown
{
    HRESULT GetKeyCount([out] int* keyCount);
    HRESULT GetKeyAt([in] int index, [out] PROPERTYKEY* pkey);
    HRESULT AppendKey([in] REFPROPERTYKEY key);
    HRESULT DeleteKey([in] int index);
    HRESULT IsKeyInStore([in] REFPROPERTYKEY key); // S_OK means yes, S_FALSE means no.
    HRESULT RemoveKey([in] REFPROPERTYKEY key);
}

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")

#pragma endregion

