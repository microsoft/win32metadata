//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       urlmon.idl
//
//  Contents:   async moniker interfaces
//
//  Classes:
//
//  Functions:
//
//
//----------------------------------------------------------------------------
cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("// UrlMon.h")
cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("// Copyright (c) Microsoft Corporation.  All rights reserved.")
cpp_quote("//")
cpp_quote("// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF")
cpp_quote("// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO")
cpp_quote("// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A")
cpp_quote("// PARTICULAR PURPOSE.")
cpp_quote("//=--------------------------------------------------------------------------=")
cpp_quote("")
cpp_quote("#pragma comment(lib,\"uuid.lib\")")
cpp_quote("")
cpp_quote("//---------------------------------------------------------------------------=")
cpp_quote("// URL Moniker Interfaces.")
cpp_quote("")

cpp_quote("#include <winapifamily.h>")

cpp_quote("#if _MSC_VER >= 1200")
cpp_quote("#pragma warning(push)")
cpp_quote("#ifndef _MSC_EXTENSIONS")
cpp_quote("#pragma warning(disable:4309) /* truncation of constant value */")
cpp_quote("#endif")
cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
cpp_quote("#endif")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

#ifdef UNIX
typedef unsigned long HANDLE_PTR;
#endif /* UNIX */

import "objidl.idl";
import "oleidl.idl";
import "servprov.idl";
import "msxml.idl";

interface IPersistMoniker;
interface IBindProtocol;
interface IBinding;
interface IBindStatusCallback;
interface IBindStatusCallbackEx;
interface IBindStatusCallbackMsg;
interface IAuthenticate;
interface IAuthenticateEx;
interface IWindowForBindingUI;
interface ICodeInstall;
interface IHttpNegotiate;
interface IHttpNegotiate2;
interface IHttpNegotiate3;
interface IWinInetFileStream;

cpp_quote("// Side-by-Side clsid")
cpp_quote("EXTERN_C const IID CLSID_SBS_StdURLMoniker;  ")
cpp_quote("EXTERN_C const IID CLSID_SBS_HttpProtocol;   ")
cpp_quote("EXTERN_C const IID CLSID_SBS_FtpProtocol;    ")
cpp_quote("EXTERN_C const IID CLSID_SBS_GopherProtocol; ")
cpp_quote("EXTERN_C const IID CLSID_SBS_HttpSProtocol;  ")
cpp_quote("EXTERN_C const IID CLSID_SBS_FileProtocol;   ")
cpp_quote("EXTERN_C const IID CLSID_SBS_MkProtocol;     ")
cpp_quote("EXTERN_C const IID CLSID_SBS_UrlMkBindCtx;   ")
cpp_quote("EXTERN_C const IID CLSID_SBS_SoftDistExt;  ")
cpp_quote("EXTERN_C const IID CLSID_SBS_CdlProtocol;          ")
cpp_quote("EXTERN_C const IID CLSID_SBS_ClassInstallFilter;   ")
cpp_quote("EXTERN_C const IID CLSID_SBS_InternetSecurityManager;  ")
cpp_quote("EXTERN_C const IID CLSID_SBS_InternetZoneManager;  ")
cpp_quote("// END Side-by-Side clsid")


cpp_quote("// These are for backwards compatibility with previous URLMON versions")
cpp_quote("#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION")
cpp_quote("#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE")
cpp_quote("#define BINDF_NOCOPYDATA BINDF_PULLDATA")
cpp_quote("#define INVALID_P_ROOT_SECURITY_ID ((BYTE*)-1)")

cpp_quote("#define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP")

cpp_quote("EXTERN_C const IID IID_IAsyncMoniker;    ")
cpp_quote("EXTERN_C const IID CLSID_StdURLMoniker;  ")
cpp_quote("EXTERN_C const IID CLSID_HttpProtocol;   ")
cpp_quote("EXTERN_C const IID CLSID_FtpProtocol;    ")
cpp_quote("EXTERN_C const IID CLSID_GopherProtocol; ")
cpp_quote("EXTERN_C const IID CLSID_HttpSProtocol;  ")
cpp_quote("EXTERN_C const IID CLSID_FileProtocol;   ")
cpp_quote("EXTERN_C const IID CLSID_ResProtocol;    ")
cpp_quote("EXTERN_C const IID CLSID_AboutProtocol;  ")
cpp_quote("EXTERN_C const IID CLSID_JSProtocol;  ")
cpp_quote("EXTERN_C const IID CLSID_MailtoProtocol;  ")
cpp_quote("EXTERN_C const IID CLSID_IE4_PROTOCOLS;  ")
cpp_quote("EXTERN_C const IID CLSID_MkProtocol;     ")
cpp_quote("EXTERN_C const IID CLSID_StdURLProtocol; ")
cpp_quote("EXTERN_C const IID CLSID_TBAuthProtocol; ")
cpp_quote("EXTERN_C const IID CLSID_UrlMkBindCtx;   ")
cpp_quote("EXTERN_C const IID CLSID_CdlProtocol;          ")
cpp_quote("EXTERN_C const IID CLSID_ClassInstallFilter;   ")
cpp_quote("EXTERN_C const IID IID_IAsyncBindCtx;    ")

#pragma midl_echo(" ")
#pragma midl_echo("#define SZ_URLCONTEXT           OLESTR(\"URL Context\")")
#pragma midl_echo("#define SZ_ASYNC_CALLEE         OLESTR(\"AsyncCallee\")")

#pragma midl_echo("#define MKSYS_URLMONIKER         6            ")
#pragma midl_echo("#define URL_MK_LEGACY            0            ")
#pragma midl_echo("#define URL_MK_UNIFORM           1            ")
#pragma midl_echo("#define URL_MK_NO_CANONICALIZE   2            ")
#pragma midl_echo(" ")
#pragma midl_echo("STDAPI CreateURLMoniker(_In_opt_ LPMONIKER pMkCtx, _In_ LPCWSTR szURL, _Outptr_ LPMONIKER FAR * ppmk);             ")
#pragma midl_echo("STDAPI CreateURLMonikerEx(_In_opt_ LPMONIKER pMkCtx, _In_ LPCWSTR szURL, _Outptr_ LPMONIKER FAR * ppmk, DWORD dwFlags);             ")
#pragma midl_echo("STDAPI GetClassURL(_In_ LPCWSTR szURL, _Out_ CLSID *pClsID);                                           ")
#pragma midl_echo("STDAPI CreateAsyncBindCtx(DWORD reserved, _In_ IBindStatusCallback *pBSCb,                       ")
#pragma midl_echo("                                _In_opt_ IEnumFORMATETC *pEFetc, _Outptr_ IBindCtx **ppBC);                   ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
#pragma midl_echo("STDAPI CreateURLMonikerEx2(_In_opt_ LPMONIKER pMkCtx, _In_ IUri* pUri, _Outptr_ LPMONIKER FAR * ppmk, DWORD dwFlags);             ")
cpp_quote("#endif")

#pragma midl_echo("STDAPI CreateAsyncBindCtxEx(_In_ IBindCtx *pbc, DWORD dwOptions, _In_ IBindStatusCallback *pBSCb, _In_opt_ IEnumFORMATETC *pEnum,   ")
#pragma midl_echo("                            _Outptr_ IBindCtx **ppBC, DWORD reserved);                                                     ")

#pragma midl_echo("STDAPI MkParseDisplayNameEx(_In_ IBindCtx *pbc, _In_ LPCWSTR szDisplayName, _Out_ _Out_range_(<=, _String_length_(szDisplayName)) ULONG *pchEaten,          ")
#pragma midl_echo("                                _Outptr_ LPMONIKER *ppmk);                                           ")
#pragma midl_echo("STDAPI RegisterBindStatusCallback(_In_ LPBC pBC, _In_ IBindStatusCallback *pBSCb,                     ")
#pragma midl_echo("                                _Outptr_ IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       ")
#pragma midl_echo("STDAPI RevokeBindStatusCallback(_In_ LPBC pBC, _In_ IBindStatusCallback *pBSCb);                      ")

#pragma midl_echo("STDAPI GetClassFileOrMime(_In_opt_ LPBC pBC, _In_opt_ LPCWSTR szFilename, _In_reads_bytes_opt_(cbSize) LPVOID pBuffer, DWORD cbSize, _In_opt_ LPCWSTR szMime, DWORD dwReserved, _Out_ CLSID *pclsid); ")
#pragma midl_echo("STDAPI IsValidURL(_In_opt_ LPBC pBC, _In_ LPCWSTR szURL, DWORD dwReserved);                               ")


#pragma midl_echo("STDAPI CoGetClassObjectFromURL( _In_ REFCLSID rCLASSID,")
#pragma midl_echo("            _In_ LPCWSTR szCODE, DWORD dwFileVersionMS, ")
#pragma midl_echo("            DWORD dwFileVersionLS, _In_ LPCWSTR szTYPE,")
#pragma midl_echo("            _In_ LPBINDCTX pBindCtx, DWORD dwClsContext,")
#pragma midl_echo("            _Reserved_ LPVOID pvReserved, REFIID riid, _Outptr_ LPVOID * ppv);")

#pragma midl_echo("STDAPI IEInstallScope(_Out_ LPDWORD pdwScope);")

#pragma midl_echo("STDAPI FaultInIEFeature( HWND hWnd,")
#pragma midl_echo("            _In_ uCLSSPEC *pClassSpec,")
#pragma midl_echo("            _Inout_opt_ QUERYCONTEXT *pQuery, DWORD dwFlags);                                           ")

#pragma midl_echo("STDAPI GetComponentIDFromCLSSPEC(_In_ uCLSSPEC *pClassspec,")
#pragma midl_echo("            _Outptr_ LPSTR * ppszComponentID);                                                      ")

#pragma midl_echo("// flags for FaultInIEFeature")
#pragma midl_echo("#define FIEF_FLAG_FORCE_JITUI               0x1     // force JIT ui even if")
#pragma midl_echo("                                                 // previoulsy rejected by ")
#pragma midl_echo("                                                 // user in this session or")
#pragma midl_echo("                                                 // marked as Never Ask Again")
#pragma midl_echo("#define FIEF_FLAG_PEEK                      0x2     // just peek, don't faultin")
#pragma midl_echo("#define FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK        0x4     // force JIT without checking local version")
#pragma midl_echo("#define FIEF_FLAG_RESERVED_0                0x8     // reserved")



#pragma midl_echo(" ")
#pragma midl_echo("//helper apis                                                                               ")
#pragma midl_echo("STDAPI IsAsyncMoniker(_In_ IMoniker* pmk);                                                       ")
#pragma midl_echo("STDAPI CreateURLBinding(LPCWSTR lpszUrl, _In_ IBindCtx *pbc, _Inout_ IBinding **ppBdg);")
#pragma midl_echo(" ")
#pragma midl_echo("STDAPI RegisterMediaTypes(_In_ _In_range_(>, 0) UINT ctypes, _In_reads_(ctypes) const LPCSTR* rgszTypes, _Out_writes_(ctypes) CLIPFORMAT* rgcfTypes);            ")
#pragma midl_echo("STDAPI FindMediaType(_In_ LPCSTR rgszTypes, _Out_ CLIPFORMAT* rgcfTypes);                                       ")
#pragma midl_echo("STDAPI CreateFormatEnumerator( _In_ _In_range_(>, 0) UINT cfmtetc, _In_reads_(cfmtetc) FORMATETC* rgfmtetc, _Outptr_ IEnumFORMATETC** ppenumfmtetc); ")
#pragma midl_echo("STDAPI RegisterFormatEnumerator(_In_ LPBC pBC, _In_ IEnumFORMATETC *pEFetc, DWORD reserved);          ")
#pragma midl_echo("STDAPI RevokeFormatEnumerator(_In_ LPBC pBC, _In_ IEnumFORMATETC *pEFetc);                            ")
#pragma midl_echo("STDAPI RegisterMediaTypeClass(_In_ LPBC pBC, _In_ _In_range_(>, 0) UINT ctypes, _In_reads_(ctypes) const LPCSTR* rgszTypes, _In_reads_(ctypes)  CLSID *rgclsID, DWORD reserved);    ")
#pragma midl_echo("STDAPI FindMediaTypeClass(_In_ LPBC pBC, _In_ LPCSTR szType, _Out_ CLSID *pclsID, DWORD reserved);                          ")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

#pragma region Application Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)")
#pragma midl_echo("STDAPI UrlMkSetSessionOption(DWORD dwOption, _In_reads_bytes_opt_(dwBufferLength) LPVOID pBuffer, DWORD dwBufferLength, _Reserved_ DWORD dwReserved);       ")
#pragma midl_echo("STDAPI UrlMkGetSessionOption(DWORD dwOption, _Out_writes_bytes_to_opt_(dwBufferLength,*pdwBufferLengthOut) LPVOID pBuffer, DWORD dwBufferLength, _Out_ DWORD *pdwBufferLengthOut, _Reserved_ DWORD dwReserved);       ")
cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM) */")
#pragma endregion

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")


#pragma midl_echo("STDAPI FindMimeFromData(                                                                                                                  ")
#pragma midl_echo("    _In_opt_                     LPBC    pBC,                   // bind context - can be NULL                                                 ")
#pragma midl_echo("    _In_opt_                     LPCWSTR pwzUrl,                // url - can be null                                                          ")
#pragma midl_echo("    _In_reads_bytes_opt_(cbSize) LPVOID  pBuffer,               // buffer with data to sniff - can be null (pwzUrl must be valid)             ")
#pragma midl_echo("                                 DWORD   cbSize,                // size of buffer                                                             ")
#pragma midl_echo("    _In_opt_                     LPCWSTR pwzMimeProposed,       // proposed mime if - can be null                                             ")
#pragma midl_echo("                                 DWORD   dwMimeFlags,           // will be defined                                                            ")
#pragma midl_echo("    _Outptr_                     LPWSTR  *ppwzMimeOut,          // the suggested mime                                                         ")
#pragma midl_echo("    _Reserved_                   DWORD   dwReserved);           // must be 0                                                                  ")


#pragma midl_echo("#define     FMFD_DEFAULT             0x00000000 ")
#pragma midl_echo("#define     FMFD_URLASFILENAME       0x00000001 ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
#pragma midl_echo("#define     FMFD_ENABLEMIMESNIFFING  0x00000002 ")
#pragma midl_echo("#define     FMFD_IGNOREMIMETEXTPLAIN  0x00000004 ")

cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

#pragma midl_echo("#define     FMFD_SERVERMIME   0x00000008 ")
#pragma midl_echo("#define     FMFD_RESPECTTEXTPLAIN   0x00000010 ")
#pragma midl_echo("#define     FMFD_RETURNUPDATEDIMGMIMES   0x00000020")
#pragma midl_echo("#define     FMFD_RESERVED_1   0x00000040")
#pragma midl_echo("#define     FMFD_RESERVED_2   0x00000080")

#pragma midl_echo("#define     UAS_EXACTLEGACY   0x00001000 ")
#pragma midl_echo("STDAPI ObtainUserAgentString(                           ")
#pragma midl_echo("                                         DWORD dwOption, ")
#pragma midl_echo("    _Out_writes_to_(*cbSize, *cbSize)    LPSTR pszUAOut, ")
#pragma midl_echo("    _Inout_                              DWORD *cbSize); ")

#pragma midl_echo("STDAPI CompareSecurityIds(_In_reads_(dwLen1) BYTE* pbSecurityId1, _In_ DWORD dwLen1, _In_reads_(dwLen2) BYTE* pbSecurityId2, _In_ DWORD dwLen2, _In_ DWORD dwReserved);    ")

#pragma midl_echo("STDAPI CompatFlagsFromClsid(_In_ CLSID *pclsid, _Out_ LPDWORD pdwCompatFlags, _Out_ LPDWORD pdwMiscStatusFlags);             ")

#pragma midl_echo(" ")
#pragma midl_echo("#if (NTDDI_VERSION > NTDDI_WINBLUE || (NTDDI_VERSION == NTDDI_WINBLUE && defined(WINBLUE_KBSPRING14)))")
#pragma midl_echo("// Enhanced Protected Mode (EPM) Convenience Functions")
#pragma midl_echo(" ")
#pragma midl_echo("typedef enum IEObjectType")
#pragma midl_echo("{")
#pragma midl_echo("    IE_EPM_OBJECT_EVENT,")
#pragma midl_echo("    IE_EPM_OBJECT_MUTEX,")
#pragma midl_echo("    IE_EPM_OBJECT_SEMAPHORE,")
#pragma midl_echo("    IE_EPM_OBJECT_SHARED_MEMORY,")
#pragma midl_echo("    IE_EPM_OBJECT_WAITABLE_TIMER,")
#pragma midl_echo("    IE_EPM_OBJECT_FILE,")
#pragma midl_echo("    IE_EPM_OBJECT_NAMED_PIPE,")
#pragma midl_echo("    IE_EPM_OBJECT_REGISTRY,")
#pragma midl_echo("} IEObjectType;")
#pragma midl_echo(" ")
#pragma midl_echo("STDAPI SetAccessForIEAppContainer(")
#pragma midl_echo("    _In_ HANDLE hObject,")
#pragma midl_echo("    _In_ IEObjectType ieObjectType,")
#pragma midl_echo("    _In_ DWORD dwAccessMask")
#pragma midl_echo("    );")
#pragma midl_echo("#endif")
#pragma midl_echo(" ")

#pragma midl_echo("// URLMON-specific defines for UrlMkSetSessionOption() above")
#pragma midl_echo("#define URLMON_OPTION_USERAGENT           0x10000001")
#pragma midl_echo("#define URLMON_OPTION_USERAGENT_REFRESH   0x10000002")
#pragma midl_echo("#define URLMON_OPTION_URL_ENCODING        0x10000004")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
#pragma midl_echo("#define URLMON_OPTION_USE_BINDSTRINGCREDS 0x10000008")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
#pragma midl_echo("#define URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS 0x10000010")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

#pragma region Application Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)")

#pragma midl_echo(" ")
#pragma midl_echo("#define CF_NULL                 0                                  ")
#pragma midl_echo("#define CFSTR_MIME_NULL         NULL                               ")
// 7 bit MIME Types
#pragma midl_echo("#define CFSTR_MIME_TEXT         (TEXT(\"text/plain\"))             ")
#pragma midl_echo("#define CFSTR_MIME_RICHTEXT     (TEXT(\"text/richtext\"))          ")
#pragma midl_echo("#define CFSTR_MIME_MANIFEST     (TEXT(\"text/cache-manifest\"))    ")
#pragma midl_echo("#define CFSTR_MIME_WEBVTT       (TEXT(\"text/vtt\"))               ")
#pragma midl_echo("#define CFSTR_MIME_X_BITMAP     (TEXT(\"image/x-xbitmap\"))        ")
#pragma midl_echo("#define CFSTR_MIME_POSTSCRIPT   (TEXT(\"application/postscript\")) ")
// 8 bit MIME Types
#pragma midl_echo("#define CFSTR_MIME_AIFF         (TEXT(\"audio/aiff\"))             ")
#pragma midl_echo("#define CFSTR_MIME_BASICAUDIO   (TEXT(\"audio/basic\"))            ")
#pragma midl_echo("#define CFSTR_MIME_WAV          (TEXT(\"audio/wav\"))              ")
#pragma midl_echo("#define CFSTR_MIME_X_WAV        (TEXT(\"audio/x-wav\"))            ")
#pragma midl_echo("#define CFSTR_MIME_GIF          (TEXT(\"image/gif\"))              ")
#pragma midl_echo("#define CFSTR_MIME_PJPEG        (TEXT(\"image/pjpeg\"))            ")
#pragma midl_echo("#define CFSTR_MIME_JPEG         (TEXT(\"image/jpeg\"))             ")
#pragma midl_echo("#define CFSTR_MIME_TIFF         (TEXT(\"image/tiff\"))             ")
#pragma midl_echo("#define CFSTR_MIME_JPEG_XR      (TEXT(\"image/vnd.ms-photo\"))     ")
#pragma midl_echo("#define CFSTR_MIME_PNG          (TEXT(\"image/png\"))              ")
#pragma midl_echo("#define CFSTR_MIME_DDS          (TEXT(\"image/vnd.ms-dds\"))       ")
#pragma midl_echo("#define CFSTR_MIME_X_PNG        (TEXT(\"image/x-png\"))            ")
#pragma midl_echo("#define CFSTR_MIME_X_ICON       (TEXT(\"image/x-icon\"))           ")
#pragma midl_echo("#define CFSTR_MIME_SVG_XML      (TEXT(\"image/svg+xml\"))          ")
#pragma midl_echo("#define CFSTR_MIME_BMP          (TEXT(\"image/bmp\"))              ")
#pragma midl_echo("#define CFSTR_MIME_X_EMF        (TEXT(\"image/x-emf\"))            ")
#pragma midl_echo("#define CFSTR_MIME_X_WMF        (TEXT(\"image/x-wmf\"))            ")
#pragma midl_echo("#define CFSTR_MIME_AVI          (TEXT(\"video/avi\"))              ")
#pragma midl_echo("#define CFSTR_MIME_MPEG         (TEXT(\"video/mpeg\"))             ")
#pragma midl_echo("#define CFSTR_MIME_FRACTALS     (TEXT(\"application/fractals\"))   ")
#pragma midl_echo("#define CFSTR_MIME_RAWDATA      (TEXT(\"application/octet-stream\"))")
#pragma midl_echo("#define CFSTR_MIME_RAWDATASTRM  (TEXT(\"application/octet-stream\"))")
#pragma midl_echo("#define CFSTR_MIME_PDF          (TEXT(\"application/pdf\"))        ")
#pragma midl_echo("#define CFSTR_MIME_HTA          (TEXT(\"application/hta\"))        ")
#pragma midl_echo("#define CFSTR_MIME_APP_XML      (TEXT(\"application/xml\"))  ")
#pragma midl_echo("#define CFSTR_MIME_XHTML        (TEXT(\"application/xhtml+xml\"))  ")
#pragma midl_echo("#define CFSTR_MIME_X_AIFF       (TEXT(\"audio/x-aiff\"))           ")
#pragma midl_echo("#define CFSTR_MIME_X_REALAUDIO  (TEXT(\"audio/x-pn-realaudio\"))   ")
#pragma midl_echo("#define CFSTR_MIME_XBM          (TEXT(\"image/xbm\"))              ")
#pragma midl_echo("#define CFSTR_MIME_QUICKTIME    (TEXT(\"video/quicktime\"))        ")
#pragma midl_echo("#define CFSTR_MIME_X_MSVIDEO    (TEXT(\"video/x-msvideo\"))        ")
#pragma midl_echo("#define CFSTR_MIME_X_SGI_MOVIE  (TEXT(\"video/x-sgi-movie\"))      ")
#pragma midl_echo("#define CFSTR_MIME_X_MIXED_REPLACE (TEXT(\"multipart/x-mixed-replace\")) ")

// 7 or 8 bit MIME Types
#pragma midl_echo("#define CFSTR_MIME_HTML         (TEXT(\"text/html\"))              ")
#pragma midl_echo("#define CFSTR_MIME_XML          (TEXT(\"text/xml\"))               ")
#pragma midl_echo("#define CFSTR_MIME_TTML         (TEXT(\"application/ttml+xml\"))   ")
#pragma midl_echo("#define CFSTR_MIME_TTAF         (TEXT(\"application/ttaf+xml\"))   ")
#pragma midl_echo("#define CFSTR_MIME_X_JAVASCRIPT (TEXT(\"application/x-javascript\"))")
#pragma midl_echo("#define CFSTR_MIME_TEXT_JSON    (TEXT(\"text/json\"))              ")
#pragma midl_echo("#define CFSTR_MIME_APPLICATION_JAVASCRIPT (TEXT(\"application/javascript\"))")
#pragma midl_echo(" ")

cpp_quote("// MessageId: MK_S_ASYNCHRONOUS                                              ")
cpp_quote("// MessageText: Operation is successful, but will complete asynchronously.   ")
cpp_quote("//                                                                           ")
cpp_quote("#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  ")
cpp_quote("#ifndef S_ASYNCHRONOUS                                                       ")
cpp_quote("#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               ")
cpp_quote("#endif                                                                       ")
cpp_quote("                                                                             ")
cpp_quote("#ifndef E_PENDING                                                            ")
cpp_quote("#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             ")
cpp_quote("#endif                                                                       ")
cpp_quote("                                                                             ")
cpp_quote("//                                                                           ")
cpp_quote("//                                                                           ")
cpp_quote("// WinINet and protocol specific errors are mapped to one of the following   ")
cpp_quote("// error which are returned in IBSC::OnStopBinding                           ")
cpp_quote("//                                                                           ")
cpp_quote("//                                                                           ")
cpp_quote("// Note: FACILITY C is split into ranges of 1k                               ")
cpp_quote("// C0000 - C03FF  INET_E_ (URLMON's original hresult)                        ")
cpp_quote("// C0400 - C07FF  INET_E_CLIENT_xxx                                          ")
cpp_quote("// C0800 - C0BFF  INET_E_SERVER_xxx                                          ")
cpp_quote("// C0C00 - C0FFF  INET_E_????                                                ")
cpp_quote("// C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                    ")

//
// url could not be parsed
//
cpp_quote("#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      ")
//
// InternetOpen failed - no session was established
//
cpp_quote("#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      ")
//
//  InternetConnect failed - no
//
cpp_quote("#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      ")
//
// the server or proxy was not found
//
cpp_quote("#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      ")
//
// the actual object was not found - e.g. http: 404
//
cpp_quote("#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      ")
//
//  connection was established but data can not be retrieved
//  no filename from cache invalid etc.
//
cpp_quote("#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      ")
//
//  generic download failure - connection broke
//
cpp_quote("#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      ")
//
//  to access to this object need authentication    e.g. http: 401
//
cpp_quote("#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      ")
//
// the object is not available of the required type             http: 403 no object
//
cpp_quote("#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      ")
//
// the internet connection timed out
//
cpp_quote("#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      ")
//
// the request was invalid
//
cpp_quote("#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      ")
//
// protocol is not know and no plugable protocol is registered
//
cpp_quote("#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      ")
//
// security problem encountered
//
cpp_quote("#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      ")
//
// object could not be loaded; IPersistXXX::Load failed
//
cpp_quote("#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      ")
//
// CoCreateInstance failed.
//
cpp_quote("#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      ")
//
// invalid certificate.
//
cpp_quote("#define INET_E_INVALID_CERTIFICATE       _HRESULT_TYPEDEF_(0x800C0019L)      ")
//
// Redirect failed.
//
cpp_quote("#define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)      ")
//
// Redirect to directory.
//
cpp_quote("#define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)      ")
//
// HResult range returned in OnStopBinding
//
//
// Data can not be locked
//
cpp_quote("#define INET_E_CANNOT_LOCK_REQUEST                   _HRESULT_TYPEDEF_(0x800C0016L)      ")
cpp_quote("#define INET_E_USE_EXTEND_BINDING                    _HRESULT_TYPEDEF_(0x800C0017L)      ")
cpp_quote("#define INET_E_TERMINATED_BIND                       _HRESULT_TYPEDEF_(0x800C0018L)      ")
cpp_quote("#define INET_E_RESERVED_1                            _HRESULT_TYPEDEF_(0x800C001AL)      ")
cpp_quote("#define INET_E_BLOCKED_REDIRECT_XSECURITYID          _HRESULT_TYPEDEF_(0x800C001BL)      ")
cpp_quote("#define INET_E_DOMINJECTIONVALIDATION                _HRESULT_TYPEDEF_(0x800C001CL)      ")
cpp_quote("#define INET_E_VTAB_SWITCH_FORCE_ENGINE              _HRESULT_TYPEDEF_(0x800C001DL)      ")
cpp_quote("#define INET_E_HSTS_CERTIFICATE_ERROR                _HRESULT_TYPEDEF_(0x800C001EL)      ")
cpp_quote("#define INET_E_RESERVED_2                            _HRESULT_TYPEDEF_(0x800C001FL)      ")
cpp_quote("#define INET_E_RESERVED_3                            _HRESULT_TYPEDEF_(0x800C0020L)      ")
cpp_quote("#define INET_E_RESERVED_4                            _HRESULT_TYPEDEF_(0x800C0021L)      ")
cpp_quote("#define INET_E_RESERVED_5                            _HRESULT_TYPEDEF_(0x800C0022L)      ")
cpp_quote("#define INET_E_ERROR_FIRST                           _HRESULT_TYPEDEF_(0x800C0002L)      ")

// User declined download of component
cpp_quote("#define INET_E_CODE_DOWNLOAD_DECLINED                _HRESULT_TYPEDEF_(0x800C0100L)      ")
cpp_quote("#define INET_E_RESULT_DISPATCHED                     _HRESULT_TYPEDEF_(0x800C0200L)      ")

// Exact code download version requested not found
cpp_quote("#define INET_E_CANNOT_REPLACE_SFP_FILE               _HRESULT_TYPEDEF_(0x800C0300L)      ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
// Authenticode prompt UI was not shown because the page is not in the ActiveX permissive state
cpp_quote("#define INET_E_CODE_INSTALL_SUPPRESSED               _HRESULT_TYPEDEF_(0x800C0400L)      ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

// AX installation blocked by hash policy.
cpp_quote("#define INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY   _HRESULT_TYPEDEF_(0x800C0500L)      ")

// URL download is blocked
cpp_quote("#define INET_E_DOWNLOAD_BLOCKED_BY_INPRIVATE         _HRESULT_TYPEDEF_(0x800C0501L)      ")

// AX installation blocked for Immersive mode.
cpp_quote("#define INET_E_CODE_INSTALL_BLOCKED_IMMERSIVE        _HRESULT_TYPEDEF_(0x800C0502L)      ")

// forbid framing (X-FRAME-OPTIONS: DENY)
cpp_quote("#define INET_E_FORBIDFRAMING                         _HRESULT_TYPEDEF_(0x800C0503L)      ")

// AX installation blocked for ARM
cpp_quote("#define INET_E_CODE_INSTALL_BLOCKED_ARM              _HRESULT_TYPEDEF_(0x800C0504L)      ")

// Pluggable protocol is blocked
cpp_quote("#define INET_E_BLOCKED_PLUGGABLE_PROTOCOL            _HRESULT_TYPEDEF_(0x800C0505L)      ")

// AX load blocked for EPM
cpp_quote("#define INET_E_BLOCKED_ENHANCEDPROTECTEDMODE         _HRESULT_TYPEDEF_(0x800C0506L)      ")

// AX installation blocked because of bitness
cpp_quote("#define INET_E_CODE_INSTALL_BLOCKED_BITNESS          _HRESULT_TYPEDEF_(0x800C0507L)      ")

// Download blocked by CSP
cpp_quote("#define INET_E_DOWNLOAD_BLOCKED_BY_CSP               _HRESULT_TYPEDEF_(0x800C0508L)      ")

// NOTE: Please update INET_E_ERROR_LAST if you add an error code with a higher number:
cpp_quote("#define INET_E_ERROR_LAST                INET_E_DOWNLOAD_BLOCKED_BY_CSP")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM) */")
#pragma endregion

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:  IPersistMoniker interface definition
//
//----------------------------------------------------------------------------

cpp_quote("#ifndef _LPPERSISTMONIKER_DEFINED")
cpp_quote("#define _LPPERSISTMONIKER_DEFINED")

[
        object,
        uuid(79eac9c9-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IPersistMoniker : IUnknown
{
    typedef [unique] IPersistMoniker *LPPERSISTMONIKER;

    HRESULT GetClassID(
        [out] CLSID *pClassID
        );

    HRESULT IsDirty(void);

    HRESULT Load(
        [in] BOOL fFullyAvailable,
        [in] IMoniker * pimkName,
        [in] LPBC pibc,
        [in] DWORD grfMode
        );

    HRESULT Save(
        [in] IMoniker * pimkName,
        [in] LPBC pbc,
        [in] BOOL fRemember);

    HRESULT SaveCompleted(
        [in] IMoniker * pimkName,
        [in] LPBC pibc);

    HRESULT GetCurMoniker(
        [out] IMoniker ** ppimkName);
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:  IMonikerProp interface definition
//
//----------------------------------------------------------------------------

cpp_quote("#ifndef _LPMONIKERPROP_DEFINED")
cpp_quote("#define _LPMONIKERPROP_DEFINED")

[
        object,
        uuid(a5ca5f7f-1847-4d87-9c5b-918509f7511d),
        pointer_default(unique)
]

interface IMonikerProp : IUnknown
{
    typedef [unique] IMonikerProp *LPMONIKERPROP;

    typedef enum {
        MIMETYPEPROP            = 0x00000000,
        USE_SRC_URL             = 0X00000001,
        CLASSIDPROP             = 0x00000002,
        TRUSTEDDOWNLOADPROP     = 0x00000003,
        POPUPLEVELPROP          = 0x00000004,
    } MONIKERPROPERTY;

    HRESULT PutProperty (
        [in] MONIKERPROPERTY mkp,
        [in] LPCWSTR val
    );
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:  IBindProtocol interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPBINDPROTOCOL_DEFINED")
cpp_quote("#define _LPBINDPROTOCOL_DEFINED")

[
        local,
        object,
        uuid(79eac9cd-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]


interface IBindProtocol : IUnknown
{
        typedef [unique] IBindProtocol *LPBINDPROTOCOL;

        HRESULT CreateBinding(
                [in] LPCWSTR szUrl,
                [in] IBindCtx *pbc,
                [out] IBinding ** ppb);
}

cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IBinding interface definition
//
//----------------------------------------------------------------------------

cpp_quote("#ifndef _LPBINDING_DEFINED")
cpp_quote("#define _LPBINDING_DEFINED")

[
        object,
        uuid(79eac9c0-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IBinding: IUnknown
{
        typedef [unique] IBinding *LPBINDING;

        HRESULT Abort();

        HRESULT Suspend();

        HRESULT Resume();

        HRESULT SetPriority(
                [in] LONG nPriority);

        HRESULT GetPriority(
                [out] LONG * pnPriority);

        [local]
        HRESULT GetBindResult(
                [out]       CLSID *pclsidProtocol,
                [out]       DWORD *pdwResult,
                [out, annotation("__RPC__out")]       LPOLESTR *pszResult,
                [in, out]   DWORD   *pdwReserved);

        [call_as(GetBindResult)]
        HRESULT RemoteGetBindResult(
                [out]   CLSID       *pclsidProtocol,
                [out]   DWORD       *pdwResult,
                [out]   LPOLESTR    *pszResult,
                [in]    DWORD       dwReserved);

}

cpp_quote("#endif")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

#pragma region Application Family or Games Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM | WINAPI_PARTITION_GAMES)")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IBindStatusCallback interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPBINDSTATUSCALLBACK_DEFINED")
cpp_quote("#define _LPBINDSTATUSCALLBACK_DEFINED")

[
        object,
        uuid(79eac9c1-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IBindStatusCallback: IUnknown
{
        typedef [unique] IBindStatusCallback *LPBINDSTATUSCALLBACK;

        typedef enum
        {
            BINDVERB_GET       = 0x00000000,       // default action
            BINDVERB_POST      = 0x00000001,       // post verb
            BINDVERB_PUT       = 0x00000002,       // put verb
            BINDVERB_CUSTOM    = 0x00000003,       // custom verb
            BINDVERB_RESERVED1 = 0x00000004,       // reserved
        } BINDVERB;

        typedef enum
        {
            BINDINFOF_URLENCODESTGMEDDATA   = 0x00000001,       // url encode the stgmed data
            BINDINFOF_URLENCODEDEXTRAINFO   = 0x00000002,       // url encode the extra info
        } BINDINFOF;


        // flags that describe the type of transaction that caller wants
        typedef enum
        {
             BINDF_ASYNCHRONOUS              = 0x00000001
            ,BINDF_ASYNCSTORAGE              = 0x00000002
            ,BINDF_NOPROGRESSIVERENDERING    = 0x00000004
            ,BINDF_OFFLINEOPERATION          = 0x00000008
            ,BINDF_GETNEWESTVERSION          = 0x00000010
            ,BINDF_NOWRITECACHE              = 0x00000020
            ,BINDF_NEEDFILE                  = 0x00000040
            ,BINDF_PULLDATA                  = 0x00000080
            ,BINDF_IGNORESECURITYPROBLEM     = 0x00000100
            ,BINDF_RESYNCHRONIZE             = 0x00000200
            ,BINDF_HYPERLINK                 = 0x00000400
            ,BINDF_NO_UI                     = 0x00000800
            ,BINDF_SILENTOPERATION           = 0x00001000
            ,BINDF_PRAGMA_NO_CACHE           = 0x00002000

            ,BINDF_GETCLASSOBJECT            = 0x00004000
            ,BINDF_RESERVED_1                = 0x00008000

            // bindstatus callback from client is free threaded
            ,BINDF_FREE_THREADED             = 0x00010000
            // client does not need to know excat size of data available
            // hence the read goes directly to e.g. socket
            ,BINDF_DIRECT_READ               = 0x00020000
            // is the transaction a forms submit.
            ,BINDF_FORMS_SUBMIT              = 0x00040000
            ,BINDF_GETFROMCACHE_IF_NET_FAIL  = 0x00080000
            // binding is from UrlMoniker
            ,BINDF_FROMURLMON                = 0x00100000
            ,BINDF_FWD_BACK                  = 0x00200000

            ,BINDF_PREFERDEFAULTHANDLER      = 0x00400000
            ,BINDF_ENFORCERESTRICTED         = 0x00800000

            // Note:
            // the highest byte 0x??000000 is used internally
            // see other documentation
            ,BINDF_RESERVED_2                = 0x80000000 // BINDF_IGNOREMIMECLSID
            ,BINDF_RESERVED_3                = 0x01000000 // BINDF_COMPLETEDOWNLOAD
            ,BINDF_RESERVED_4                = 0x02000000 // BINDF_XDOMAINREQUEST
            ,BINDF_RESERVED_5                = 0x04000000 // BINDF_NO_COOKIES
            ,BINDF_RESERVED_6                = 0x08000000 // BINDF_BLOCK_REDIRECTS
            ,BINDF_RESERVED_7                = 0x40000000 // BINDF_DO_REDIRECT_CORS_CHECK
            ,BINDF_RESERVED_8                = 0x20000000 // BINDF_ALLOW_STATUS_NO_CONTENT
        } BINDF;

        typedef enum
        {
             URL_ENCODING_NONE               = 0x00000000
            ,URL_ENCODING_ENABLE_UTF8        = 0x10000000
            ,URL_ENCODING_DISABLE_UTF8       = 0x20000000
        } URL_ENCODING;

        typedef struct _tagBINDINFO
        {
            ULONG       cbSize;
            LPWSTR      szExtraInfo;        // e.g. string added to the URL string [range byte]
            STGMEDIUM   stgmedData;         // e.g. put or post data
            DWORD       grfBindInfoF;       // e.g. how meddata should be treaded
            DWORD       dwBindVerb;         // e.g. put, post, ...
            LPWSTR      szCustomVerb;       // e.g. custom verb
            DWORD       cbstgmedData;       // size of data in stgmedData
            DWORD       dwOptions;          // additional option
            DWORD       dwOptionsFlags;     // options flags
            DWORD       dwCodePage;         // the code used to convert the url
            SECURITY_ATTRIBUTES securityAttributes;
            IID         iid;                // iid of pUnk
            IUnknown    *pUnk;              // pUnk - whatever
            DWORD       dwReserved;         // should be null

        } BINDINFO;

        typedef struct _REMSECURITY_ATTRIBUTES
        {
            DWORD nLength;
            DWORD lpSecurityDescriptor;
            BOOL  bInheritHandle;
        } REMSECURITY_ATTRIBUTES, *PREMSECURITY_ATTRIBUTES, *LPREMSECURITY_ATTRIBUTES;

        typedef struct _tagRemBINDINFO
        {
            ULONG       cbSize;
            LPWSTR      szExtraInfo;        // e.g. string added to the URL string [range byte]
            DWORD       grfBindInfoF;       // e.g. how meddata should be treaded
            DWORD       dwBindVerb;         // e.g. put, post, ...
            LPWSTR      szCustomVerb;       // e.g. custom verb
            DWORD       cbstgmedData;       // size of data in stgmedData
            DWORD       dwOptions;          // additional options
            DWORD       dwOptionsFlags;     // options flags
            DWORD       dwCodePage;         // the code used to convert the url
            REMSECURITY_ATTRIBUTES securityAttributes;
            IID         iid;                // iid of pUnk
            IUnknown    *pUnk;              // pUnk - whatever
            DWORD       dwReserved;         // should be null

        } RemBINDINFO;

        typedef struct tagRemFORMATETC {
            DWORD cfFormat;
            DWORD ptd;
            DWORD dwAspect;
            LONG lindex;
            DWORD tymed;
        } RemFORMATETC, *LPREMFORMATETC;

        // Options flag
        typedef enum
        {
             BINDINFO_OPTIONS_WININETFLAG        = 0x00010000

            ,BINDINFO_OPTIONS_ENABLE_UTF8        = 0x00020000
            ,BINDINFO_OPTIONS_DISABLE_UTF8       = 0x00040000
            ,BINDINFO_OPTIONS_USE_IE_ENCODING    = 0x00080000

            ,BINDINFO_OPTIONS_BINDTOOBJECT       = 0x00100000
            ,BINDINFO_OPTIONS_SECURITYOPTOUT     = 0x00200000
            ,BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN     = 0x00400000
            ,BINDINFO_OPTIONS_USEBINDSTRINGCREDS       = 0x00800000
            ,BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 0x01000000
            ,BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = 0x02000000
            // skip 0x04000000, whcih was used downlevel for a security fix
            //,BINDINFO_OPTIONS_UNPROTECTED_BINDING    = 0x04000000
            ,BINDINFO_WPC_DOWNLOADBLOCKED = 0x08000000
            ,BINDINFO_WPC_LOGGING_ENABLED = 0x10000000
            ,BINDINFO_OPTIONS_ALLOWCONNECTDATA = 0x20000000
            ,BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = 0x40000000
            ,BINDINFO_OPTIONS_SHDOCVW_NAVIGATE   = (int) 0x80000000

            // Note:
            // the lowest bytes 0x0000???? are used extended binding
        } BINDINFO_OPTIONS;



        // Data notification flags
        typedef enum
        {
             BSCF_FIRSTDATANOTIFICATION          = 0x00000001
            ,BSCF_INTERMEDIATEDATANOTIFICATION   = 0x00000002
            ,BSCF_LASTDATANOTIFICATION           = 0x00000004
            ,BSCF_DATAFULLYAVAILABLE             = 0x00000008
            ,BSCF_AVAILABLEDATASIZEUNKNOWN       = 0x00000010
            ,BSCF_SKIPDRAINDATAFORFILEURLS       = 0x00000020
            ,BSCF_64BITLENGTHDOWNLOAD            = 0x00000040
        } BSCF;

        typedef enum tagBINDSTATUS
        {
             BINDSTATUS_FINDINGRESOURCE          = 1
            ,BINDSTATUS_CONNECTING
            ,BINDSTATUS_REDIRECTING
            ,BINDSTATUS_BEGINDOWNLOADDATA
            ,BINDSTATUS_DOWNLOADINGDATA
            ,BINDSTATUS_ENDDOWNLOADDATA
            ,BINDSTATUS_BEGINDOWNLOADCOMPONENTS
            ,BINDSTATUS_INSTALLINGCOMPONENTS
            ,BINDSTATUS_ENDDOWNLOADCOMPONENTS
            ,BINDSTATUS_USINGCACHEDCOPY
            ,BINDSTATUS_SENDINGREQUEST
            ,BINDSTATUS_CLASSIDAVAILABLE
            ,BINDSTATUS_MIMETYPEAVAILABLE
            ,BINDSTATUS_CACHEFILENAMEAVAILABLE
            ,BINDSTATUS_BEGINSYNCOPERATION
            ,BINDSTATUS_ENDSYNCOPERATION
            ,BINDSTATUS_BEGINUPLOADDATA
            ,BINDSTATUS_UPLOADINGDATA
            ,BINDSTATUS_ENDUPLOADDATA
            ,BINDSTATUS_PROTOCOLCLASSID
            ,BINDSTATUS_ENCODING                   // retiredIE9: no urlmon compression/decompression
            ,BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE
            ,BINDSTATUS_CLASSINSTALLLOCATION
            ,BINDSTATUS_DECODING
            ,BINDSTATUS_LOADINGMIMEHANDLER
            ,BINDSTATUS_CONTENTDISPOSITIONATTACH
            ,BINDSTATUS_FILTERREPORTMIMETYPE
            ,BINDSTATUS_CLSIDCANINSTANTIATE
            ,BINDSTATUS_IUNKNOWNAVAILABLE
            ,BINDSTATUS_DIRECTBIND
            ,BINDSTATUS_RAWMIMETYPE
            ,BINDSTATUS_PROXYDETECTING
            ,BINDSTATUS_ACCEPTRANGES
            ,BINDSTATUS_COOKIE_SENT
            ,BINDSTATUS_COMPACT_POLICY_RECEIVED
            ,BINDSTATUS_COOKIE_SUPPRESSED
            ,BINDSTATUS_COOKIE_STATE_UNKNOWN
            ,BINDSTATUS_COOKIE_STATE_ACCEPT
            ,BINDSTATUS_COOKIE_STATE_REJECT
            ,BINDSTATUS_COOKIE_STATE_PROMPT
            ,BINDSTATUS_COOKIE_STATE_LEASH
            ,BINDSTATUS_COOKIE_STATE_DOWNGRADE
            ,BINDSTATUS_POLICY_HREF
            ,BINDSTATUS_P3P_HEADER
            ,BINDSTATUS_SESSION_COOKIE_RECEIVED
            ,BINDSTATUS_PERSISTENT_COOKIE_RECEIVED
            ,BINDSTATUS_SESSION_COOKIES_ALLOWED
            ,BINDSTATUS_CACHECONTROL
            ,BINDSTATUS_CONTENTDISPOSITIONFILENAME
            ,BINDSTATUS_MIMETEXTPLAINMISMATCH
            ,BINDSTATUS_PUBLISHERAVAILABLE
            ,BINDSTATUS_DISPLAYNAMEAVAILABLE
            ,BINDSTATUS_SSLUX_NAVBLOCKED
            ,BINDSTATUS_SERVER_MIMETYPEAVAILABLE
            ,BINDSTATUS_SNIFFED_CLASSIDAVAILABLE
            ,BINDSTATUS_64BIT_PROGRESS
            ,BINDSTATUS_LAST = BINDSTATUS_64BIT_PROGRESS // not a functional flag, used to calc public enum length
            ,BINDSTATUS_RESERVED_0
            ,BINDSTATUS_RESERVED_1
            ,BINDSTATUS_RESERVED_2
            ,BINDSTATUS_RESERVED_3
            ,BINDSTATUS_RESERVED_4
            ,BINDSTATUS_RESERVED_5
            ,BINDSTATUS_RESERVED_6
            ,BINDSTATUS_RESERVED_7
            ,BINDSTATUS_RESERVED_8
            ,BINDSTATUS_RESERVED_9
            ,BINDSTATUS_RESERVED_A
            ,BINDSTATUS_RESERVED_B
            ,BINDSTATUS_RESERVED_C
            ,BINDSTATUS_RESERVED_D
            ,BINDSTATUS_RESERVED_E
            ,BINDSTATUS_RESERVED_F
            ,BINDSTATUS_RESERVED_10
            ,BINDSTATUS_RESERVED_11
            ,BINDSTATUS_RESERVED_12
            ,BINDSTATUS_RESERVED_13
            ,BINDSTATUS_RESERVED_14
            ,BINDSTATUS_LAST_PRIVATE = BINDSTATUS_RESERVED_14
        } BINDSTATUS;

        HRESULT OnStartBinding(
                [in] DWORD dwReserved,
                [in] IBinding * pib);

        HRESULT GetPriority(
                [out] LONG * pnPriority);

        HRESULT OnLowResource(
                [in] DWORD reserved);

        HRESULT OnProgress(
                [in] ULONG ulProgress,
                [in] ULONG ulProgressMax,
                [in] ULONG ulStatusCode,
                [in, unique] LPCWSTR szStatusText);

        HRESULT OnStopBinding(
                [in] HRESULT hresult,
                [in, unique] LPCWSTR szError
                );

        [local]
        HRESULT GetBindInfo(
                [out] DWORD *grfBINDF,
                [in, out, unique] BINDINFO * pbindinfo
                );

        [call_as(GetBindInfo)]
        HRESULT RemoteGetBindInfo(
                [out] DWORD *grfBINDF,
                [in, out, unique] RemBINDINFO * pbindinfo,
                [in, out, unique] RemSTGMEDIUM* pstgmed
                );

        [local]
        HRESULT OnDataAvailable(
                [in] DWORD grfBSCF,
                [in] DWORD dwSize,
                [in] FORMATETC* pformatetc,
                [in] STGMEDIUM* pstgmed
                );

        [call_as(OnDataAvailable)]
        HRESULT RemoteOnDataAvailable(
                [in] DWORD grfBSCF,
                [in] DWORD dwSize,
                [in] RemFORMATETC *pformatetc,
                [in] RemSTGMEDIUM* pstgmed
                );

        HRESULT OnObjectAvailable(
                [in] REFIID riid,
                [in, iid_is(riid)] IUnknown* punk
                );

}
cpp_quote("#endif")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM | WINAPI_PARTITION_GAMES) */")
#pragma endregion

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IBindStatusCallbackEx interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPBINDSTATUSCALLBACKEX_DEFINED")
cpp_quote("#define _LPBINDSTATUSCALLBACKEX_DEFINED")

[
        object,
        uuid(aaa74ef9-8ee7-4659-88d9-f8c504da73cc),
        pointer_default(unique)
]

interface IBindStatusCallbackEx: IBindStatusCallback
{
        typedef [unique] IBindStatusCallbackEx *LPBINDSTATUSCALLBACKEX;

        // grfBINDF2 flags
        typedef enum
        {
            BINDF2_DISABLEBASICOVERHTTP              = 0x00000001,
            BINDF2_DISABLEAUTOCOOKIEHANDLING         = 0x00000002,
            BINDF2_READ_DATA_GREATER_THAN_4GB        = 0x00000004,
            BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 0x00000008,
            BINDF2_SETDOWNLOADMODE                   = 0x00000020,
            BINDF2_DISABLE_HTTP_REDIRECT_CACHING     = 0x00000040,
            BINDF2_KEEP_CALLBACK_MODULE_LOADED       = 0x00000080,
            BINDF2_ALLOW_PROXY_CRED_PROMPT           = 0x00000100,
            BINDF2_RESERVED_17                       = 0x00000200,
            BINDF2_RESERVED_16                       = 0x00000400,
            BINDF2_RESERVED_15                       = 0x00000800,
            BINDF2_RESERVED_14                       = 0x00001000,
            BINDF2_RESERVED_13                       = 0x00002000,
            BINDF2_RESERVED_12                       = 0x00004000,
            BINDF2_RESERVED_11                       = 0x00008000,
            BINDF2_RESERVED_10                       = 0x00010000,
            BINDF2_RESERVED_F                        = 0x00020000,
            BINDF2_RESERVED_E                        = 0x00040000,
            BINDF2_RESERVED_D                        = 0x00080000,
            BINDF2_RESERVED_C                        = 0x00100000,
            BINDF2_RESERVED_B                        = 0x00200000,
            BINDF2_RESERVED_A                        = 0x00400000,
            BINDF2_RESERVED_9                        = 0x00800000,
            BINDF2_RESERVED_8                        = 0x01000000,
            BINDF2_RESERVED_7                        = 0x02000000,
            BINDF2_RESERVED_6                        = 0x04000000,
            BINDF2_RESERVED_5                        = 0x08000000,
            BINDF2_RESERVED_4                        = 0x10000000,
            BINDF2_RESERVED_3                        = 0x20000000,
            BINDF2_RESERVED_2                        = 0x40000000,
            BINDF2_RESERVED_1                        = 0x80000000,
        } BINDF2;

        [local]
        HRESULT GetBindInfoEx(
                [out] DWORD *grfBINDF,
                [in, out, unique] BINDINFO *pbindinfo,
                [out] DWORD *grfBINDF2,
                [out] DWORD *pdwReserved
                );

        [call_as(GetBindInfoEx)]
        HRESULT RemoteGetBindInfoEx(
                [out] DWORD *grfBINDF,
                [in, out, unique] RemBINDINFO * pbindinfo,
                [in, out, unique] RemSTGMEDIUM* pstgmed,
                [out] DWORD *grfBINDF2,
                [out] DWORD *pdwReserved
                );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IAuthenticate interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPAUTHENTICATION_DEFINED")
cpp_quote("#define _LPAUTHENTICATION_DEFINED")

[
    object,
    uuid(79eac9d0-baf9-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]


interface IAuthenticate : IUnknown
{
    typedef [unique] IAuthenticate *LPAUTHENTICATION;

    HRESULT Authenticate(
                [out] HWND* phwnd,
                [out] LPWSTR *pszUsername,
                [out] LPWSTR *pszPassword
                );
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IAuthenticateEx interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPAUTHENTICATIONEX_DEFINED")
cpp_quote("#define _LPAUTHENTICATIONEX_DEFINED")

[
    object,
    uuid(2ad1edaf-d83d-48b5-9adf-03dbe19f53bd),
    pointer_default(unique)
]

interface IAuthenticateEx : IAuthenticate
{
    typedef [unique] IAuthenticateEx *LPAUTHENTICATIONEX;

    // flags that pass info about the authentication request
    typedef enum
    {
        AUTHENTICATEF_PROXY = 0x00000001,
        AUTHENTICATEF_BASIC = 0x00000002,
        AUTHENTICATEF_HTTP  = 0x00000004,

    } AUTHENTICATEF;

    typedef struct _tagAUTHENTICATEINFO
    {
        DWORD       dwFlags;
        DWORD       dwReserved;         // should be null

    } AUTHENTICATEINFO;

    HRESULT AuthenticateEx(
                [out] HWND* phwnd,
                [out] LPWSTR *pszUsername,
                [out] LPWSTR *pszPassword,
                [in]  AUTHENTICATEINFO *pauthinfo
                );
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IHttpNegotiate interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPHTTPNEGOTIATE_DEFINED")
cpp_quote("#define _LPHTTPNEGOTIATE_DEFINED")

[
    object,
    uuid(79eac9d2-baf9-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]

interface IHttpNegotiate : IUnknown
{
    typedef [unique] IHttpNegotiate *LPHTTPNEGOTIATE;

    HRESULT BeginningTransaction(
                [in]         LPCWSTR szURL,
                [in, unique] LPCWSTR szHeaders,
                [in]         DWORD dwReserved,
                [out]        LPWSTR *pszAdditionalHeaders
                );

    HRESULT OnResponse(
                [in]         DWORD dwResponseCode,
                [in, unique] LPCWSTR szResponseHeaders,
                [in, unique] LPCWSTR szRequestHeaders,
                [out]        LPWSTR *pszAdditionalRequestHeaders
                );
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IHttpNegotiate2 interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPHTTPNEGOTIATE2_DEFINED")
cpp_quote("#define _LPHTTPNEGOTIATE2_DEFINED")

[
    object,
    uuid(4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4),
    pointer_default(unique)
]

interface IHttpNegotiate2 : IHttpNegotiate
{
    typedef [unique] IHttpNegotiate2 *LPHTTPNEGOTIATE2;

    HRESULT GetRootSecurityId
    (
        [out, size_is(*pcbSecurityId)]
                BYTE*   pbSecurityId,
        [in, out]
                DWORD*  pcbSecurityId,
        [in]    DWORD_PTR dwReserved
    );
}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation.
//
//  Contents:   IHttpNegotiate3 interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPHTTPNEGOTIATE3_DEFINED")
cpp_quote("#define _LPHTTPNEGOTIATE3_DEFINED")

[
    object,
    uuid(57b6c80a-34c2-4602-bc26-66a02fc57153),
    pointer_default(unique)
]

interface IHttpNegotiate3 : IHttpNegotiate2
{
    typedef [unique] IHttpNegotiate3 *LPHTTPNEGOTIATE3;

    HRESULT GetSerializedClientCertContext
    (
        [out, size_is(, *pcbCert)]
                BYTE** ppbCert,
        [out]   DWORD* pcbCert
    );
}

cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWinInetFileStream interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETFILESTREAM_DEFINED")
cpp_quote("#define _LPWININETFILESTREAM_DEFINED")

[
    object,
    uuid(F134C4B7-B1F8-4e75-B886-74B90943BECB),
    pointer_default(unique)
]

interface IWinInetFileStream : IUnknown
{
    typedef [unique] IWinInetFileStream *LPWININETFILESTREAM;

    HRESULT SetHandleForUnlock
    (
        [in]    DWORD_PTR hWinInetLockHandle,
        [in]    DWORD_PTR dwReserved
    );

    HRESULT SetDeleteFile
    (
        [in]    DWORD_PTR dwReserved
    );
}

cpp_quote("#endif")




//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWindowForBindingUI interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWINDOWFORBINDINGUI_DEFINED")
cpp_quote("#define _LPWINDOWFORBINDINGUI_DEFINED")

[
    local,
    object,
    uuid(79eac9d5-bafa-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]

interface IWindowForBindingUI : IUnknown
{
    typedef [unique] IWindowForBindingUI *LPWINDOWFORBINDINGUI;

    HRESULT GetWindow(
                [in]  REFGUID rguidReason,
                [out] HWND* phwnd);
}

cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   ICodeDownloadClient interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPCODEINSTALL_DEFINED")
cpp_quote("#define _LPCODEINSTALL_DEFINED")

[
    local,
    object,
    uuid(79eac9d1-baf9-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]


interface ICodeInstall : IWindowForBindingUI
{
    typedef [unique] ICodeInstall *LPCODEINSTALL;

    typedef enum {
        CIP_DISK_FULL,
        CIP_ACCESS_DENIED,
        CIP_NEWER_VERSION_EXISTS,
        CIP_OLDER_VERSION_EXISTS,
        CIP_NAME_CONFLICT,
        CIP_TRUST_VERIFICATION_COMPONENT_MISSING,
        CIP_EXE_SELF_REGISTERATION_TIMEOUT,
        CIP_UNSAFE_TO_ABORT,
        CIP_NEED_REBOOT,
        CIP_NEED_REBOOT_UI_PERMISSION
    } CIP_STATUS;

    HRESULT OnCodeInstallProblem(
            [in] ULONG ulStatusCode,            // contingency status
            [in, unique] LPCWSTR szDestination,         // file that needs to be updated
            [in, unique] LPCWSTR szSource,              // new version from 'net (a temp file)
            [in] DWORD dwReserved
            );

}

cpp_quote("#endif")


cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-2005.
//
//  Contents:   IUri interface definition
//
//  The string properties returned must always be the same between calls to
//  the same object.  That is once an implementation of IUri is created it
//  cannot change its string properties.
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPUri_DEFINED")
cpp_quote("#define _LPUri_DEFINED")

#pragma region Application Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)")

[
    object,
    uuid(A39EE748-6A27-4817-A6F2-13914BEF5890),
    pointer_default(unique)
]

interface IUri : IUnknown
{
    [helpstring("Uri_PROPERTYs represent properties that an URI may contain.  "
        "The Uri_PROPERTIYs in the range Uri_PROPERTY_STRING_START to "
        "Uri_PROPERTY_STRING_LAST are string properties and the rest are DWORD "
        "properties.")]
    typedef enum
    {
        Uri_PROPERTY_ABSOLUTE_URI   = 0,
        Uri_PROPERTY_STRING_START = Uri_PROPERTY_ABSOLUTE_URI,
        Uri_PROPERTY_AUTHORITY      = 1,
        Uri_PROPERTY_DISPLAY_URI    = 2,
        Uri_PROPERTY_DOMAIN         = 3,
        Uri_PROPERTY_EXTENSION      = 4,
        Uri_PROPERTY_FRAGMENT       = 5,
        Uri_PROPERTY_HOST           = 6,
        Uri_PROPERTY_PASSWORD       = 7,
        Uri_PROPERTY_PATH           = 8,
        Uri_PROPERTY_PATH_AND_QUERY = 9,
        Uri_PROPERTY_QUERY          = 10,
        Uri_PROPERTY_RAW_URI        = 11,
        Uri_PROPERTY_SCHEME_NAME    = 12,
        Uri_PROPERTY_USER_INFO      = 13,
        Uri_PROPERTY_USER_NAME      = 14,
        Uri_PROPERTY_STRING_LAST = Uri_PROPERTY_USER_NAME,

        Uri_PROPERTY_HOST_TYPE      = 15,
        Uri_PROPERTY_DWORD_START = Uri_PROPERTY_HOST_TYPE,
        Uri_PROPERTY_PORT           = 16,
        Uri_PROPERTY_SCHEME         = 17,
        Uri_PROPERTY_ZONE           = 18,
        Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY_ZONE,
    } Uri_PROPERTY;

    [helpstring("Uri_HOST_TYPE describes in what format the host in an URI "
        "was specified.")]
    typedef enum
    {
        Uri_HOST_UNKNOWN,
        Uri_HOST_DNS,
        Uri_HOST_IPV4,
        Uri_HOST_IPV6,
        Uri_HOST_IDN,
    } Uri_HOST_TYPE;

    [helpstring("pbstrProperty is set to a new BSTR representing the string "
        "property specified by uriProp if it exists. "
        "Caller must call SysFreeString to free the new BSTR on success. "
        )]
    HRESULT GetPropertyBSTR(
        [in, range(Uri_PROPERTY_STRING_START, Uri_PROPERTY_STRING_LAST)] Uri_PROPERTY uriProp,
        [out] BSTR* pbstrProperty,
        [in] DWORD dwFlags);

    [helpstring("pcchProperty is set to the length of the string property, "
        "excluding the terminating NULL character. "
        "Call this function if you only need the property length. "
        )]
    HRESULT GetPropertyLength(
        [in, range(Uri_PROPERTY_STRING_START, Uri_PROPERTY_STRING_LAST)] Uri_PROPERTY uriProp,
        [out] DWORD* pcchProperty,
        [in] DWORD dwFlags);

    [helpstring("pdwProperty is set to the DWORD value of the specified property "
        )]
    HRESULT GetPropertyDWORD(
        [in, range(Uri_PROPERTY_DWORD_START, Uri_PROPERTY_DWORD_LAST)] Uri_PROPERTY uriProp,
        [out] DWORD* pdwProperty,
        [in] DWORD dwFlags);

    [helpstring("pfHasProperty is set TRUE if the specified property exists "
        "in the URI.")]
    HRESULT HasProperty(
        [in, range(Uri_PROPERTY_STRING_START, Uri_PROPERTY_DWORD_LAST)] Uri_PROPERTY uriProp,
        [out] BOOL* pfHasProperty);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetAbsoluteUri(
        [out] BSTR* pbstrAbsoluteUri);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetAuthority(
        [out] BSTR* pbstrAuthority);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetDisplayUri(
        [out] BSTR* pbstrDisplayString);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetDomain(
        [out] BSTR* pbstrDomain);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetExtension(
        [out] BSTR* pbstrExtension);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetFragment(
        [out] BSTR* pbstrFragment);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetHost(
        [out] BSTR* pbstrHost);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetPassword(
        [out] BSTR* pbstrPassword);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetPath(
        [out] BSTR* pbstrPath);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetPathAndQuery(
        [out] BSTR* pbstrPathAndQuery);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetQuery(
        [out] BSTR* pbstrQuery);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetRawUri(
        [out] BSTR* pbstrRawUri);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetSchemeName(
        [out] BSTR* pbstrSchemeName);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetUserInfo(
        [out] BSTR* pbstrUserInfo);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyBSTR with the respective property.")]
    HRESULT GetUserName(
        [out] BSTR* pbstrUserName);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyDWORD with the respective property.")]
    HRESULT GetHostType(
        [out] DWORD* pdwHostType);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyDWORD with the respective property.")]
    HRESULT GetPort(
        [out] DWORD* pdwPort);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyDWORD with the respective property.")]
    HRESULT GetScheme(
        [out] DWORD* pdwScheme);

    [helpstring("This function is for convenience and is the same as calling "
        "GetPropertyDWORD with the respective property.")]
    HRESULT GetZone(
        [out] DWORD* pdwZone);

    [helpstring("This function sets pdwFlags to a bitmap using the values "
        "Uri_HAS_PROPERTY.")]
    HRESULT GetProperties(
        [out] LPDWORD pdwFlags);

    [helpstring("pfEqual is set TRUE if the logical content of the URIs are "
        "the same")]
    HRESULT IsEqual(
        [in] IUri* pUri,
        [out] BOOL* pfEqual);
}

#pragma midl_echo("STDAPI CreateUri(_In_ LPCWSTR pwzURI,")
#pragma midl_echo("                 _In_ DWORD dwFlags,")
#pragma midl_echo("                 _Reserved_ DWORD_PTR dwReserved,   // must be 0")
#pragma midl_echo("                 _Outptr_ IUri** ppURI);")
#pragma midl_echo("")
#pragma midl_echo("STDAPI CreateUriWithFragment(")
#pragma midl_echo("                 _In_ LPCWSTR pwzURI,")
#pragma midl_echo("                 _In_opt_ LPCWSTR pwzFragment,        // can be NULL")
#pragma midl_echo("                 _In_ DWORD dwFlags,")
#pragma midl_echo("                 _Reserved_ DWORD_PTR dwReserved,   // must be 0")
#pragma midl_echo("                 _Outptr_ IUri** ppURI);")
#pragma midl_echo("")
cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM) */")
#pragma endregion

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
#pragma midl_echo("")
#pragma midl_echo("STDAPI CreateUriFromMultiByteString(")
#pragma midl_echo("    _In_       LPCSTR    pszANSIInputUri,")
#pragma midl_echo("               DWORD     dwEncodingFlags, // ORed set of Uri_ENCODING_ flags")
#pragma midl_echo("               DWORD     dwCodePage,")
#pragma midl_echo("               DWORD     dwCreateFlags,")
#pragma midl_echo("    _Reserved_ DWORD_PTR dwReserved,   // must be 0")
#pragma midl_echo("    _Outptr_   IUri**    ppUri);")
#pragma midl_echo("")
cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

#pragma region Application Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)")
#pragma midl_echo("")
#pragma midl_echo("//The following flags are used with IUri::GetProperties.")
#pragma midl_echo("#define Uri_HAS_ABSOLUTE_URI    (1 << Uri_PROPERTY_ABSOLUTE_URI)")
#pragma midl_echo("#define Uri_HAS_AUTHORITY       (1 << Uri_PROPERTY_AUTHORITY)")
#pragma midl_echo("#define Uri_HAS_DISPLAY_URI     (1 << Uri_PROPERTY_DISPLAY_URI)")
#pragma midl_echo("#define Uri_HAS_DOMAIN          (1 << Uri_PROPERTY_DOMAIN)")
#pragma midl_echo("#define Uri_HAS_EXTENSION       (1 << Uri_PROPERTY_EXTENSION)")
#pragma midl_echo("#define Uri_HAS_FRAGMENT        (1 << Uri_PROPERTY_FRAGMENT)")
#pragma midl_echo("#define Uri_HAS_HOST            (1 << Uri_PROPERTY_HOST)")
#pragma midl_echo("#define Uri_HAS_PASSWORD        (1 << Uri_PROPERTY_PASSWORD)")
#pragma midl_echo("#define Uri_HAS_PATH            (1 << Uri_PROPERTY_PATH)")
#pragma midl_echo("#define Uri_HAS_QUERY           (1 << Uri_PROPERTY_QUERY)")
#pragma midl_echo("#define Uri_HAS_RAW_URI         (1 << Uri_PROPERTY_RAW_URI)")
#pragma midl_echo("#define Uri_HAS_SCHEME_NAME     (1 << Uri_PROPERTY_SCHEME_NAME)")
#pragma midl_echo("#define Uri_HAS_USER_NAME       (1 << Uri_PROPERTY_USER_NAME)")
#pragma midl_echo("#define Uri_HAS_PATH_AND_QUERY  (1 << Uri_PROPERTY_PATH_AND_QUERY)")
#pragma midl_echo("#define Uri_HAS_USER_INFO       (1 << Uri_PROPERTY_USER_INFO)")
#pragma midl_echo("#define Uri_HAS_HOST_TYPE       (1 << Uri_PROPERTY_HOST_TYPE)")
#pragma midl_echo("#define Uri_HAS_PORT            (1 << Uri_PROPERTY_PORT)")
#pragma midl_echo("#define Uri_HAS_SCHEME          (1 << Uri_PROPERTY_SCHEME)")
#pragma midl_echo("#define Uri_HAS_ZONE            (1 << Uri_PROPERTY_ZONE)")
#pragma midl_echo("")
#pragma midl_echo("//The following public Uri_CREATE flags may be passed in ")
#pragma midl_echo("//through the dwFlags parameter of the CreateUri functions.")
#pragma midl_echo("//Note that ALLOW_RELATIVE and ALLOW_IMPLICIT_WILDCARD_SCHEME are mutually exclusive and may not be passed together.")
#pragma midl_echo("#define Uri_CREATE_ALLOW_RELATIVE                 0x00000001    // When the scheme is unspecified and not implicit file, assume relative.")
#pragma midl_echo("#define Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME 0x00000002    // When the scheme is unspecified and not implicit file, assume wildcard.")
#pragma midl_echo("#define Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME     0x00000004    // When the scheme is unspecified and it starts with X: or \\\\ assume its a file scheme.")
#pragma midl_echo("#define Uri_CREATE_NOFRAG                         0x00000008    // If there's a query string don't look for a fragment")
#pragma midl_echo("#define Uri_CREATE_NO_CANONICALIZE                0x00000010    // Do not canonicalize the scheme, host, authority, or path")
#pragma midl_echo("#define Uri_CREATE_CANONICALIZE                   0x00000100    // DEFAULT: Canonicalize the scheme, host, authority, and path")
#pragma midl_echo("#define Uri_CREATE_FILE_USE_DOS_PATH              0x00000020    // Use DOS path compat mode for file URI creation")
#pragma midl_echo("#define Uri_CREATE_DECODE_EXTRA_INFO              0x00000040    // Beta2 DEFAULT: Decode the contents of query and fragment, then re-encode reserved characters")
#pragma midl_echo("#define Uri_CREATE_NO_DECODE_EXTRA_INFO           0x00000080    // Beta1 DEFAULT: Neither decode nor re-encode any part of the query or fragment")
#pragma midl_echo("#define Uri_CREATE_CRACK_UNKNOWN_SCHEMES          0x00000200    // Beta2 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like heirarchical URIs")
#pragma midl_echo("#define Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES       0x00000400    // Beta1 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like opaque URIs")
#pragma midl_echo("#define Uri_CREATE_PRE_PROCESS_HTML_URI           0x00000800    // DEFAULT:  Perform pre-processing on the URI to remove control characters and whitespace as if the URI comes from the raw href value of an HTML page.")
#pragma midl_echo("#define Uri_CREATE_NO_PRE_PROCESS_HTML_URI        0x00001000    // Don't perform pre-processing to remove control characters and whitespace as appropriate.")
#pragma midl_echo("#define Uri_CREATE_IE_SETTINGS                    0x00002000    // Use IE registry settings for such things as whether or not to use IDN.")
#pragma midl_echo("#define Uri_CREATE_NO_IE_SETTINGS                 0x00004000    // DEFAULT: Don't use IE registry settings.")
#pragma midl_echo("#define Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS 0x00008000    // Don't percent-encode characters that are forbidden by the RFC.")
#pragma midl_echo("#define Uri_CREATE_NORMALIZE_INTL_CHARACTERS      0x00010000    // Percent encode all extended unicode charcters, then decode all percent encoded extended unicode characters (except those identified as dangerous)")
#pragma midl_echo("#define Uri_CREATE_CANONICALIZE_ABSOLUTE          0x00020000    // Generate a fully UTF-8 encoded value for absoluteUri")

#pragma midl_echo("//The following flags may be passed in through the dwFlags ")
#pragma midl_echo("//parameter of the IUri::GetPropertyBSTR or IUri::GetPropertyLength functions.")
#pragma midl_echo("//The following flags apply only to the property Uri_PROPERTY_DISPLAY_URI:")
#pragma midl_echo("#define Uri_DISPLAY_NO_FRAGMENT               0x00000001    // Exclude fragment from the DisplayUri, if one exists")
#pragma midl_echo("#define Uri_PUNYCODE_IDN_HOST                 0x00000002    // Show the hostname encoded as punycode inside the Host, Domain, or AbsoluteUri properties, if the Uri is IDN")
#pragma midl_echo("#define Uri_DISPLAY_IDN_HOST                  0x00000004    // Show the hostname encoded as punycode or Unicode as it would appear in the DisplayUri property. This applies to the Host, Domain, and AbsoluteUri properties.")
#pragma midl_echo("#define Uri_DISPLAY_NO_PUNYCODE               0x00000008    // Show the hostname encoded as Unicode from the DisplayUri, if the Uri is IDN")

#pragma midl_echo("// The following are Uri_ENCODING_ flags for use with the function CreateUriFromMultiByteString")
#pragma midl_echo("#define Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8  0x00000001")
#pragma midl_echo("#define Uri_ENCODING_USER_INFO_AND_PATH_IS_CP                    0x00000002")
#pragma midl_echo("#define Uri_ENCODING_HOST_IS_IDN                                 0x00000004")
#pragma midl_echo("#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8                0x00000008")
#pragma midl_echo("#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP                  0x00000010")
#pragma midl_echo("#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8  0x00000020")
#pragma midl_echo("#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP                    0x00000040")
#pragma midl_echo("#define Uri_ENCODING_RFC (Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8)")

#pragma midl_echo("")
#pragma midl_echo("//The following flags may be passed in through the dwUriBuilderFlags ")
#pragma midl_echo("//parameter of the IUriBuilder::CreateUri")
#pragma midl_echo("#define UriBuilder_USE_ORIGINAL_FLAGS             0x00000001    // Use the create flags from the underlying IUri if they are available.")
#pragma midl_echo("")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM) */")
#pragma endregion

cpp_quote("#endif")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

[
    object,
    local,
    uuid(a158a630-ed6f-45fb-b987-f68676f57752),
    pointer_default(unique)
]

interface IUriContainer : IUnknown
{
    [helpstring("GetIUri will set ppIUri to the IUri contained by the "
        "IUriContainer.  The IUri is AddRefed before being passed out.")]
    HRESULT GetIUri([out] IUri** ppIUri);
}


[
    helpstring("Interface used to create a new IUri by modifying an existing one"),
    local,
    object,
    uuid(4221B2E1-8955-46c0-BD5B-DE9897565DE7),
    pointer_default(unique)
]
interface IUriBuilder: IUnknown
{
    [helpstring("Returns a new IUri* object based on changes made to the base IUri using the same flags to create the original IUri. If no changes are made, the method may return a pointer to the original IUri (after incrementing the reference count).")]
    HRESULT CreateUriSimple(
        [in]                            DWORD       dwAllowEncodingPropertyMask,
        [in]                            DWORD_PTR   dwReserved,
        [out, annotation("_Outptr_")]   IUri      **ppIUri);

    [helpstring("Returns a new IUri* object based on changes made to the base IUri. If no changes are made, the method may return a pointer to the original IUri (after incrementing the reference count).")]
    HRESULT CreateUri(
        [in]                            DWORD       dwCreateFlags,
        [in]                            DWORD       dwAllowEncodingPropertyMask,
        [in]                            DWORD_PTR   dwReserved,
        [out, annotation("_Outptr_")]   IUri      **ppIUri);

    [helpstring("Returns a new IUri* object based on changes made to the base IUri. If no changes are made, the method may return a pointer to the original IUri (after incrementing the reference count).")]
    HRESULT CreateUriWithFlags(
        [in]                            DWORD       dwCreateFlags,
        [in]                            DWORD       dwUriBuilderFlags,
        [in]                            DWORD       dwAllowEncodingPropertyMask,
        [in]                            DWORD_PTR   dwReserved,
        [out, annotation("_Outptr_")]   IUri      **ppIUri);

    [helpstring("Gets a pointer to the original IUri* on which this IUri is based; the calling context must Release() the pointer.")]
    HRESULT GetIUri(
        [out, annotation("_Outptr_result_maybenull_")]IUri **ppIUri);

    [helpstring("Sets the IUri* held by the IUriBuilder; invalidates all properties and releases the current IUri*")]
    HRESULT SetIUri(
        [in, unique, annotation("_In_opt_")]IUri  *pIUri);

    [helpstring("Gets a pointer the Fragment property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetFragment(
        [out, annotation("_Out_")]                      DWORD   *pcchFragment,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzFragment);

    [helpstring("Gets the Host property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetHost(
        [out, annotation("_Out_")]                      DWORD   *pcchHost,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzHost);

    [helpstring("Gets the Password property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetPassword(
        [out, annotation("_Out_")]                      DWORD   *pcchPassword,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzPassword);

    [helpstring("Gets the Path property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetPath(
        [out, annotation("_Out_")]                      DWORD   *pcchPath,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzPath);

    [helpstring("Gets the Port property; returns S_FALSE if the property has not been set.")]
    HRESULT GetPort(
        [out, annotation("_Out_")]BOOL  *pfHasPort,
        [out, annotation("_Out_")]DWORD *pdwPort);

    [helpstring("Gets the Query property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetQuery(
        [out, annotation("_Out_")]                      DWORD   *pcchQuery,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzQuery);

    [helpstring("Gets the SchemeName property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetSchemeName(
        [out, annotation("_Out_")]                      DWORD   *pcchSchemeName,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzSchemeName);

    [helpstring("Gets the UserName property; returns S_FALSE if the property has not been set; the calling context must not free the returned pointer.")]
    HRESULT GetUserName(
        [out, annotation("_Out_")]                      DWORD   *pcchUserName,
        [out, annotation("_Outptr_result_maybenull_")]  LPCWSTR *ppwzUserName);

    [helpstring("Sets Fragment to pwzNewValue; invalidates AbsoluteUri, DisplayUri")]
    HRESULT SetFragment(
        [in, annotation("_In_opt_")]LPCWSTR pwzNewValue);

    [helpstring("Sets Host to pwzNewValue; invalidates Authority, AbsoluteUri, Domain; pwzNewValue must be neither empty nor NULL")]
    HRESULT SetHost(
        [in, annotation("_In_")]LPCWSTR pwzNewValue);

    [helpstring("Sets Password to pwzNewValue; invalidates Authority, AbsoluteUri")]
    HRESULT SetPassword(
        [in, annotation("_In_opt_")]LPCWSTR pwzNewValue);

    [helpstring("Sets Path to pwzNewValue; invalidates AbsoluteUri, DisplayUri, PathAndQuery; pwzNewValue must be an absolute path if non-NULL")]
    HRESULT SetPath(
        [in, annotation("_In_opt_")]LPCWSTR pwzNewValue);

    [helpstring("Sets Port to dwNewValue; invalidates AbsoluteUri, Authority, DisplayUri")]
    HRESULT SetPort(
        [in]BOOL  fHasPort,
        [in]DWORD dwNewValue);

    [helpstring("Sets Query to pwzNewValue; invalidates AbsoluteUri, DisplayUri, PathAndQuery")]
    HRESULT SetQuery(
        [in, annotation("_In_opt_")]LPCWSTR pwzNewValue);

    [helpstring("Sets SchemeName to pwzNewValue; invalidates AbsoluteUri, DisplayUri; pwzNewValue must be neither empty nor NULL")]
    HRESULT SetSchemeName(
        [in, annotation("_In_")]LPCWSTR pwzNewValue);

    [helpstring("Sets UserName to pwzNewValue; invalidates Authority, AbsoluteUri")]
    HRESULT SetUserName(
        [in, annotation("_In_opt_")]LPCWSTR pwzNewValue);

    [helpstring("Removes the properties indicated by the bits in dwPropertyMask (from constants Uri_HAS_* flags) as well as any derived properties; SchemeName may not be removed")]
    HRESULT RemoveProperties(
        [in]DWORD dwPropertyMask);

    [helpstring("Returns TRUE if the IUriBuilder has been changed from the values from the base IUri*")]
    HRESULT HasBeenModified(
        [out,annotation("_Out_")]BOOL *pfModified);
};


[
    helpstring("Interface to create an IUriBuilder appropriate to the this object"),
    local,
    object,
    uuid(E982CE48-0B96-440c-BC37-0C869B27A29E),
    pointer_default(unique)
]
interface IUriBuilderFactory: IUnknown
{
    [helpstring("Return an IUriBuilder that can operate on this object (but which points to no IUri)")]
    HRESULT CreateIUriBuilder(
        [in, annotation("_In_")]        DWORD         dwFlags,
        [in, annotation("_In_")]        DWORD_PTR     dwReserved,
        [out, annotation("_Out_")]      IUriBuilder **ppIUriBuilder);

    [helpstring("Return an IUriBuilder that can operate on this object (and holds a reference to it)")]
    HRESULT CreateInitializedIUriBuilder(
        [in, annotation("_In_")]        DWORD         dwFlags,
        [in, annotation("_In_")]        DWORD_PTR     dwReserved,
        [out, annotation("_Out_")]      IUriBuilder **ppIUriBuilder);
};


#pragma midl_echo("STDAPI CreateIUriBuilder(")
#pragma midl_echo("    _In_opt_     IUri         *pIUri,")
#pragma midl_echo("    _In_         DWORD         dwFlags,")
#pragma midl_echo("    _In_         DWORD_PTR     dwReserved,")
#pragma midl_echo("    _Outptr_     IUriBuilder **ppIUriBuilder")
#pragma midl_echo("    );")

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWinInetInfo interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETINFO_DEFINED")
cpp_quote("#define _LPWININETINFO_DEFINED")

[
    object,
    uuid(79eac9d6-bafa-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]

interface IWinInetInfo : IUnknown
{

    typedef [unique] IWinInetInfo *LPWININETINFO;

    [local]
    HRESULT QueryOption(
            [in]      DWORD  dwOption,
            [in, out, size_is(*pcbBuf)]     LPVOID pBuffer,
            [in, out] DWORD *pcbBuf);

    [call_as(QueryOption)]
    HRESULT RemoteQueryOption(
            [in]      DWORD  dwOption,
            [in, out, size_is(*pcbBuf)]     BYTE *pBuffer,
            [in, out] DWORD *pcbBuf);

}
cpp_quote("#endif")

cpp_quote("#define WININETINFO_OPTION_LOCK_HANDLE 65534")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IHttpSecurity interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPHTTPSECURITY_DEFINED")
cpp_quote("#define _LPHTTPSECURITY_DEFINED")

[
    local,
    object,
    uuid(79eac9d7-bafa-11ce-8c82-00aa004ba90b),

    pointer_default(unique)
]


interface IHttpSecurity : IWindowForBindingUI
{
    typedef [unique] IHttpSecurity *LPHTTPSECURITY;

   HRESULT OnSecurityProblem(
            [in] DWORD dwProblem);

}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWinInetHttpInfo interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETHTTPINFO_DEFINED")
cpp_quote("#define _LPWININETHTTPINFO_DEFINED")

[
    object,
    uuid(79eac9d8-bafa-11ce-8c82-00aa004ba90b),
    pointer_default(unique)
]

interface IWinInetHttpInfo : IWinInetInfo
{
    typedef [unique] IWinInetHttpInfo *LPWININETHTTPINFO;

    [local]
    HRESULT QueryInfo(
            [in]      DWORD  dwOption,
            [in, out,size_is(*pcbBuf)]     LPVOID pBuffer,
            [in, out] DWORD *pcbBuf,
            [in, out] DWORD *pdwFlags,
            [in, out] DWORD *pdwReserved
            );

    [call_as(QueryInfo)]
    HRESULT RemoteQueryInfo(
            [in]      DWORD  dwOption,
            [in,out,size_is(*pcbBuf)] BYTE *pBuffer,
            [in, out] DWORD *pcbBuf,
            [in, out] DWORD *pdwFlags,
            [in, out] DWORD *pdwReserved
            );

}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2011
//
//  Contents:   IWinInetHttpTimeouts interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETHTTPTIMEOUTS_DEFINED")
cpp_quote("#define _LPWININETHTTPTIMEOUTS_DEFINED")

[
    local,
    object,
    uuid(F286FA56-C1FD-4270-8E67-B3EB790A81E8),
    pointer_default(unique)
]
interface IWinInetHttpTimeouts : IUnknown
{
    [helpstring("Returns the specified timeouts in milleseconds to use on the request or 0 to specify default values")]
    HRESULT GetRequestTimeouts(
            [out, annotation("_Out_")] DWORD *pdwConnectTimeout,
            [out, annotation("_Out_")] DWORD *pdwSendTimeout,
            [out, annotation("_Out_")] DWORD *pdwReceiveTimeout
            );
}
cpp_quote("#endif")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWinInetCacheHints interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETCACHEHINTS_DEFINED")
cpp_quote("#define _LPWININETCACHEHINTS_DEFINED")

[
    local,
    object,
    uuid(DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD),
    pointer_default(unique)
]

interface IWinInetCacheHints : IUnknown
{
    typedef [unique] IWinInetCacheHints *LPWININETCACHEHINTS;

    HRESULT SetCacheExtension(
            [in]      LPCWSTR  pwzExt,
            [in,out,size_is(*pcbCacheFile)]    LPVOID pszCacheFile,
            [in, out]   DWORD* pcbCacheFile,
            [in, out]   DWORD* pdwWinInetError,
            [in, out]   DWORD* pdwReserved
            );
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IWinInetCacheHints interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPWININETCACHEHINTS2_DEFINED")
cpp_quote("#define _LPWININETCACHEHINTS2_DEFINED")

[
    local,
    object,
    uuid(7857AEAC-D31F-49bf-884E-DD46DF36780A),
    pointer_default(unique)
]

interface IWinInetCacheHints2 : IWinInetCacheHints
{
    typedef [unique] IWinInetCacheHints2 *LPWININETCACHEHINTS2;

    HRESULT SetCacheExtension2(
            [in]        LPCWSTR  pwzExt,
            [out, size_is(sizeof(WCHAR) * (*pcchCacheFile)),
                annotation("__RPC__out_ecount(*pcchCacheFile)")]
                WCHAR *pwzCacheFile,
            [in, out]   DWORD* pcchCacheFile,
            [out]       DWORD* pdwWinInetError,
            [out]       DWORD* pdwReserved
            );
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")


cpp_quote("#define SID_IBindHost IID_IBindHost")
cpp_quote("#define SID_SBindHost IID_IBindHost")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IBindHost definition
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _LPBINDHOST_DEFINED")
cpp_quote("#define _LPBINDHOST_DEFINED")

cpp_quote("EXTERN_C const GUID SID_BindHost;")
[
        object,
        uuid(fc4801a1-2ba9-11cf-a229-00aa003d7352),
        pointer_default(unique)
]
interface IBindHost : IUnknown
{
        typedef [unique] IBindHost *LPBINDHOST;

        HRESULT CreateMoniker(
            [in]    LPOLESTR    szName,
            [in]    IBindCtx   *pBC,
            [out]   IMoniker**  ppmk,
            [in]    DWORD       dwReserved);

        [local]
        HRESULT MonikerBindToStorage(
            [in]    IMoniker            *pMk,
            [in]    IBindCtx            *pBC,
            [in]    IBindStatusCallback *pBSC,
            [in]    REFIID              riid,
            [out]   void                **ppvObj);

        [call_as(MonikerBindToStorage)]
        HRESULT RemoteMonikerBindToStorage(
            [in, unique]    IMoniker            *pMk,
            [in, unique]    IBindCtx            *pBC,
            [in, unique]    IBindStatusCallback *pBSC,
            [in]            REFIID riid,
            [out, iid_is(riid)] IUnknown **ppvObj);

        [local]
        HRESULT MonikerBindToObject(
            [in]    IMoniker            *pMk,
            [in]    IBindCtx            *pBC,
            [in]    IBindStatusCallback *pBSC,
            [in]    REFIID              riid,
            [out]   void                **ppvObj);

        [call_as(MonikerBindToObject)]
        HRESULT RemoteMonikerBindToObject(
            [in, unique]    IMoniker            *pMk,
            [in, unique]    IBindCtx            *pBC,
            [in, unique]    IBindStatusCallback *pBSC,
            [in]            REFIID riid,
            [out, iid_is(riid)] IUnknown **ppvObj);
}

cpp_quote("#endif")

// urlhlink stuff
#pragma midl_echo("                                                                                                           ")
cpp_quote("// These are for backwards compatibility with previous URLMON versions")
#pragma midl_echo("// Flags for the UrlDownloadToCacheFile                                                                    ")
#pragma midl_echo("#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            ")
#pragma midl_echo("#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      ")
#pragma midl_echo("#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("struct IBindStatusCallback;                                                                                ")
#pragma midl_echo("STDAPI HlinkSimpleNavigateToString(                                                                        ")
#pragma midl_echo("    _In_opt_ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       ")
#pragma midl_echo("    _In_opt_ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  ")
#pragma midl_echo("    _In_opt_ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             ")
#pragma midl_echo("    _In_     IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    ")
#pragma midl_echo("    _In_opt_ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  ")
#pragma midl_echo("    _In_opt_ IBindStatusCallback *,                                                                      ")
#pragma midl_echo("    /* [in] */ DWORD grfHLNF,            // flags                                                          ")
#pragma midl_echo("    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   ")
#pragma midl_echo(");                                                                                                         ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("STDAPI HlinkSimpleNavigateToMoniker(                                                                       ")
#pragma midl_echo("    _In_opt_ IMoniker *pmkTarget,      // required - target document - (may be null                      ")
#pragma midl_echo("    _In_opt_ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  ")
#pragma midl_echo("    _In_opt_ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             ")
#pragma midl_echo("    _In_opt_ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    ")
#pragma midl_echo("    _In_opt_ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  ")
#pragma midl_echo("    _In_opt_ IBindStatusCallback *,                                                                      ")
#pragma midl_echo("    /* [in] */ DWORD grfHLNF,            // flags                                                          ")
#pragma midl_echo("    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   ")
#pragma midl_echo(");                                                                                                         ")
//#pragma midl_echo("typedef HRESULT (STDAPICALLTYPE *LPFNUOSCALLBACK)(LPBINDSTATUSCALLBACK);                                   ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("STDAPI URLOpenStreamA(_In_opt_ LPUNKNOWN, _In_ LPCSTR,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                                        ")
#pragma midl_echo("STDAPI URLOpenStreamW(_In_opt_ LPUNKNOWN, _In_ LPCWSTR,DWORD,_In_opt_ LPBINDSTATUSCALLBACK);                                       ")
#pragma midl_echo("STDAPI URLOpenPullStreamA(_In_opt_ LPUNKNOWN, _In_ LPCSTR,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                                    ")
#pragma midl_echo("STDAPI URLOpenPullStreamW(_In_opt_ LPUNKNOWN,_In_ LPCWSTR,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                                   ")
#pragma midl_echo("STDAPI URLDownloadToFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _In_opt_ LPCSTR,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                             ")
#pragma midl_echo("STDAPI URLDownloadToFileW(_In_opt_ LPUNKNOWN, _In_ LPCWSTR,_In_opt_ LPCWSTR,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                           ")
#pragma midl_echo("STDAPI URLDownloadToCacheFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR,  _Out_writes_(cchFileName) LPSTR,  DWORD cchFileName, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);")
#pragma midl_echo("STDAPI URLDownloadToCacheFileW(_In_opt_ LPUNKNOWN, _In_ LPCWSTR, _Out_writes_(cchFileName) LPWSTR, DWORD cchFileName, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);")
#pragma midl_echo("STDAPI URLOpenBlockingStreamA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _Outptr_ LPSTREAM*,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                      ")
#pragma midl_echo("STDAPI URLOpenBlockingStreamW(_In_opt_ LPUNKNOWN, _In_ LPCWSTR, _Outptr_ LPSTREAM*,DWORD, _In_opt_ LPBINDSTATUSCALLBACK);                     ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("#ifdef UNICODE                                                                                             ")
#pragma midl_echo("#define URLOpenStream            URLOpenStreamW                                                            ")
#pragma midl_echo("#define URLOpenPullStream        URLOpenPullStreamW                                                        ")
#pragma midl_echo("#define URLDownloadToFile        URLDownloadToFileW                                                        ")
#pragma midl_echo("#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   ")
#pragma midl_echo("#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    ")
#pragma midl_echo("#else                                                                                                      ")
#pragma midl_echo("#define URLOpenStream            URLOpenStreamA                                                            ")
#pragma midl_echo("#define URLOpenPullStream        URLOpenPullStreamA                                                        ")
#pragma midl_echo("#define URLDownloadToFile        URLDownloadToFileA                                                        ")
#pragma midl_echo("#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   ")
#pragma midl_echo("#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    ")
#pragma midl_echo("#endif // !UNICODE                                                                                         ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("                                                                                                           ")
#pragma midl_echo("STDAPI HlinkGoBack(_In_ IUnknown *pUnk);                                                                   ")
#pragma midl_echo("STDAPI HlinkGoForward(_In_ IUnknown *pUnk);                                                                ")
#pragma midl_echo("STDAPI HlinkNavigateString(_In_opt_ IUnknown *pUnk, _In_opt_ LPCWSTR szTarget);                            ")
#pragma midl_echo("STDAPI HlinkNavigateMoniker(_In_opt_ IUnknown *pUnk, _In_opt_ IMoniker *pmkTarget);                        ")
#pragma midl_echo("                                                                                                           ")
// urlhlink end


//
// Some components to not want the new async plugable protocol interfaces (e.g OLE)
//
#pragma midl_echo("#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   ")

interface IInternet;
interface IInternetBindInfo;
interface IInternetBindInfoEx;
interface IInternetProtocolRoot;
interface IInternetProtocol;
interface IInternetProtocolEx;
interface IInternetProtocolSink;
interface IInternetProtocolInfo;
interface IInternetSession;
interface IInternetProtocolSinkStackable;


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternet interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNET")
cpp_quote("#define _LPIINTERNET")

[
        local,
        object,
        uuid(79eac9e0-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternet : IUnknown
{
        typedef [unique] IInternet *LPIINTERNET;



}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetBindInfo interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETBINDINFO")
cpp_quote("#define _LPIINTERNETBINDINFO")

[
        local,
        object,
        uuid(79eac9e1-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetBindInfo : IUnknown
{
        typedef [unique] IInternetBindInfo *LPIINTERNETBINDINFO;

        typedef enum tagBINDSTRING
        {
             BINDSTRING_HEADERS  = 1
            ,BINDSTRING_ACCEPT_MIMES
            ,BINDSTRING_EXTRA_URL
            ,BINDSTRING_LANGUAGE
            ,BINDSTRING_USERNAME
            ,BINDSTRING_PASSWORD
            ,BINDSTRING_UA_PIXELS
            ,BINDSTRING_UA_COLOR
            ,BINDSTRING_OS
            ,BINDSTRING_USER_AGENT
            ,BINDSTRING_ACCEPT_ENCODINGS
            ,BINDSTRING_POST_COOKIE
            ,BINDSTRING_POST_DATA_MIME
            ,BINDSTRING_URL
            ,BINDSTRING_IID
            ,BINDSTRING_FLAG_BIND_TO_OBJECT
            ,BINDSTRING_PTR_BIND_CONTEXT
            ,BINDSTRING_XDR_ORIGIN
            ,BINDSTRING_DOWNLOADPATH
            ,BINDSTRING_ROOTDOC_URL
            ,BINDSTRING_INITIAL_FILENAME
            ,BINDSTRING_PROXY_USERNAME
            ,BINDSTRING_PROXY_PASSWORD
            ,BINDSTRING_ENTERPRISE_ID
            ,BINDSTRING_DOC_URL
            ,BINDSTRING_SAMESITE_COOKIE_LEVEL
        } BINDSTRING;


        HRESULT GetBindInfo(
                [out] DWORD *grfBINDF,
                [in, out, unique] BINDINFO * pbindinfo
                );

        HRESULT GetBindString(
                [in]  ULONG ulStringType,
                [in, out, annotation("__RPC__out")] LPOLESTR *ppwzStr,
                [in]      ULONG cEl,
                [in, out] ULONG *pcElFetched
                );

}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetBindInfoEx interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETBINDINFOEX")
cpp_quote("#define _LPIINTERNETBINDINFOEX")

[
        local,
        object,
        uuid(a3e015b7-a82c-4dcd-a150-569aeeed36ab),
        pointer_default(unique)
]

interface IInternetBindInfoEx : IInternetBindInfo
{
        typedef [unique] IInternetBindInfoEx *LPIINTERNETBINDINFOEX;

        HRESULT GetBindInfoEx(
                [out] DWORD *grfBINDF,
                [in, out, unique] BINDINFO * pbindinfo,
                [out] DWORD *grfBINDF2,
                [out] DWORD *pdwReserved
                );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocolRoot interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOLROOT_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOLROOT_DEFINED")

[
        local,
        object,
        uuid(79eac9e3-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetProtocolRoot : IUnknown
{
        typedef [unique] IInternetProtocolRoot *LPIINTERNETPROTOCOLROOT;

        typedef enum _tagPI_FLAGS
        {
             PI_PARSE_URL               = 0x00000001
            ,PI_FILTER_MODE             = 0x00000002
            ,PI_FORCE_ASYNC             = 0x00000004
            ,PI_USE_WORKERTHREAD        = 0x00000008
            ,PI_MIMEVERIFICATION        = 0x00000010
            ,PI_CLSIDLOOKUP             = 0x00000020
            ,PI_DATAPROGRESS            = 0x00000040
            ,PI_SYNCHRONOUS             = 0x00000080
            ,PI_APARTMENTTHREADED       = 0x00000100
            ,PI_CLASSINSTALL            = 0x00000200
            // new flags to deal with mime handler
            // and to load app directly
            ,PI_PASSONBINDCTX                   = 0x00002000
            ,PI_NOMIMEHANDLER                   = 0x00008000
            ,PI_LOADAPPDIRECT                   = 0x00004000
            // flags used in the protocol data on switch
            ,PD_FORCE_SWITCH            = 0x00010000
            ,PI_PREFERDEFAULTHANDLER            = 0x00020000

        } PI_FLAGS;

        typedef struct _tagPROTOCOLDATA
        {
            DWORD   grfFlags;
            DWORD   dwState;
            LPVOID  pData;
            ULONG   cbData;
        } PROTOCOLDATA;

        typedef struct _tagStartParam
        {
            IID       iid;
            IBindCtx  *pIBindCtx;
            IUnknown  *pItf;
        } StartParam;


        HRESULT Start(
            [in] LPCWSTR szUrl,
            [in] IInternetProtocolSink *pOIProtSink,
            [in] IInternetBindInfo *pOIBindInfo,
            [in] DWORD grfPI,
            [in] HANDLE_PTR dwReserved
            );

        HRESULT Continue(
            [in] PROTOCOLDATA *pProtocolData
            );

        HRESULT Abort(
            [in] HRESULT hrReason,
            [in] DWORD dwOptions
            );

        HRESULT Terminate(
            [in] DWORD dwOptions
            );

        HRESULT Suspend();

        HRESULT Resume();

}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocol interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOL_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOL_DEFINED")

[
        local,
        object,
        uuid(79eac9e4-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetProtocol : IInternetProtocolRoot
{

        typedef [unique] IInternetProtocol *LPIINTERNETPROTOCOL;

        HRESULT Read(
            [in,out, size_is(cb), length_is(*pcbRead)]
            void *pv,
            [in] ULONG cb,
            [out] ULONG *pcbRead);

        HRESULT Seek(
            [in] LARGE_INTEGER dlibMove,
            [in] DWORD dwOrigin,
            [out] ULARGE_INTEGER *plibNewPosition);

        HRESULT LockRequest(
            [in] DWORD dwOptions
            );

        HRESULT UnlockRequest();
}
cpp_quote("#endif")


cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocolEx interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOLEX_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOLEX_DEFINED")

[
        local,
        object,
        uuid(C7A98E66-1010-492c-A1C8-C809E1F75905),
        pointer_default(unique)
]

interface IInternetProtocolEx: IInternetProtocol
{
        HRESULT StartEx(
            [in] IUri *pUri,
            [in] IInternetProtocolSink *pOIProtSink,
            [in] IInternetBindInfo *pOIBindInfo,
            [in] DWORD grfPI,
            [in] HANDLE_PTR dwReserved
            );
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocolSink interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOLSINK_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOLSINK_DEFINED")

[
        local,
        object,
        uuid(79eac9e5-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetProtocolSink : IUnknown
{
        typedef [unique] IInternetProtocolSink *LPIINTERNETPROTOCOLSINK;

        HRESULT Switch(
            [in] PROTOCOLDATA *pProtocolData
            );

        HRESULT ReportProgress(
            [in] ULONG   ulStatusCode,
            [in] LPCWSTR szStatusText
            );

        HRESULT ReportData(
            [in] DWORD grfBSCF,
            [in] ULONG ulProgress,
            [in] ULONG ulProgressMax
            );

        HRESULT ReportResult(
            [in] HRESULT hrResult,
            [in] DWORD   dwError,
            [in] LPCWSTR szResult
            );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocolSinkStackable interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED")

[
        local,
        object,
        uuid(79eac9f0-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetProtocolSinkStackable : IUnknown
{
        typedef [unique] IInternetProtocolSinkStackable *LPIINTERNETPROTOCOLSINKStackable;

        HRESULT SwitchSink(
            [in] IInternetProtocolSink *pOIProtSink
            );

        HRESULT CommitSwitch();
        HRESULT RollbackSwitch();
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997.
//
//  Contents:   IInternetSession interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETSESSION_DEFINED")
cpp_quote("#define _LPIINTERNETSESSION_DEFINED")

[
        local,
        object,
        uuid(79eac9e7-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]


interface IInternetSession : IUnknown
{
        typedef [unique] IInternetSession *LPIINTERNETSESSION;

        typedef enum _tagOIBDG_FLAGS
        {
            // default is free threaded
             OIBDG_APARTMENTTHREADED        = 0x00000100
            ,OIBDG_DATAONLY                 = 0x00001000
        } OIBDG_FLAGS;

        HRESULT RegisterNameSpace(
            [in] IClassFactory *pCF,
            [in] REFCLSID rclsid,
            [in] LPCWSTR pwzProtocol,
            [in] ULONG          cPatterns,
            [in] const LPCWSTR *ppwzPatterns,
            [in] DWORD          dwReserved
            );

        HRESULT UnregisterNameSpace(
            [in] IClassFactory *pCF,
            [in] LPCWSTR pszProtocol
            );

        HRESULT RegisterMimeFilter(
            [in] IClassFactory *pCF,
            [in] REFCLSID rclsid,
            [in] LPCWSTR pwzType
            );

        HRESULT UnregisterMimeFilter(
            [in] IClassFactory *pCF,
            [in] LPCWSTR pwzType
            );

        HRESULT CreateBinding(
            [in] LPBC pBC,
            [in] LPCWSTR szUrl,
            [in] IUnknown *pUnkOuter,
            [out, unique] IUnknown **ppUnk,
            [out, unique] IInternetProtocol **ppOInetProt,
            [in] DWORD dwOption
            );

        HRESULT SetSessionOption(
            [in] DWORD dwOption,
            [in] LPVOID pBuffer,
            [in] DWORD dwBufferLength,
            [in] DWORD dwReserved
            );

        HRESULT GetSessionOption(
            [in] DWORD dwOption,
            [in, out] LPVOID pBuffer,
            [in, out] DWORD *pdwBufferLength,
            [in] DWORD dwReserved
            );
}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetThreadSwitch interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETTHREADSWITCH_DEFINED")
cpp_quote("#define _LPIINTERNETTHREADSWITCH_DEFINED")

[
        local,
        object,
        uuid(79eac9e8-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetThreadSwitch : IUnknown
{
        typedef [unique] IInternetThreadSwitch *LPIINTERNETTHREADSWITCH;

        HRESULT Prepare();

        HRESULT Continue();
}
cpp_quote("#endif")



//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetPriority interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPRIORITY_DEFINED")
cpp_quote("#define _LPIINTERNETPRIORITY_DEFINED")

[
        local,
        object,
        uuid(79eac9eb-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetPriority : IUnknown
{
        typedef [unique] IInternetPriority *LPIINTERNETPRIORITY;

        HRESULT SetPriority(
            [in] LONG nPriority
            );

        HRESULT GetPriority(
            [out] LONG * pnPriority
            );

}
cpp_quote("#endif")




//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetProtocolInfo interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIINTERNETPROTOCOLINFO_DEFINED")
cpp_quote("#define _LPIINTERNETPROTOCOLINFO_DEFINED")

[
        local,
        object,
        uuid(79eac9ec-baf9-11ce-8c82-00aa004ba90b),
        pointer_default(unique)
]

interface IInternetProtocolInfo : IUnknown
{
        typedef [unique] IInternetProtocolInfo *LPIINTERNETPROTOCOLINFO;

        typedef enum _tagPARSEACTION
        {
             PARSE_CANONICALIZE      = 1    // compute canonical URL
            ,PARSE_FRIENDLY                 // get user friendly name from URL
            ,PARSE_SECURITY_URL             // get security URL.
            ,PARSE_ROOTDOCUMENT             // returns URL of root document for site
            ,PARSE_DOCUMENT                 // Strips of #anchor
            ,PARSE_ANCHOR                   // Strips of everything before #anchor
            ,PARSE_ENCODE_IS_UNESCAPE       // decode/unescape (misnamed constant) - deprecated for PARSE_UNESCAPE
            ,PARSE_DECODE_IS_ESCAPE         // encode/escape (misnamed constant) - deprecated for PARSE_ESCAPE
            ,PARSE_PATH_FROM_URL            // get the path if apply
            ,PARSE_URL_FROM_PATH            // create a url from the path
            ,PARSE_MIME                     // return mime of this url
            ,PARSE_SERVER                   // return server
            ,PARSE_SCHEMA
            ,PARSE_SITE
            ,PARSE_DOMAIN
            ,PARSE_LOCATION
            ,PARSE_SECURITY_DOMAIN          // returns the canonical security form of the URL.
            ,PARSE_ESCAPE                   // encode the url
            ,PARSE_UNESCAPE                 // decode the url
        } PARSEACTION;

        // Actions for CoInternetGetSecurityURL function.
        typedef enum _tagPSUACTION
        {
            PSU_DEFAULT            = 1         // gets security URL and returns its domain.
            ,PSU_SECURITY_URL_ONLY             // gets just the security URL
        } PSUACTION;

        //
        // Query options - needs more work on possible options
        //
        typedef enum _tagQUERYOPTION
        {
             QUERY_EXPIRATION_DATE      = 1     // the expiration date in form of systemtime
            ,QUERY_TIME_OF_LAST_CHANGE          // time of last change in form of systemtime
            ,QUERY_CONTENT_ENCODING             // the content concoding schema
            ,QUERY_CONTENT_TYPE                 // the content type header (mime and charset)
            ,QUERY_REFRESH                      // the refresh
            ,QUERY_RECOMBINE                    // combine the page URL with the nearest base if TRUE
            ,QUERY_CAN_NAVIGATE                 // does the protocol navigate (unlike mailto)
            ,QUERY_USES_NETWORK                 // will URL hit network
            ,QUERY_IS_CACHED                    // is data cached locally?
            ,QUERY_IS_INSTALLEDENTRY            // Is the entry installed locally (on cdrom)
            ,QUERY_IS_CACHED_OR_MAPPED          // is the entry in cache or is it on a mapped drive
                                                // It may be mapped but may not actually be present
            ,QUERY_USES_CACHE                   // does the protocol use the internet cache
            ,QUERY_IS_SECURE                    // is the protocol encrypted
            ,QUERY_IS_SAFE                      // the protocol serves only trusted (e.g. local resource) content
            ,QUERY_USES_HISTORYFOLDER           // should the urls from this protocol appear in history
            ,QUERY_IS_CACHED_AND_USABLE_OFFLINE // cache entry is not expired or flagged must revalidate
        } QUERYOPTION;

        //
        // returns:
        // S_OK on success
        // S_FALSE on success but buffer is too small
        // INET_E_DEFAULT_ACTION if action is not know should be handled be default implementation
        //
        HRESULT ParseUrl(
            [in]    LPCWSTR     pwzUrl,
            [in]    PARSEACTION ParseAction,
            [in]    DWORD       dwParseFlags,
            [out, annotation("__RPC__out")]   LPWSTR      pwzResult,
            [in]    DWORD       cchResult,
            [out]   DWORD      *pcchResult,
            [in]    DWORD       dwReserved
            );

        //
        // returns:
        // S_OK on success
        // S_FALSE on success but buffer is too small
        // INET_E_DEFAULT_ACTION if action is not know should be handled be default implementation
        //
        HRESULT CombineUrl(
            [in]    LPCWSTR     pwzBaseUrl,
            [in]    LPCWSTR     pwzRelativeUrl,
            [in]    DWORD       dwCombineFlags,
            [out, annotation("__RPC__in")]   LPWSTR      pwzResult,
            [in]    DWORD       cchResult,
            [out]   DWORD      *pcchResult,
            [in]    DWORD       dwReserved
            );

        //
        // returns:
        // S_OK  if equal
        // S_FALSE otherwise
        //
        HRESULT CompareUrl(
            [in]    LPCWSTR pwzUrl1,
            [in]    LPCWSTR pwzUrl2,
            [in]    DWORD dwCompareFlags
            );

        //
        // returns:
        // S_OK on success
        // S_FALSE on success but buffer is too small
        // INET_E_QUERYOPTION_UNKNOWN
        //
        HRESULT QueryInfo(
            [in]        LPCWSTR pwzUrl,
            [in]        QUERYOPTION   OueryOption,
            [in]        DWORD         dwQueryFlags,
            [in, out,size_is(*pcbBuf)]  LPVOID pBuffer,
            [in]        DWORD   cbBuffer,
            [in, out]   DWORD  *pcbBuf,
            [in]        DWORD   dwReserved
            );

}

cpp_quote("#ifndef URLMON_STRICT")
cpp_quote("// PARSE_ENCODE was misnamed and is deprecated for PARSE_UNESCAPE")
cpp_quote("#define PARSE_ENCODE PARSE_ENCODE_IS_UNESCAPE")
cpp_quote("// PARSE_DECODE was misnamed and is deprecated for PARSE_ESCAPE")
cpp_quote("#define PARSE_DECODE PARSE_DECODE_IS_ESCAPE")
cpp_quote("#endif //!URLMON_STRICT")

cpp_quote("#endif")

//
// compatablility defines
//
cpp_quote("#define IOInet               IInternet            ")
cpp_quote("#define IOInetBindInfo       IInternetBindInfo    ")
cpp_quote("#define IOInetBindInfoEx     IInternetBindInfoEx  ")
cpp_quote("#define IOInetProtocolRoot   IInternetProtocolRoot")
cpp_quote("#define IOInetProtocol       IInternetProtocol    ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define IOInetProtocolEx     IInternetProtocolEx  ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#define IOInetProtocolSink   IInternetProtocolSink")
cpp_quote("#define IOInetProtocolInfo   IInternetProtocolInfo")
cpp_quote("#define IOInetSession        IInternetSession     ")
cpp_quote("#define IOInetPriority       IInternetPriority    ")
cpp_quote("#define IOInetThreadSwitch   IInternetThreadSwitch")
cpp_quote("#define IOInetProtocolSinkStackable   IInternetProtocolSinkStackable")

cpp_quote("#define LPOINET              LPIINTERNET             ")
cpp_quote("#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO ")
cpp_quote("#define LPOINETBINDINFO      LPIINTERNETBINDINFO     ")
cpp_quote("#define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT ")
cpp_quote("#define LPOINETPROTOCOL      LPIINTERNETPROTOCOL     ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define LPOINETPROTOCOLEX    LPIINTERNETPROTOCOLEX   ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK ")
cpp_quote("#define LPOINETSESSION       LPIINTERNETSESSION      ")
cpp_quote("#define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH ")
cpp_quote("#define LPOINETPRIORITY      LPIINTERNETPRIORITY     ")
cpp_quote("#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO ")
cpp_quote("#define LPOINETPROTOCOLSINKSTACKABLE  LPIINTERNETPROTOCOLSINKSTACKABLE ")


cpp_quote("#define IID_IOInet               IID_IInternet            ")
cpp_quote("#define IID_IOInetBindInfo       IID_IInternetBindInfo    ")
cpp_quote("#define IID_IOInetBindInfoEx     IID_IInternetBindInfoEx  ")
cpp_quote("#define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot")
cpp_quote("#define IID_IOInetProtocol       IID_IInternetProtocol    ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define IID_IOInetProtocolEx     IID_IInternetProtocolEx  ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#define IID_IOInetProtocolSink   IID_IInternetProtocolSink")
cpp_quote("#define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo")
cpp_quote("#define IID_IOInetSession        IID_IInternetSession     ")
cpp_quote("#define IID_IOInetPriority       IID_IInternetPriority    ")
cpp_quote("#define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch")
cpp_quote("#define IID_IOInetProtocolSinkStackable   IID_IInternetProtocolSinkStackable")


//
// OInet helper functions for url parsing
//
#pragma midl_echo("STDAPI CoInternetParseUrl(                              ")
#pragma midl_echo("                                             LPCWSTR      pwzUrl,        ")
#pragma midl_echo("                                             PARSEACTION  ParseAction,   ")
#pragma midl_echo("                                             DWORD        dwFlags,       ")
#pragma midl_echo("    _Out_writes_to_(cchResult,*pcchResult+1) LPWSTR       pszResult,     ")
#pragma midl_echo("                                             DWORD        cchResult,     ")
#pragma midl_echo("    _Out_                                    DWORD       *pcchResult,    ")
#pragma midl_echo("                                             DWORD        dwReserved     ")
#pragma midl_echo("    );                                                  ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
#pragma midl_echo("STDAPI CoInternetParseIUri(                             ")
#pragma midl_echo("    _In_                                     IUri        *pIUri,         ")
#pragma midl_echo("                                             PARSEACTION  ParseAction,   ")
#pragma midl_echo("                                             DWORD        dwFlags,       ")
#pragma midl_echo("    _Out_writes_to_(cchResult,*pcchResult+1) LPWSTR       pwzResult,     ")
#pragma midl_echo("                                             DWORD        cchResult,     ")
#pragma midl_echo("    _Out_                                    DWORD       *pcchResult,    ")
#pragma midl_echo("    _Reserved_                               DWORD_PTR    dwReserved     ")
#pragma midl_echo("    );                                                  ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

#pragma midl_echo("STDAPI CoInternetCombineUrl(                                           ")
#pragma midl_echo("                                             LPCWSTR   pwzBaseUrl,     ")
#pragma midl_echo("                                             LPCWSTR   pwzRelativeUrl, ")
#pragma midl_echo("                                             DWORD     dwCombineFlags, ")
#pragma midl_echo("    _Out_writes_to_(cchResult,*pcchResult+1) LPWSTR    pszResult,      ")
#pragma midl_echo("                                             DWORD     cchResult,      ")
#pragma midl_echo("    _Out_opt_                                DWORD     *pcchResult,    ")
#pragma midl_echo("    _Reserved_                               DWORD     dwReserved      ")
#pragma midl_echo("    );                                                                 ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
#pragma midl_echo("STDAPI CoInternetCombineUrlEx(               ")
#pragma midl_echo("    _In_opt_     IUri       *pBaseUri,       ")
#pragma midl_echo("    _In_opt_     LPCWSTR     pwzRelativeUrl, ")
#pragma midl_echo("                 DWORD       dwCombineFlags, ")
#pragma midl_echo("    _Outptr_     IUri      **ppCombinedUri,  ")
#pragma midl_echo("    _In_opt_     DWORD_PTR   dwReserved      ")
#pragma midl_echo("    );                                       ")
#pragma midl_echo("STDAPI CoInternetCombineIUri (               ")
#pragma midl_echo("    _In_         IUri       *pBaseUri,       ")
#pragma midl_echo("    _In_         IUri       *pRelativeUri,   ")
#pragma midl_echo("                 DWORD       dwCombineFlags, ")
#pragma midl_echo("    _Outptr_     IUri      **ppCombinedUri,  ")
#pragma midl_echo("    _In_opt_     DWORD_PTR   dwReserved      ")
#pragma midl_echo("    );                                       ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

#pragma midl_echo("STDAPI CoInternetCompareUrl(             ")
#pragma midl_echo("    LPCWSTR pwzUrl1,                     ")
#pragma midl_echo("    LPCWSTR pwzUrl2,                     ")
#pragma midl_echo("    DWORD dwFlags                        ")
#pragma midl_echo("    );                                   ")
#pragma midl_echo("STDAPI CoInternetGetProtocolFlags(       ")
#pragma midl_echo("             LPCWSTR     pwzUrl,         ")
#pragma midl_echo("    _Out_    DWORD      *pdwFlags,       ")
#pragma midl_echo("             DWORD       dwReserved      ")
#pragma midl_echo("    );                                   ")
#pragma midl_echo("STDAPI CoInternetQueryInfo(                                                ")
#pragma midl_echo("                                                 LPCWSTR     pwzUrl,       ")
#pragma midl_echo("                                                 QUERYOPTION QueryOptions, ")
#pragma midl_echo("                                                 DWORD       dwQueryFlags, ")
#pragma midl_echo("    _Out_writes_bytes_to_(cbBuffer, *pcbBuffer)  LPVOID      pvBuffer,     ")
#pragma midl_echo("    _In_range_(>=, sizeof(DWORD))                DWORD       cbBuffer,     ")
#pragma midl_echo("    _Out_opt_                                    DWORD      *pcbBuffer,    ")
#pragma midl_echo("                                                 DWORD       dwReserved    ")
#pragma midl_echo("    );                                                                     ")
#pragma midl_echo("STDAPI CoInternetGetSession(                             ")
#pragma midl_echo("                 DWORD               dwSessionMode,      ")
#pragma midl_echo("    _Outptr_     IInternetSession  **ppIInternetSession, ")
#pragma midl_echo("                 DWORD               dwReserved          ")
#pragma midl_echo("    );                                                   ")
#pragma midl_echo("STDAPI CoInternetGetSecurityUrl(         ")
#pragma midl_echo("                 LPCWSTR pwszUrl,        ")
#pragma midl_echo("    _Outptr_     LPWSTR *ppwszSecUrl,    ")
#pragma midl_echo("    _In_         PSUACTION   psuAction,  ")
#pragma midl_echo("    _Reserved_   DWORD dwReserved        ")
#pragma midl_echo("    );                                   ")
#pragma midl_echo("STDAPI AsyncInstallDistributionUnit(     ")
#pragma midl_echo("    _In_ LPCWSTR szDistUnit,             ")
#pragma midl_echo("    _In_opt_ LPCWSTR szTYPE,             ")
#pragma midl_echo("    _In_opt_ LPCWSTR szExt,              ")
#pragma midl_echo("    DWORD dwFileVersionMS,               ")
#pragma midl_echo("    DWORD dwFileVersionLS,               ")
#pragma midl_echo("    _In_opt_ LPCWSTR szURL,                  ")
#pragma midl_echo("    _In_ IBindCtx *pbc,                  ")
#pragma midl_echo("    _Reserved_ LPVOID   pvReserved,      ")
#pragma midl_echo("    DWORD   flags                        ")
#pragma midl_echo("    );                                   ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
#pragma midl_echo("STDAPI CoInternetGetSecurityUrlEx(           ")
#pragma midl_echo("    _In_         IUri           *pUri,       ")
#pragma midl_echo("    _Outptr_     IUri          **ppSecUri,   ")
#pragma midl_echo("                 PSUACTION       psuAction,  ")
#pragma midl_echo("    _Reserved_   DWORD_PTR       dwReserved  ")
#pragma midl_echo("    );                                       ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")


cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
//
// Feature options, primarily for Springboard
//

cpp_quote("#ifndef _INTERNETFEATURELIST_DEFINED")
cpp_quote("#define _INTERNETFEATURELIST_DEFINED")

typedef enum _tagINTERNETFEATURELIST
{
    FEATURE_OBJECT_CACHING      = 0,
    FEATURE_ZONE_ELEVATION,
    FEATURE_MIME_HANDLING,
    FEATURE_MIME_SNIFFING,
    FEATURE_WINDOW_RESTRICTIONS,
    FEATURE_WEBOC_POPUPMANAGEMENT,
    FEATURE_BEHAVIORS,
    FEATURE_DISABLE_MK_PROTOCOL,
    FEATURE_LOCALMACHINE_LOCKDOWN,
    FEATURE_SECURITYBAND,
    FEATURE_RESTRICT_ACTIVEXINSTALL,
    FEATURE_VALIDATE_NAVIGATE_URL,
    FEATURE_RESTRICT_FILEDOWNLOAD,
    FEATURE_ADDON_MANAGEMENT,
    FEATURE_PROTOCOL_LOCKDOWN,
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE,
    FEATURE_SAFE_BINDTOOBJECT,
    FEATURE_UNC_SAVEDFILECHECK,
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED,
    FEATURE_TABBED_BROWSING,
    FEATURE_SSLUX,
    FEATURE_DISABLE_NAVIGATION_SOUNDS,
    FEATURE_DISABLE_LEGACY_COMPRESSION, // retiredIE9
    FEATURE_FORCE_ADDR_AND_STATUS,
    FEATURE_XMLHTTP,
    FEATURE_DISABLE_TELNET_PROTOCOL,
    FEATURE_FEEDS,
    FEATURE_BLOCK_INPUT_PROMPTS,
    FEATURE_ENTRY_COUNT,             // This should be the last item
} INTERNETFEATURELIST;

cpp_quote("")
cpp_quote("// CoInternetSetFeatureEnabled can be used to set/reset features. ")
cpp_quote("// The following flags control where the feature is set")
cpp_quote("")
cpp_quote("#define SET_FEATURE_ON_THREAD                       0x00000001")
cpp_quote("#define SET_FEATURE_ON_PROCESS                      0x00000002")
cpp_quote("#define SET_FEATURE_IN_REGISTRY                     0x00000004")
cpp_quote("#define SET_FEATURE_ON_THREAD_LOCALMACHINE          0x00000008")
cpp_quote("#define SET_FEATURE_ON_THREAD_INTRANET              0x00000010")
cpp_quote("#define SET_FEATURE_ON_THREAD_TRUSTED               0x00000020")
cpp_quote("#define SET_FEATURE_ON_THREAD_INTERNET              0x00000040")
cpp_quote("#define SET_FEATURE_ON_THREAD_RESTRICTED            0x00000080")

cpp_quote("")
cpp_quote("// CoInternetIsFeatureEnabled can be used to get features. ")
cpp_quote("// The following flags control where the feature is obtained from")
cpp_quote("// default is from process")
cpp_quote("")
cpp_quote("#define GET_FEATURE_FROM_THREAD                      0x00000001")
cpp_quote("#define GET_FEATURE_FROM_PROCESS                     0x00000002")
cpp_quote("#define GET_FEATURE_FROM_REGISTRY                    0x00000004")
cpp_quote("#define GET_FEATURE_FROM_THREAD_LOCALMACHINE         0x00000008")
cpp_quote("#define GET_FEATURE_FROM_THREAD_INTRANET             0x00000010")
cpp_quote("#define GET_FEATURE_FROM_THREAD_TRUSTED              0x00000020")
cpp_quote("#define GET_FEATURE_FROM_THREAD_INTERNET             0x00000040")
cpp_quote("#define GET_FEATURE_FROM_THREAD_RESTRICTED           0x00000080")

cpp_quote("#endif")

//
// OInet helper functions for looking up if features are enabled
//

#pragma midl_echo("STDAPI CoInternetSetFeatureEnabled(      ")
#pragma midl_echo("    INTERNETFEATURELIST FeatureEntry,    ")
#pragma midl_echo("    DWORD dwFlags,                       ")
#pragma midl_echo("    BOOL fEnable                         ")
#pragma midl_echo("    );                                   ")

#pragma midl_echo("STDAPI CoInternetIsFeatureEnabled(       ")
#pragma midl_echo("    INTERNETFEATURELIST FeatureEntry,    ")
#pragma midl_echo("    DWORD dwFlags                        ")
#pragma midl_echo("    );                                   ")

#pragma midl_echo("STDAPI CoInternetIsFeatureEnabledForUrl( ")
#pragma midl_echo("    INTERNETFEATURELIST FeatureEntry,    ")
#pragma midl_echo("    DWORD dwFlags,                       ")
#pragma midl_echo("    _In_opt_ LPCWSTR szURL,                       ")
#pragma midl_echo("    _In_opt_ IInternetSecurityManager *pSecMgr    ")
#pragma midl_echo("    );                                   ")

#pragma midl_echo("STDAPI CoInternetIsFeatureEnabledForIUri( ")
#pragma midl_echo("    INTERNETFEATURELIST FeatureEntry,     ")
#pragma midl_echo("    DWORD dwFlags,                        ")
#pragma midl_echo("    _In_opt_ IUri * pIUri,                         ")
#pragma midl_echo("    _In_opt_ IInternetSecurityManagerEx2 *pSecMgr  ")
#pragma midl_echo("    );                                    ")

#pragma midl_echo("STDAPI CoInternetIsFeatureZoneElevationEnabled( ")
#pragma midl_echo("    _In_opt_ LPCWSTR szFromURL,                 ")
#pragma midl_echo("    _In_ LPCWSTR szToURL,                       ")
#pragma midl_echo("    _In_opt_ IInternetSecurityManager *pSecMgr, ")
#pragma midl_echo("    DWORD dwFlags                               ")
#pragma midl_echo("    );                                          ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

//
// STGMEDIUMs and BINDINFO helper utils
//
#pragma midl_echo(" ")
#pragma midl_echo("STDAPI CopyStgMedium(_In_ const STGMEDIUM * pcstgmedSrc,  ")
#pragma midl_echo("                     _Out_      STGMEDIUM * pstgmedDest); ")

#pragma midl_echo("STDAPI CopyBindInfo(_In_ const BINDINFO * pcbiSrc,   ")
#pragma midl_echo("                    _Out_      BINDINFO * pbiDest ); ")

#pragma midl_echo("STDAPI_(void) ReleaseBindInfo( _Inout_ BINDINFO * pbindinfo );  ")
#pragma midl_echo(" ")

cpp_quote("#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      ")
cpp_quote("#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      ")
cpp_quote("#define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER  ")
cpp_quote("#define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)      ")
cpp_quote("#define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)      ")

cpp_quote("#define OInetParseUrl               CoInternetParseUrl               ")
cpp_quote("#define OInetCombineUrl             CoInternetCombineUrl             ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define OInetCombineUrlEx           CoInternetCombineUrlEx           ")
cpp_quote("#define OInetCombineIUri            CoInternetCombineIUri            ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#define OInetCompareUrl             CoInternetCompareUrl             ")
cpp_quote("#define OInetQueryInfo              CoInternetQueryInfo              ")
cpp_quote("#define OInetGetSession             CoInternetGetSession             ")

#pragma midl_echo("#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ ")

cpp_quote("//")
cpp_quote("// Static Protocol flags")
cpp_quote("//")
cpp_quote("#define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001")
cpp_quote("")

#pragma midl_echo("// Do not take a dependency on the exact value of the private namespace, no guarantee is given that it won't change.")
#pragma midl_echo("STDAPI_(PWSTR) IEGetUserPrivateNamespaceName(void);")
#pragma midl_echo(" ")


cpp_quote("// Creates the security manager object. The first argument is the Service provider")
cpp_quote("// to allow for delegation")
cpp_quote("STDAPI CoInternetCreateSecurityManager(_In_opt_ IServiceProvider *pSP, _Outptr_ IInternetSecurityManager **ppSM, DWORD dwReserved);")
cpp_quote("")
cpp_quote("STDAPI CoInternetCreateZoneManager(_In_opt_ IServiceProvider *pSP, _Outptr_ IInternetZoneManager **ppZM, DWORD dwReserved);")
cpp_quote("")
cpp_quote("")

cpp_quote("// Security manager CLSID's")
cpp_quote("EXTERN_C const IID CLSID_InternetSecurityManager;  ")
cpp_quote("EXTERN_C const IID CLSID_InternetZoneManager;  ")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("EXTERN_C const IID CLSID_PersistentZoneIdentifier;  ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

cpp_quote("// This service is used for delegation support on the Security Manager interface")
cpp_quote("#define SID_SInternetSecurityManager         IID_IInternetSecurityManager")
cpp_quote("")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#define SID_SInternetSecurityManagerEx         IID_IInternetSecurityManagerEx")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#define SID_SInternetSecurityManagerEx2         IID_IInternetSecurityManagerEx2")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("")

cpp_quote("#define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager")
cpp_quote("")

cpp_quote("#ifndef _LPINTERNETSECURITYMGRSITE_DEFINED")
cpp_quote("#define _LPINTERNETSECURITYMGRSITE_DEFINED")
[

    local,
    object,
    uuid(79eac9ed-baf9-11ce-8c82-00aa004ba90b),
    helpstring("IInternetSecurityMgrSite Interface"),
    pointer_default(unique)
]

interface IInternetSecurityMgrSite : IUnknown
{
    HRESULT GetWindow (
            [out] HWND* phwnd);
    HRESULT EnableModeless (
            [in] BOOL fEnable);
};
cpp_quote("#endif")

cpp_quote("#ifndef _LPINTERNETSECURITYMANANGER_DEFINED")
cpp_quote("#define _LPINTERNETSECURITYMANANGER_DEFINED")

[

    uuid(79eac9ee-baf9-11ce-8c82-00aa004ba90b),
    helpstring("IInternetSecurityManager Interface"),
    pointer_default(unique)
]

interface IInternetSecurityManager : IUnknown
{
    HRESULT     SetSecuritySite
    (
        [in,unique]    IInternetSecurityMgrSite *pSite
    );

    HRESULT     GetSecuritySite
    (
        [out]   IInternetSecurityMgrSite **ppSite
    );

cpp_quote("#define MUTZ_NOSAVEDFILECHECK        0x00000001 // don't check file: for saved file comment")
cpp_quote("#define MUTZ_ISFILE                  0x00000002 // Assume URL if File, url does not need file://")
cpp_quote("#define MUTZ_ACCEPT_WILDCARD_SCHEME  0x00000080 // Accept a wildcard scheme")
cpp_quote("#define MUTZ_ENFORCERESTRICTED       0x00000100 // enforce restricted zone independent of URL")
cpp_quote("#define MUTZ_RESERVED                0x00000200 // This is same as PUAF_NOSAVEDFILECHECK. However we already have MUTZ_NOSAVEDFILECHECK for this.")
cpp_quote("#define MUTZ_REQUIRESAVEDFILECHECK   0x00000400 // always check the file for MOTW (overriding FEATURE_UNC_SAVEDFILECHECK)")
cpp_quote("#define MUTZ_DONT_UNESCAPE           0x00000800 // Do not unescape the url")
cpp_quote("#define MUTZ_DONT_USE_CACHE          0x00001000 // Do not check the cache")
cpp_quote("#define MUTZ_FORCE_INTRANET_FLAGS    0x00002000 // Force the intranet flags to be active")
cpp_quote("#define MUTZ_IGNORE_ZONE_MAPPINGS    0x00004000 // Don't look up the Zone Mappings")

    HRESULT MapUrlToZone
    (
        [in]    LPCWSTR     pwszUrl,
        [out]   DWORD*      pdwZone,
        [in]    DWORD       dwFlags
    );

cpp_quote("// MapUrlToZone returns the zone index given a URL")

cpp_quote("#define MAX_SIZE_SECURITY_ID 512 // bytes")

midl_pragma warning(disable:2495) // annotation is allowed on local interface and local methods only
    HRESULT GetSecurityId
    (
        [in, annotation("_In_")]
                LPCWSTR     pwszUrl,
        [out, size_is(*pcbSecurityId), annotation("_Out_writes_bytes_to_(MAX_SIZE_SECURITY_ID, *pcbSecurityId)")]
                BYTE*   pbSecurityId,
        [in, out, annotation("_Inout_ _At_(*pcbSecurityId, _In_range_(>= , MAX_SIZE_SECURITY_ID) _Out_range_(0, MAX_SIZE_SECURITY_ID))")]
                DWORD*  pcbSecurityId,
        [in, annotation("_In_")]
                DWORD_PTR dwReserved
    );
midl_pragma warning (default: 2495)

    // Flags passed into ProcessUrlAction.
    typedef enum
    {
        PUAF_DEFAULT                        = 0x00000000,
        PUAF_NOUI                           = 0x00000001,
        PUAF_ISFILE                         = 0x00000002,  // Assume URL if File, url does not need file://
        PUAF_WARN_IF_DENIED                 = 0x00000004,
        PUAF_FORCEUI_FOREGROUND             = 0x00000008,
        PUAF_CHECK_TIFS                     = 0x00000010,
        PUAF_DONTCHECKBOXINDIALOG           = 0x00000020,
        PUAF_TRUSTED                        = 0x00000040,
        PUAF_ACCEPT_WILDCARD_SCHEME         = 0x00000080,
        PUAF_ENFORCERESTRICTED              = 0x00000100,
        PUAF_NOSAVEDFILECHECK               = 0x00000200, // don't check file: for saved comment
        PUAF_REQUIRESAVEDFILECHECK          = 0x00000400, // always check the file for MOTW (overriding FEATURE_UNC_SAVEDFILECHECK)
        PUAF_DONT_USE_CACHE                 = 0x00001000, // don't use the MUTZ zone cache - recompute the zone.
        PUAF_RESERVED1                      = 0x00002000, // RESERVED for MUTZ_FORCE_INTRANET_FLAGS.
        PUAF_RESERVED2                      = 0x00004000, // RESERVED for MUTZ_IGNORE_ZONE_MAPPINGS.
        PUAF_LMZ_UNLOCKED                   = 0x00010000, // flag to retrieve local machine policies when LMZL is on
        PUAF_LMZ_LOCKED                     = 0x00020000, // flag to force retrieving locked down local machine policies when LMZL is on
        PUAF_DEFAULTZONEPOL                 = 0x00040000, // flag to retrieve Default Security Zone policies when NPL is on
        PUAF_NPL_USE_LOCKED_IF_RESTRICTED   = 0x00080000, // flag to tell urlmon that trident wants to use locked zones if needed.
        PUAF_NOUIIFLOCKED                   = 0x00100000, // flag to turn off UI if Urlmon figures it is using the locked zone.
        PUAF_DRAGPROTOCOLCHECK              = 0x00200000  // flag to check for allow-list drag protcols when URLACTION_SHELL_MOVE_OR_COPY is allow
    } PUAF ;

    typedef enum
    {
        PUAFOUT_DEFAULT                        = 0x00000000,
        PUAFOUT_ISLOCKZONEPOLICY               = 0x00000001
    } PUAFOUT ;

cpp_quote("// Note that for the below function, the semantics of the 'pwszUrl',")
cpp_quote("// 'pContext', and 'cbContext' parameters depend on the specific")
cpp_quote("// URLACTION_* enum value that is passed for 'dwAction'. For example,")
cpp_quote("// when 'dwAction' is URLACTION_HTML_MIXED_CONTENT, 'pwszUrl' will be")
cpp_quote("// the target URL of the resource, 'pContext' will be the containing")
cpp_quote("// document's IUri* cast to BYTE*, and 'cbContext' will be sizeof(Uri*).")
cpp_quote("// When 'dwAction' is URLACTION_CROSS_DOMAIN_DATA, 'pwszUrl' will be")
cpp_quote("// the source URL, 'pContext' will be the target PCWSTR cast to BYTE*,")
cpp_quote("// and 'cbContext' will be the size of the string including its null")
cpp_quote("// terminator. Implementers should use the value of 'dwAction' to")
cpp_quote("// correctly interpret the 'pswzUrl', 'pContext' and 'cbContext' for")
cpp_quote("// each action type.")
    HRESULT     ProcessUrlAction
    (
        [in]    LPCWSTR     pwszUrl,
        [in]    DWORD       dwAction,
        [out, size_is(cbPolicy)]
                BYTE*   pPolicy,    // output buffer pointer
        [in]    DWORD   cbPolicy,   // output buffer size
        [in, unique]
                BYTE*   pContext,   // context (used by the delegation routines)
        [in]    DWORD   cbContext,  // size of the Context
        [in]    DWORD   dwFlags,    // See enum PUAF for details.
        [in]    DWORD   dwReserved
    );

cpp_quote("// This is the wrapper function that most clients will use.")
cpp_quote("// It figures out the current Policy for the passed in Action,")
cpp_quote("// and puts up UI if the current Policy indicates that the user")
cpp_quote("// should be queried. It returns back the Policy which the caller")
cpp_quote("// will use to determine if the action should be allowed")

    HRESULT     QueryCustomPolicy
    (
        [in]    LPCWSTR     pwszUrl,
        [in]    REFGUID     guidKey,
        [out, size_is(,*pcbPolicy)]     // allocation via IMemAlloc; caller frees
                BYTE**  ppPolicy,   // pointer to output buffer pointer
        [out]   DWORD*  pcbPolicy,  // pointer to output buffer size
        [in]    BYTE*   pContext,   // context (used by the delegation routines)
        [in]    DWORD   cbContext,  // size of the Context
        [in]    DWORD   dwReserved
    );
cpp_quote("// This is the wrapper function to conveniently read a custom policy.")

// create/enumerate mappings

    typedef enum
    {
        SZM_CREATE = 0x00000000, // create new mapping, error's if mapping already exists.
        SZM_DELETE = 0x00000001, // delete the mapping
    }
        SZM_FLAGS;

    HRESULT SetZoneMapping
    (
        [in]    DWORD   dwZone,        // absolute zone index
        [in]    LPCWSTR lpszPattern,   // URL pattern with limited wildcarding
        [in]    DWORD   dwFlags       // add, change, delete
    );

cpp_quote("// SetZoneMapping")
cpp_quote("//    lpszPattern: string denoting a URL pattern")
cpp_quote("//        Examples of valid patterns:   ")
cpp_quote("//            *://*.msn.com             ")
cpp_quote("//            http://*.sony.co.jp       ")
cpp_quote("//            *://et.msn.com            ")
cpp_quote("//            ftp://157.54.23.41/       ")
cpp_quote("//            https://localsvr          ")
cpp_quote("//            file:\\localsvr\share     ")
cpp_quote("//            *://157.54.100-200.*      ")
cpp_quote("//        Examples of invalid patterns: ")
cpp_quote("//            http://*.lcs.mit.edu      ")
cpp_quote("//            ftp://*                   ")
cpp_quote("//    dwFlags: SZM_FLAGS values         ")

    HRESULT GetZoneMappings
    (
        [in]    DWORD   dwZone,        // absolute zone index
        [out]   IEnumString  **ppenumString,   // output buffer size
        [in]    DWORD   dwFlags        // reserved, pass 0
    );
// Returns an enumerator of strings for the mappings of a zone.
// dwFlags is for future use; pass in 0.

};
cpp_quote("#endif")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#ifndef _LPINTERNETSECURITYMANANGEREX_DEFINED")
cpp_quote("#define _LPINTERNETSECURITYMANANGEREX_DEFINED")

[

    uuid(F164EDF1-CC7C-4f0d-9A94-34222625C393),
    helpstring("IInternetSecurityManagerEx Interface"),
    pointer_default(unique)
]

interface IInternetSecurityManagerEx : IInternetSecurityManager
{
cpp_quote("// Please see notes on IInternetSecurityManager::ProcessUrlAction")
    HRESULT     ProcessUrlActionEx
    (
        [in]    LPCWSTR     pwszUrl,
        [in]    DWORD       dwAction,
        [out, size_is(cbPolicy)]
                BYTE*   pPolicy,    // output buffer pointer
        [in]    DWORD   cbPolicy,   // output buffer size
        [in]    BYTE*   pContext,   // context (used by the delegation routines)
        [in]    DWORD   cbContext,  // size of the Context
        [in]    DWORD   dwFlags,    // See enum PUAF for details.
        [in]    DWORD   dwReserved,
        [out]   DWORD   *pdwOutFlags //See enum PUAF for details
    );

cpp_quote("// This is the wrapper function that most clients will use.")
cpp_quote("// It figures out the current Policy for the passed in Action,")
cpp_quote("// and puts up UI if the current Policy indicates that the user")
cpp_quote("// should be queried. It returns back the Policy which the caller")
cpp_quote("// will use to determine if the action should be allowed")
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
cpp_quote("#ifndef _LPINTERNETSECURITYMANANGEREx2_DEFINED")
cpp_quote("#define _LPINTERNETSECURITYMANANGEREx2_DEFINED")

[

    uuid(F1E50292-A795-4117-8E09-2B560A72AC60),
    helpstring("IInternetSecurityManagerEx2 Interface"),
    pointer_default(unique)
]

interface IInternetSecurityManagerEx2 : IInternetSecurityManagerEx
{
midl_pragma warning (disable:2495) // annotation is allowed on local interface and local methods only
    HRESULT MapUrlToZoneEx2
    (
        [in, annotation("_In_")]
                IUri*       pUri,
        [out]   DWORD*      pdwZone,
        [in]    DWORD       dwFlags,
        [out, annotation("_Outptr_opt_")]
                LPWSTR*     ppwszMappedUrl,
        [out, annotation("_Out_opt_")]
                DWORD*      pdwOutFlags
    );

cpp_quote("// Please see notes on IInternetSecurityManager::ProcessUrlAction")
    HRESULT ProcessUrlActionEx2
    (
        [in, annotation("_In_")]
                IUri*       pUri,
        [in]    DWORD       dwAction,
        [out, size_is(cbPolicy)]
                BYTE*       pPolicy,    // output buffer pointer
        [in]    DWORD       cbPolicy,   // output buffer size
        [in, unique]
                BYTE*       pContext,   // context (used by the delegation routines)
        [in]    DWORD       cbContext,  // size of the Context
        [in]    DWORD       dwFlags,    // See enum PUAF for details.
        [in]    DWORD_PTR   dwReserved,
        [out]   DWORD*      pdwOutFlags
    );

    HRESULT GetSecurityIdEx2
    (
        [in, annotation("_In_")]
                IUri*       pUri,
        [out, size_is(*pcbSecurityId), annotation("_Out_writes_bytes_to_(MAX_SIZE_SECURITY_ID, *pcbSecurityId)")]
                BYTE*       pbSecurityId,
        [in, out, annotation("_Inout_ _At_(*pcbSecurityId, _In_range_(>= , MAX_SIZE_SECURITY_ID) _Out_range_(0, MAX_SIZE_SECURITY_ID))")]
                DWORD*      pcbSecurityId,
        [in, annotation("_In_")]    DWORD_PTR   dwReserved
    );
    HRESULT QueryCustomPolicyEx2
    (
        [in, annotation("_In_")]
                IUri*       pUri,
        [in]    REFGUID     guidKey,
        [out, size_is(,*pcbPolicy)]     // allocation via IMemAlloc; caller frees
                BYTE**      ppPolicy,   // pointer to output buffer pointer
        [out]   DWORD*      pcbPolicy,  // pointer to output buffer size
        [in]    BYTE*       pContext,   // context (used by the delegation routines)
        [in]    DWORD       cbContext,  // size of the Context
        [in]    DWORD_PTR   dwReserved
    );
midl_pragma warning(default:2495)
}

cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
//  implmented by CLSID_ PersistentZoneIdentifier (along with IPersistFile)
//  to access or change the Zone attached to a local file
[
    object,
    uuid(cd45f185-1b21-48e2-967b-ead743a8914e),
    pointer_default(unique)
]
interface IZoneIdentifier : IUnknown
{
    HRESULT GetId([out] DWORD *pdwZone);
    HRESULT SetId([in] DWORD dwZone);
    HRESULT Remove();
};
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_WIN10)")
//  implemented by CLSID_PersistentZoneIdentifier (along with IPersistFile,
//  and IZoneIdentifier) to access or change the Package Family Name of the
//  last app container writer
[
    object,
    uuid(EB5E760C-09EF-45C0-B510-70830CE31E6A),
    pointer_default(unique)
]
interface IZoneIdentifier2 : IZoneIdentifier
{
    HRESULT GetLastWriterPackageFamilyName([out] LPWSTR* packageFamilyName);
    HRESULT SetLastWriterPackageFamilyName([in] LPCWSTR packageFamilyName);
    HRESULT RemoveLastWriterPackageFamilyName();

    HRESULT GetAppZoneId([out] DWORD* zone);
    HRESULT SetAppZoneId([in] DWORD zone);
    HRESULT RemoveAppZoneId();
};
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_WIN10")

cpp_quote("#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED")
cpp_quote("#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED")

cpp_quote("//This is the interface MSHTML exposes to its clients")
cpp_quote("//The clients need not pass in a URL to these functions")
cpp_quote("//since MSHTML maintains the notion of the current URL")

[

    local,
    object,
    uuid(3af280b6-cb3f-11d0-891e-00c04fb6bfc4),
    helpstring("IInternetHostSecurityManager Interface"),
    pointer_default(unique)
]

interface IInternetHostSecurityManager : IUnknown
{

    HRESULT GetSecurityId
    (
        [out, size_is(*pcbSecurityId), annotation("_Out_writes_(*pcbSecurityId)")]
                BYTE*   pbSecurityId,
        [in, out, annotation("_Inout_ _Deref_in_range_(MAX_SIZE_SECURITY_ID, UINT_MAX) _Deref_out_range_(0, MAX_SIZE_SECURITY_ID)")]
                DWORD*  pcbSecurityId,
        [in]    DWORD_PTR dwReserved
    );

cpp_quote("// Please see notes on IInternetSecurityManager::ProcessUrlAction")
    HRESULT     ProcessUrlAction
    (
        [in]    DWORD       dwAction,
        [out, size_is(cbPolicy), annotation("_Out_writes_all_(cbPolicy)")]
                BYTE*   pPolicy,    // output buffer pointer
        [in]    DWORD   cbPolicy,   // output buffer size
        [in, annotation("_In_reads_opt_(cbContext)")]    BYTE*   pContext,   // context (used by the delegation routines)
        [in]    DWORD   cbContext,  // size of the Context
        [in]    DWORD   dwFlags,    // See enum PUAF for details.
        [in]    DWORD   dwReserved
    );

    HRESULT     QueryCustomPolicy
    (
        [in]    REFGUID     guidKey,
        [out, size_is(,*pcbPolicy), annotation("_Outptr_result_buffer_all_maybenull_(*pcbPolicy)")]     // allocation via IMemAlloc; caller frees
                BYTE**  ppPolicy,   // pointer to output buffer pointer
        [out, annotation("_Out_")]   DWORD*  pcbPolicy,  // pointer to output buffer size
        [in, annotation("_In_reads_(cbContext)")]    BYTE*   pContext,   // context (used by the delegation routines)
        [in]    DWORD   cbContext,  // size of the Context
        [in]    DWORD   dwReserved
    );

};
cpp_quote("#endif")

cpp_quote("")
cpp_quote("// The zone manager maintains policies for a set of standard actions. ")
cpp_quote("// These actions are identified by integral values (called action indexes)")
cpp_quote("// specified below.")
cpp_quote("")
cpp_quote("// Minimum legal value for an action    ")
cpp_quote("#define URLACTION_MIN                                          0x00001000")
cpp_quote("")
cpp_quote("#define URLACTION_DOWNLOAD_MIN                                 0x00001000")
cpp_quote("#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001")
cpp_quote("#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004")
cpp_quote("#define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004")
cpp_quote("#define URLACTION_DOWNLOAD_MAX                                 0x000011FF")
cpp_quote("")
cpp_quote("#define URLACTION_ACTIVEX_MIN                                  0x00001200")
cpp_quote("#define URLACTION_ACTIVEX_RUN                                  0x00001200")
cpp_quote("#define URLPOLICY_ACTIVEX_CHECK_LIST                           0x00010000")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 //")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 //")
cpp_quote("#define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 //")
cpp_quote("#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 //")
cpp_quote("#define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205")
cpp_quote("#define URLACTION_ACTIVEX_NO_WEBOC_SCRIPT                      0x00001206")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION          0x00001207")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_OPTIN                       0x00001208")
cpp_quote("#define URLACTION_ACTIVEX_SCRIPTLET_RUN                        0x00001209")
cpp_quote("#define URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION           0x0000120A //")
cpp_quote("#define URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST                  0x0000120B")
cpp_quote("#define URLACTION_ACTIVEX_ALLOW_TDC                            0x0000120C")
cpp_quote("#define URLACTION_ACTIVEX_CURR_MAX                             0x0000120C")
cpp_quote("#define URLACTION_ACTIVEX_MAX                                  0x000013ff")
cpp_quote("")
cpp_quote("#define URLACTION_SCRIPT_MIN                                   0x00001400")
cpp_quote("#define URLACTION_SCRIPT_RUN                                   0x00001400")
cpp_quote("#define URLACTION_SCRIPT_JAVA_USE                              0x00001402")
cpp_quote("#define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405")
cpp_quote("#define URLACTION_CROSS_DOMAIN_DATA                            0x00001406")
cpp_quote("#define URLACTION_SCRIPT_PASTE                                 0x00001407")
cpp_quote("#define URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE                0x00001408")
cpp_quote("#define URLACTION_SCRIPT_XSSFILTER                             0x00001409")
cpp_quote("#define URLACTION_SCRIPT_NAVIGATE                              0x0000140A")
cpp_quote("#define URLACTION_PLUGGABLE_PROTOCOL_XHR                       0x0000140B")
cpp_quote("#define URLACTION_ALLOW_VBSCRIPT_IE                            0x0000140C")
cpp_quote("#define URLACTION_ALLOW_JSCRIPT_IE                             0x0000140D")
cpp_quote("#define URLACTION_SCRIPT_CURR_MAX                              0x0000140D")
cpp_quote("#define URLACTION_SCRIPT_MAX                                   0x000015ff")
cpp_quote("")
cpp_quote("#define URLACTION_HTML_MIN                                     0x00001600")
cpp_quote("#define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two")
cpp_quote("#define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 //")
cpp_quote("#define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 //")
cpp_quote("#define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604")
cpp_quote("#define URLACTION_HTML_JAVA_RUN                                0x00001605 // derive from Java custom policy")
cpp_quote("#define URLACTION_HTML_USERDATA_SAVE                           0x00001606")
cpp_quote("#define URLACTION_HTML_SUBFRAME_NAVIGATE                       0x00001607")
cpp_quote("#define URLACTION_HTML_META_REFRESH                            0x00001608")
cpp_quote("#define URLACTION_HTML_MIXED_CONTENT                           0x00001609")
cpp_quote("#define URLACTION_HTML_INCLUDE_FILE_PATH                       0x0000160A")
cpp_quote("#define URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML             0x0000160B")
cpp_quote("#define URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE          0x0000160C")
cpp_quote("#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS               0x0000160D")
cpp_quote("#define URLACTION_HTML_ALLOW_WINDOW_CLOSE                      0x0000160E")
cpp_quote("#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER            0x0000160F")
cpp_quote("#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK            0x00001610")
cpp_quote("#define URLACTION_HTML_ALLOW_INDEXEDDB                         0x00001611")
//cpp_quote("#define URLACTION_HTML_CURR_MAX                                0x00001611")
cpp_quote("#define URLACTION_HTML_MAX                                     0x000017ff")
cpp_quote("")
cpp_quote("#define URLACTION_SHELL_MIN                                    0x00001800")
cpp_quote("#define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800")
cpp_quote("#define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802")
cpp_quote("#define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803")
cpp_quote("#define URLACTION_SHELL_VERB                                   0x00001804")
cpp_quote("#define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805")
cpp_quote("#define URLACTION_SHELL_SHELLEXECUTE                           0x00001806")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
//  URLACTION_SHELL_SHELLEXECUTE and URLACTION_SHELL_EXECUTE_HIGHRISK are deliberately the same value
cpp_quote("#define URLACTION_SHELL_EXECUTE_HIGHRISK                       0x00001806")
cpp_quote("#define URLACTION_SHELL_EXECUTE_MODRISK                        0x00001807")
cpp_quote("#define URLACTION_SHELL_EXECUTE_LOWRISK                        0x00001808")
cpp_quote("#define URLACTION_SHELL_POPUPMGR                               0x00001809")
cpp_quote("#define URLACTION_SHELL_RTF_OBJECTS_LOAD                       0x0000180A")
cpp_quote("#define URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY             0x0000180B")
cpp_quote("#define URLACTION_SHELL_EXTENSIONSECURITY                      0x0000180C")
cpp_quote("#define URLACTION_SHELL_SECURE_DRAGSOURCE                      0x0000180D")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_WIN7)")
cpp_quote("#define URLACTION_SHELL_REMOTEQUERY                            0x0000180E")
cpp_quote("#define URLACTION_SHELL_PREVIEW                                0x0000180F")
cpp_quote("#define URLACTION_SHELL_SHARE                                  0x00001810")
cpp_quote("#define URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE                 0x00001811")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_WIN7)")
cpp_quote("#define URLACTION_SHELL_TOCTOU_RISK                            0x00001812")
cpp_quote("#define URLACTION_SHELL_CURR_MAX                               0x00001812")
cpp_quote("#define URLACTION_SHELL_MAX                                    0x000019ff")
cpp_quote("")
cpp_quote("#define URLACTION_NETWORK_MIN                                  0x00001A00")
cpp_quote("")
cpp_quote("#define URLACTION_CREDENTIALS_USE                              0x00001A00")
cpp_quote("#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000")
cpp_quote("#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000")
cpp_quote("#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000")
cpp_quote("#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000")
cpp_quote("")
cpp_quote("#define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01")
cpp_quote("#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000")
cpp_quote("#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000")
cpp_quote("#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000")
cpp_quote("")
cpp_quote("")
cpp_quote("#define URLACTION_COOKIES                                      0x00001A02")
cpp_quote("#define URLACTION_COOKIES_SESSION                              0x00001A03")
cpp_quote("")
cpp_quote("#define URLACTION_CLIENT_CERT_PROMPT                           0x00001A04")
cpp_quote("")
cpp_quote("#define URLACTION_COOKIES_THIRD_PARTY                          0x00001A05")
cpp_quote("#define URLACTION_COOKIES_SESSION_THIRD_PARTY                  0x00001A06")
cpp_quote("")
cpp_quote("#define URLACTION_COOKIES_ENABLED                              0x00001A10")
cpp_quote("")

cpp_quote("#define URLACTION_NETWORK_CURR_MAX                             0x00001A10")
cpp_quote("#define URLACTION_NETWORK_MAX                                  0x00001Bff")
cpp_quote("")
cpp_quote("")
cpp_quote("#define URLACTION_JAVA_MIN                                     0x00001C00")
cpp_quote("#define URLACTION_JAVA_PERMISSIONS                             0x00001C00")
cpp_quote("#define URLPOLICY_JAVA_PROHIBIT                      0x00000000")
cpp_quote("#define URLPOLICY_JAVA_HIGH                          0x00010000")
cpp_quote("#define URLPOLICY_JAVA_MEDIUM                        0x00020000")
cpp_quote("#define URLPOLICY_JAVA_LOW                           0x00030000")
cpp_quote("#define URLPOLICY_JAVA_CUSTOM                        0x00800000")
cpp_quote("#define URLACTION_JAVA_CURR_MAX                                0x00001C00")
cpp_quote("#define URLACTION_JAVA_MAX                                     0x00001Cff")

cpp_quote("")
cpp_quote("")
cpp_quote("// The following Infodelivery actions should have no default policies")
cpp_quote("// in the registry.  They assume that no default policy means fall")
cpp_quote("// back to the global restriction.  If an admin sets a policy per")
cpp_quote("// zone, then it overrides the global restriction.")
cpp_quote("")
cpp_quote("#define URLACTION_INFODELIVERY_MIN                           0x00001D00")
cpp_quote("#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00")
cpp_quote("#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01")
cpp_quote("#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02")
cpp_quote("#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03")
cpp_quote("#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04")
cpp_quote("#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05")
cpp_quote("#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06")
cpp_quote("#define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06")
cpp_quote("#define URLACTION_INFODELIVERY_MAX                           0x00001Dff")

cpp_quote("#define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00")
cpp_quote("#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05")
cpp_quote("#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000")
cpp_quote("#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000")
cpp_quote("#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000")
cpp_quote("#define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE80)")
cpp_quote("#define URLACTION_DOTNET_USERCONTROLS                        0x00002005")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE80)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#define URLACTION_BEHAVIOR_MIN                               0x00002000")
cpp_quote("#define URLACTION_BEHAVIOR_RUN                               0x00002000")
cpp_quote("#define URLPOLICY_BEHAVIOR_CHECK_LIST                        0x00010000")
cpp_quote("")
cpp_quote("// The following actions correspond to the Feature options above." )
cpp_quote("// However, they are NOT in the same order." )
cpp_quote("#define URLACTION_FEATURE_MIN                                0x00002100")
cpp_quote("#define URLACTION_FEATURE_MIME_SNIFFING                      0x00002100")
cpp_quote("#define URLACTION_FEATURE_ZONE_ELEVATION                     0x00002101")
cpp_quote("#define URLACTION_FEATURE_WINDOW_RESTRICTIONS                0x00002102")
cpp_quote("#define URLACTION_FEATURE_SCRIPT_STATUS_BAR                  0x00002103")
cpp_quote("#define URLACTION_FEATURE_FORCE_ADDR_AND_STATUS              0x00002104")
cpp_quote("#define URLACTION_FEATURE_BLOCK_INPUT_PROMPTS                0x00002105")
cpp_quote("#define URLACTION_FEATURE_DATA_BINDING                       0x00002106")
cpp_quote("#define URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE           0x00002107")
cpp_quote("")

cpp_quote("#define URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN                  0x00002200")
cpp_quote("#define URLACTION_AUTOMATIC_DOWNLOAD_UI                      0x00002200")
cpp_quote("#define URLACTION_AUTOMATIC_ACTIVEX_UI                       0x00002201")
cpp_quote("")

cpp_quote("#define URLACTION_ALLOW_RESTRICTEDPROTOCOLS                0x00002300")
cpp_quote("")

cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("// Whether to do the Anti-Phishing check." )
cpp_quote("#define URLACTION_ALLOW_APEVALUATION                       0x00002301")
cpp_quote("#define URLACTION_ALLOW_XHR_EVALUATION                     0x00002302")
cpp_quote("")

cpp_quote("// The following ExpressAPP and XPS actions are trumped by registry in")
cpp_quote("// case of Internet Explorer upgrade from IE 6.0 which honors registry.")
cpp_quote("#define URLACTION_WINDOWS_BROWSER_APPLICATIONS             0x00002400")
cpp_quote("#define URLACTION_XPS_DOCUMENTS                            0x00002401")
cpp_quote("#define URLACTION_LOOSE_XAML                               0x00002402")
cpp_quote("#define URLACTION_LOWRIGHTS                                0x00002500")
cpp_quote("// The following action belong to WinFX Bootstrapper")
cpp_quote("#define URLACTION_WINFX_SETUP                              0x00002600")
cpp_quote("")
cpp_quote("#define URLACTION_INPRIVATE_BLOCKING                       0x00002700")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_AUDIO_VIDEO                        0x00002701")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_ACTIVEX_FILTERING                  0x00002702")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING        0x00002703")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS                0x00002704")
cpp_quote("")

cpp_quote("// The following two URLACTIONs each have as their context parameter a string that is the destination URI.")
cpp_quote("#define URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT         0x00002705")
cpp_quote("#define URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION    0x00002706")
cpp_quote("")


cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW     0x00002708")
cpp_quote("#define URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS    0x00002709")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST      0x0000270A")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS           0x0000270B")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_ANTIMALWARE_SCANNING_OF_ACTIVEX    0x0000270C")
cpp_quote("")

cpp_quote("")
cpp_quote("#define URLACTION_ALLOW_CSS_EXPRESSIONS                    0x0000270D")
cpp_quote("")

cpp_quote("// For each action specified above the system maintains")
cpp_quote("// a set of policies for the action. ")
cpp_quote("// The only policies supported currently are permissions (i.e. is something allowed)")
cpp_quote("// and logging status. ")
cpp_quote("// IMPORTANT: If you are defining your own policies don't overload the meaning of the")
cpp_quote("// loword of the policy. You can use the hiword to store any policy bits which are only")
cpp_quote("// meaningful to your action.")
cpp_quote("// For an example of how to do this look at the URLPOLICY_JAVA above")
cpp_quote("")
cpp_quote("// Permissions ")
cpp_quote("#define URLPOLICY_ALLOW                0x00")
cpp_quote("#define URLPOLICY_QUERY                0x01")
cpp_quote("#define URLPOLICY_DISALLOW             0x03")
cpp_quote("")
cpp_quote("// Notifications are not done when user already queried.")  // CUT
cpp_quote("#define URLPOLICY_NOTIFY_ON_ALLOW      0x10")
cpp_quote("#define URLPOLICY_NOTIFY_ON_DISALLOW   0x20")
cpp_quote("")
cpp_quote("// Logging is done regardless of whether user was queried.") // CUT
cpp_quote("#define URLPOLICY_LOG_ON_ALLOW         0x40")
cpp_quote("#define URLPOLICY_LOG_ON_DISALLOW      0x80")
cpp_quote("")
cpp_quote("#define URLPOLICY_MASK_PERMISSIONS     0x0f")
cpp_quote("#define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS)")
cpp_quote("#define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))")
cpp_quote("")
cpp_quote("")
cpp_quote("#define URLPOLICY_DONTCHECKDLGBOX     0x100")

cpp_quote("// The ordinal #'s that define the predefined zones internet explorer knows about. ")
cpp_quote("// When we support user-defined zones their zone numbers should be between ")
cpp_quote("// URLZONE_USER_MIN and URLZONE_USER_MAX")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
cpp_quote("// Custom policy to query whether the local machine zone")
cpp_quote("// has been unlocked for current document.")
cpp_quote("EXTERN_C const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED; ")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IInternetZoneManager interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPINTERNETZONEMANAGER_DEFINED")
cpp_quote("#define _LPINTERNETZONEMANAGER_DEFINED")

[

    local,
    object,
    uuid(79eac9ef-baf9-11ce-8c82-00aa004ba90b),
    helpstring("IInternetZoneManager Interface"),
    pointer_default(unique)
]

interface IInternetZoneManager : IUnknown
{
    typedef [unique] IInternetZoneManager *LPURLZONEMANAGER;


    typedef enum tagURLZONE
    {
        URLZONE_INVALID = -1,               // Invalid Zone. Should only be used if no appropriate zone available.
        URLZONE_PREDEFINED_MIN = 0,
        URLZONE_LOCAL_MACHINE  = 0,         // local machine zone is not exposed in UI
        URLZONE_INTRANET,                   // My Intranet zone
        URLZONE_TRUSTED,                    // Trusted Web sites zone
        URLZONE_INTERNET,                   // The Internet zone
        URLZONE_UNTRUSTED,                  // Untrusted sites zone
        URLZONE_PREDEFINED_MAX = 999,

        URLZONE_USER_MIN = 1000,
        URLZONE_USER_MAX = 10000,
    }  URLZONE;

cpp_quote("// Enhanced Security Configuration zone mapping flag for IInternetSecurityManager::SetZoneMapping")
cpp_quote("#define URLZONE_ESC_FLAG     0x100")

    typedef enum tagURLTEMPLATE
    {
        // This value is just used to indicate the current set
        // of policies are not based on any template.
        URLTEMPLATE_CUSTOM  =   0x000000,

        URLTEMPLATE_PREDEFINED_MIN =    0x10000,
        URLTEMPLATE_LOW =               0x10000,
        URLTEMPLATE_MEDLOW =            0x10500,
        URLTEMPLATE_MEDIUM =            0x11000,
        URLTEMPLATE_MEDHIGH =           0x11500,
        URLTEMPLATE_HIGH  =             0x12000,
        URLTEMPLATE_PREDEFINED_MAX =    0x20000
    } URLTEMPLATE ;



    enum { MAX_ZONE_PATH = 260, MAX_ZONE_DESCRIPTION = 200 };

    typedef enum {
        ZAFLAGS_CUSTOM_EDIT                 = 0x00000001,
        ZAFLAGS_ADD_SITES                   = 0x00000002,
        ZAFLAGS_REQUIRE_VERIFICATION        = 0x00000004,
        ZAFLAGS_INCLUDE_PROXY_OVERRIDE      = 0x00000008,  // Intranet only.
        ZAFLAGS_INCLUDE_INTRANET_SITES      = 0x00000010,  // Intranet only.
        ZAFLAGS_NO_UI                       = 0x00000020,  // Don't display UI (used for local machine)
        ZAFLAGS_SUPPORTS_VERIFICATION       = 0x00000040,  // Supports server verification.
        ZAFLAGS_UNC_AS_INTRANET             = 0x00000080,
        ZAFLAGS_DETECT_INTRANET             = 0x00000100,  // Intranet only.

        // Locked/Unlocked state specific flags.
        ZAFLAGS_USE_LOCKED_ZONES            = 0x00010000,
        // Used ONLY in GetZoneAttributes to specify that Template Matching should be done to verify
        // that zone's Current Level is correct.
        ZAFLAGS_VERIFY_TEMPLATE_SETTINGS    = 0x00020000,
        // Bypass the zonemgr cache for this setting
        ZAFLAGS_NO_CACHE                    = 0x00040000,
    } ZAFLAGS ;

    typedef struct _ZONEATTRIBUTES
    {
        ULONG   cbSize;
        WCHAR   szDisplayName[MAX_ZONE_PATH];
        WCHAR   szDescription[MAX_ZONE_DESCRIPTION];
        WCHAR   szIconPath[MAX_ZONE_PATH];
        DWORD   dwTemplateMinLevel;
        DWORD   dwTemplateRecommended;
        DWORD   dwTemplateCurrentLevel;
        DWORD   dwFlags;                     // ZAFLAGS.
    } ZONEATTRIBUTES, *LPZONEATTRIBUTES;

    HRESULT GetZoneAttributes
    (
        [in]    DWORD   dwZone,
        [in, out, unique, annotation("_Inout_")]
                ZONEATTRIBUTES* pZoneAttributes
    );

cpp_quote("// Gets the zone attributes (information in registry other than actual security")
cpp_quote("// policies associated with the zone).  Zone attributes are fixed as:")


    HRESULT    SetZoneAttributes
    (
        [in]    DWORD   dwZone,
        [in, annotation("_In_")]    ZONEATTRIBUTES* pZoneAttributes
    );
cpp_quote("// Sets the zone attributes (information in registry other than actual security")
cpp_quote("// policies associated with the zone).  Zone attributes as above.")
cpp_quote("// Returns S_OK or ??? if failed to write the zone attributes.")


cpp_quote("/* Registry Flags")
cpp_quote("")
cpp_quote("    When reading, default behavior is:")
cpp_quote("        If HKLM allows override and HKCU value exists")
cpp_quote("            Then use HKCU value")
cpp_quote("            Else use HKLM value")
cpp_quote("    When writing, default behavior is same as HKCU")
cpp_quote("        If HKLM allows override")
cpp_quote("           Then Write to HKCU")
cpp_quote("           Else Fail")
cpp_quote("*/")

    typedef enum _URLZONEREG
    {
        URLZONEREG_DEFAULT=0,
        URLZONEREG_HKLM,
        URLZONEREG_HKCU
    } URLZONEREG;

    HRESULT GetZoneCustomPolicy
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    REFGUID guidKey,    // key to lookup value
        [out, size_is(,*pcbPolicy), annotation("_Outptr_result_buffer_(*pcbPolicy)")]     // allocation via IMemAlloc; caller frees
                BYTE**  ppPolicy,   // pointer to output buffer pointer
        [out, annotation("_Out_")]   DWORD*  pcbPolicy,  // pointer to output buffer size
        [in]    URLZONEREG  urlZoneReg    // effective, HKCU, or HKLM
    );

cpp_quote("// Gets a named custom policy associated with a zone;")
cpp_quote("// e.g. the Java VM settings can be defined with a unique key such as 'Java'.")
cpp_quote("// Custom policy support is intended to allow extensibility from the predefined")
cpp_quote("// set of policies that IE4 has built in.")
cpp_quote("// ")
cpp_quote("// pwszKey is the string name designating the custom policy.  Components are")
cpp_quote("//   responsible for having unique names.")
cpp_quote("// ppPolicy is the callee allocated buffer for the policy byte blob; caller is")
cpp_quote("//   responsible for freeing this buffer eventually.")
cpp_quote("// pcbPolicy is the size of the byte blob returned.")
cpp_quote("// dwRegFlags determines how registry is accessed (see above).")
cpp_quote("// Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced).")

    HRESULT SetZoneCustomPolicy
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    REFGUID guidKey,    // key to lookup value
        [in, size_is(cbPolicy), annotation("_In_reads_(cbPolicy)")]
                BYTE*   pPolicy,    // input buffer pointer
        [in]    DWORD   cbPolicy,   // input data size
        [in]    URLZONEREG urlZoneReg    // default, HKCU, or HKLM
    );
cpp_quote("// Sets a named custom policy associated with a zone;")
cpp_quote("// e.g. the Java VM settings can be defined with a unique key such as 'Java'.")
cpp_quote("// Custom policy support is intended to allow extensibility from the predefined")
cpp_quote("// set of policies that IE4 has built in.  ")
cpp_quote("// ")
cpp_quote("// pwszKey is the string name designating the custom policy.  Components are")
cpp_quote("//   responsible for having unique names.")
cpp_quote("// ppPolicy is the caller allocated buffer for the policy byte blob.")
cpp_quote("// pcbPolicy is the size of the byte blob to be set.")
cpp_quote("// dwRegFlags determines if HTCU or HKLM is set.")
cpp_quote("// Returns S_OK or ??? if failed to write the zone custom policy.")


    HRESULT GetZoneActionPolicy
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    DWORD   dwAction,   // index number of action
        [out, size_is(cbPolicy), annotation("_Out_writes_(cbPolicy)")]
                BYTE*   pPolicy,    // output buffer pointer
        [in]    DWORD   cbPolicy,    // output buffer size
        [in]    URLZONEREG urlZoneReg // effective, HKCU, or HKLM
    );

cpp_quote("// Gets action policy associated with a zone, the builtin, fixed-length policies info.")
cpp_quote("")
cpp_quote("// dwAction is the action code for the action as defined above.")
cpp_quote("// pPolicy is the caller allocated buffer for the policy data.")
cpp_quote("// cbPolicy is the size of the caller allocated buffer.")
cpp_quote("// dwRegFlags determines how registry is accessed (see above).")
cpp_quote("// Returns S_OK if action is valid; ??? if action is not valid.")

    HRESULT SetZoneActionPolicy
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    DWORD   dwAction,   // index number of action
        [in, size_is(cbPolicy), annotation("_In_reads_(cbPolicy)")]
                BYTE*   pPolicy,    // input buffer pointer
        [in]    DWORD   cbPolicy,    // input data size
        [in]    URLZONEREG urlZoneReg // HKCU, or HKLM
    );
// Sets action policy associated with a zone, the builtin, fixed-length policies info.
//
// dwAction is the action code as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.


// UI, logging, and wrapper for both
// This function is not implemented yet.
    HRESULT PromptAction
    (
        [in]    DWORD   dwAction,                    // action type
        [in]    HWND    hwndParent,                    // parent window handle
        [in]    LPCWSTR pwszUrl,                    // URL to display
        [in]    LPCWSTR pwszText,                    // dialog text
        [in]    DWORD   dwPromptFlags                // reserved, pass 0
    );
// This method presents UI to ask user about specified action


// This function is not implemented.
    HRESULT LogAction
    (
        [in]    DWORD   dwAction,       // action type
        [in]    LPCWSTR pwszUrl,        // URL to log
        [in]    LPCWSTR pwszText,       // associated text
        [in]    DWORD   dwLogFlags      // reserved, pass 0
    );


// zone enumeration

    HRESULT CreateZoneEnumerator
    (
        [out]   DWORD*  pdwEnum,        // enum handle
        [out]   DWORD*  pdwCount,       // # of elements in the list.
        [in]    DWORD   dwFlags         // reserved, pass 0
    );
// Returns enumerator handle needed to enumerate defined zones.
// The zone enumeration corresponds to a snap-shot of the zones when
// the Create call is made.

    HRESULT    GetZoneAt
    (
        [in]    DWORD    dwEnum,         // returned by CreateZoneEnumerator
        [in]    DWORD    dwIndex,        // 0-based
        [out]   DWORD*    pdwZone        // absolute zone index.
    );


    HRESULT DestroyZoneEnumerator
    (
        [in]    DWORD   dwEnum         // enum handle
    );
// Destroys resources associated with an enumerator


    HRESULT     CopyTemplatePoliciesToZone
    (
        [in]    DWORD dwTemplate,       // High, medium or low
        [in]    DWORD dwZone,           // Zone to copy policies to.
        [in]    DWORD dwReserved
    );

}
cpp_quote("#endif")


cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE60SP2)")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-2004.
//
//  Contents:   IInternetZoneManagerEx interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPINTERNETZONEMANAGEREX_DEFINED")
cpp_quote("#define _LPINTERNETZONEMANAGEREX_DEFINED")

[

    local,
    object,
    uuid(A4C23339-8E06-431e-9BF4-7E711C085648),
    helpstring("IInternetZoneManagerEx Interface"),
    pointer_default(unique)
]

interface IInternetZoneManagerEx : IInternetZoneManager
{
    HRESULT GetZoneActionPolicyEx
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    DWORD   dwAction,   // index number of action
        [out, size_is(cbPolicy), annotation("_Out_writes_(cbPolicy)")]
                BYTE*   pPolicy,    // output buffer pointer
        [in]    DWORD   cbPolicy,    // output buffer size
        [in]    URLZONEREG urlZoneReg, // effective, HKCU, or HKLM
        [in]    DWORD    dwFlags   //Lockdown Zones or Normal Zones via ZAFLAGS
    );

cpp_quote("// Gets action policy associated with a zone, the builtin, fixed-length policies info.")
cpp_quote("")
cpp_quote("// dwAction is the action code for the action as defined above.")
cpp_quote("// pPolicy is the caller allocated buffer for the policy data.")
cpp_quote("// cbPolicy is the size of the caller allocated buffer.")
cpp_quote("// dwRegFlags determines how registry is accessed (see above).")
cpp_quote("// dwFlags determine which registry policies are accessed (see above).")
cpp_quote("// Returns S_OK if action is valid; ??? if action is not valid.")

    HRESULT SetZoneActionPolicyEx
    (
        [in]    DWORD   dwZone,     // zone index
        [in]    DWORD   dwAction,   // index number of action
        [in, size_is(cbPolicy), annotation("_In_reads_(cbPolicy)")]
                BYTE*   pPolicy,    // input buffer pointer
        [in]    DWORD   cbPolicy,    // input data size
        [in]    URLZONEREG urlZoneReg, // HKCU, or HKLM
        [in]    DWORD    dwFlags   //Lockdown Zones or Normal Zones via ZAFLAGS
    );
// Sets action policy associated with a zone, the builtin, fixed-length policies info.
//
// dwAction is the action code as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// urlZoneReg determines how registry is accessed (see above).
// dwFlags determine which registry policies are accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)")

cpp_quote("#if (_WIN32_IE >= _WIN32_IE_IE70)")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-2004.
//
//  Contents:   IInternetZoneManagerEx2 interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED")
cpp_quote("#define _LPINTERNETZONEMANAGEREX2_DEFINED")

cpp_quote("#define SECURITY_IE_STATE_GREEN 0x00000000")
cpp_quote("#define SECURITY_IE_STATE_RED   0x00000001")

[

    local,
    object,
    uuid(EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF),
    helpstring("IInternetZoneManagerEx2 Interface"),
    pointer_default(unique)
]

interface IInternetZoneManagerEx2 : IInternetZoneManagerEx
{
    HRESULT GetZoneAttributesEx
    (
        [in]    DWORD   dwZone,
        [in, out, unique]
                ZONEATTRIBUTES* pZoneAttributes,
        [in]    DWORD    dwFlags // can only be ZAFLAGS_VERIFY_TEMPLATE_SETTINGS
    );

    HRESULT GetZoneSecurityState
    (
        [in] DWORD dwZoneIndex,
        [in] BOOL fRespectPolicy,
        [in, out] LPDWORD pdwState,
        [in, out] BOOL* pfPolicyEncountered
    );

    HRESULT GetIESecurityState
    (
        [in] BOOL fRespectPolicy,
        [in, out] LPDWORD pdwState,
        [in, out] BOOL* pfPolicyEncountered,
        [in] BOOL fNoCache
    );

    HRESULT FixUnsecureSettings();

cpp_quote("// Gets the zone attributes (information in registry other than actual security")
cpp_quote("// policies associated with the zone).  Zone attributes are fixed as:")
cpp_quote("// Can also verify template settings by matching current settings with security template")
}
cpp_quote("#endif")
cpp_quote("#endif //(_WIN32_IE >= _WIN32_IE_IE70)")

cpp_quote("EXTERN_C const IID CLSID_SoftDistExt;  ")
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   ISoftDistExt interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPSOFTDISTEXT_DEFINED")
cpp_quote("#define _LPSOFTDISTEXT_DEFINED")

cpp_quote("")
cpp_quote("#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001")
cpp_quote("#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002")
cpp_quote("#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004")
cpp_quote("#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008")
cpp_quote("")
cpp_quote("")
cpp_quote("#define SOFTDIST_ADSTATE_NONE                0x00000000")
cpp_quote("#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001")
cpp_quote("#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002")
cpp_quote("#define SOFTDIST_ADSTATE_INSTALLED           0x00000003")
cpp_quote("")
typedef struct _tagCODEBASEHOLD
{
     ULONG cbSize;
     LPWSTR szDistUnit;
     LPWSTR szCodeBase;
     DWORD dwVersionMS;
     DWORD dwVersionLS;
     DWORD dwStyle;
} CODEBASEHOLD, *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
{
    ULONG       cbSize;
    DWORD       dwFlags;
        DWORD   dwAdState;
    LPWSTR      szTitle;
    LPWSTR      szAbstract;
    LPWSTR  szHREF;
    DWORD   dwInstalledVersionMS;
    DWORD   dwInstalledVersionLS;
    DWORD   dwUpdateVersionMS;
    DWORD   dwUpdateVersionLS;
    DWORD   dwAdvertisedVersionMS;
    DWORD   dwAdvertisedVersionLS;
    DWORD       dwReserved;
} SOFTDISTINFO, *LPSOFTDISTINFO;

[

    local,
    object,
    uuid(B15B8DC1-C7E1-11d0-8680-00AA00BDCB71),
    helpstring("ISoftDistExt Interface"),
    pointer_default(unique)
]

interface ISoftDistExt : IUnknown
{

    HRESULT ProcessSoftDist
    (
        [in]    LPCWSTR szCDFURL,
        [in]    IXMLElement *pSoftDistElement,
        [in, out]    LPSOFTDISTINFO lpsdi
    );


    HRESULT GetFirstCodeBase
    (
        [in, annotation("__RPC__in")]    LPWSTR *szCodeBase,
        [in]    LPDWORD dwMaxSize
    );

    HRESULT GetNextCodeBase
    (
        [in, annotation("__RPC__in")]    LPWSTR *szCodeBase,
        [in]    LPDWORD dwMaxSize
    );

    HRESULT AsyncInstallDistributionUnit
    (
        [in]    IBindCtx *pbc,
        [in]    LPVOID pvReserved,
        [in]    DWORD flags,
        [in]    LPCODEBASEHOLD lpcbh
    );

}

cpp_quote("STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, _Out_ LPSOFTDISTINFO psdi );")
cpp_quote("STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );")

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   ICatalogFileInfo interface definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPCATALOGFILEINFO_DEFINED")
cpp_quote("#define _LPCATALOGFILEINFO_DEFINED")

[
    local,
    object,
    uuid(711C7600-6B48-11d1-B403-00AA00B92AF1),
    pointer_default(unique)
]


interface ICatalogFileInfo : IUnknown
{

    typedef [unique] ICatalogFileInfo *LPCATALOGFILEINFO;

    HRESULT GetCatalogFile(
            [out, annotation("__RPC__out")] LPSTR *ppszCatalogFile    // Catalog file path
            );
    HRESULT GetJavaTrust(
            [out] void **ppJavaTrust  // Java Trust structure
            );

}

cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IDataFilter definition
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _LPDATAFILTER_DEFINED")
cpp_quote("#define _LPDATAFILTER_DEFINED")

[
        object,
        uuid(69d14c80-c18e-11d0-a9ce-006097942311),
        pointer_default(unique)
]

interface IDataFilter: IUnknown
{
        typedef [unique] IDataFilter *LPDATAFILTER;

        HRESULT DoEncode(
            [in]    DWORD                   dwFlags,
            [in]    LONG                    lInBufferSize,
            [in, size_is(lInBufferSize)]
                    BYTE*                   pbInBuffer,
            [in]    LONG                    lOutBufferSize,
            [out, size_is(lOutBufferSize)]
                    BYTE*                   pbOutBuffer,
            [in]    LONG                    lInBytesAvailable,
            [out]   LONG*                   plInBytesRead,
            [out]   LONG*                   plOutBytesWritten,
            [in]    DWORD                   dwReserved
            );

        HRESULT DoDecode(
            [in]    DWORD                   dwFlags,
            [in]    LONG                    lInBufferSize,
            [in, size_is(lInBufferSize)]
                    BYTE*                   pbInBuffer,
            [in]    LONG                    lOutBufferSize,
            [out, size_is(lOutBufferSize)]
                    BYTE*                   pbOutBuffer,
            [in]    LONG                    lInBytesAvailable,
            [out]   LONG*                   plInBytesRead,
            [out]   LONG*                   plOutBytesWritten,
            [in]    DWORD                   dwReserved
            );

        HRESULT SetEncodingLevel(
            [in]   DWORD                    dwEncLevel
            );

}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   IEncodingFilterFactory definition
//
//---------------------------------------------------------------------------

cpp_quote("#ifndef _LPENCODINGFILTERFACTORY_DEFINED")
cpp_quote("#define _LPENCODINGFILTERFACTORY_DEFINED")

typedef struct _tagPROTOCOLFILTERDATA
{
    DWORD                   cbSize;
    IInternetProtocolSink   *pProtocolSink;  // out parameter
    IInternetProtocol       *pProtocol;      // in parameter
    IUnknown                *pUnk;
    DWORD                   dwFilterFlags;
} PROTOCOLFILTERDATA;


[
        local,
        object,
        uuid(70bdde00-c18e-11d0-a9ce-006097942311),
        pointer_default(unique)
]

interface IEncodingFilterFactory : IUnknown
{
        typedef [unique] IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

        typedef struct _tagDATAINFO
        {
            ULONG   ulTotalSize;
            ULONG   ulavrPacketSize;
            ULONG   ulConnectSpeed;
            ULONG   ulProcessorSpeed;
        } DATAINFO ;


        HRESULT FindBestFilter(
            [in]    LPCWSTR                 pwzCodeIn,
            [in]    LPCWSTR                 pwzCodeOut,
            [in]    DATAINFO                info,
            [out]   IDataFilter**           ppDF
            );

        HRESULT GetDefaultFilter(
            [in]    LPCWSTR                 pwzCodeIn,
            [in]    LPCWSTR                 pwzCodeOut,
            [out]   IDataFilter**           ppDF
            );

}
cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1995-1998.
//
//  Contents:   Hit Logging Apis definition
//
//---------------------------------------------------------------------------

cpp_quote("#ifndef _HITLOGGING_DEFINED")
cpp_quote("#define _HITLOGGING_DEFINED")

cpp_quote("// Logging-specific apis")
#pragma midl_echo("BOOL WINAPI IsLoggingEnabledA(_In_ LPCSTR  pszUrl);                    ")
#pragma midl_echo("BOOL WINAPI IsLoggingEnabledW(_In_ LPCWSTR  pwszUrl);                  ")

cpp_quote("#ifdef UNICODE                                                       ")
cpp_quote("#define IsLoggingEnabled         IsLoggingEnabledW                   ")
cpp_quote("#else                                                                ")
cpp_quote("#define IsLoggingEnabled         IsLoggingEnabledA                   ")
cpp_quote("#endif // !UNICODE                                                   ")

// HIT_LOGGING_INFO
typedef struct _tagHIT_LOGGING_INFO {
                            DWORD dwStructSize;
                                LPSTR lpszLoggedUrlName;
                        SYSTEMTIME StartTime;
                                SYSTEMTIME EndTime;
                                LPSTR lpszExtendedInfo;
                                } HIT_LOGGING_INFO, * LPHIT_LOGGING_INFO;

#pragma midl_echo("BOOL WINAPI WriteHitLogging(_In_ LPHIT_LOGGING_INFO lpLogginginfo);    ")

cpp_quote("#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001")

struct CONFIRMSAFETY
{
    CLSID       clsid;
    IUnknown *  pUnk;
    DWORD       dwFlags;
};

cpp_quote("EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; ")

cpp_quote("#endif")


//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2000.
//
//  Contents:   IWrappedProtocol definition
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _LPIWRAPPEDPROTOCOL_DEFINED")
cpp_quote("#define _LPIWRAPPEDPROTOCOL_DEFINED")
[
        local,
        object,
        uuid(53c84785-8425-4dc5-971b-e58d9c19f9b6),
        pointer_default(unique)
]

interface IWrappedProtocol : IUnknown
{
        typedef [unique] IWrappedProtocol *LPIWRAPPEDPROTOCOL;

        HRESULT GetWrapperCode(
            [out] LONG * pnCode,
            [in]  DWORD_PTR dwReserved
            );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2011.
//
//  IGetBindHandle
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _LPGETBINDHANDLE_DEFINED")
cpp_quote("#define _LPGETBINDHANDLE_DEFINED")
[
    local,
    object,
    uuid(AF0FF408-129D-4b20-91F0-02BD23D88352),
    pointer_default(unique)
]
interface IGetBindHandle: IUnknown
{
    typedef [unique] IGetBindHandle *LPGETBINDHANDLE;

    typedef enum
    {
            BINDHANDLETYPES_APPCACHE              = 0x00000000,
            BINDHANDLETYPES_DEPENDENCY            = 0x00000001,
            BINDHANDLETYPES_COUNT
    } BINDHANDLETYPES;

    HRESULT GetBindHandle(
            [in] BINDHANDLETYPES enumRequestedHandle,
            [out] HANDLE *pRetHandle
            );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2010.
//
//  Contents:   XHR Pluggable Protocol Argument definition
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _XHRPLUGGABLEPROTOCOL_DEFINED")
cpp_quote("#define _XHRPLUGGABLEPROTOCOL_DEFINED")

typedef struct _tagPROTOCOL_ARGUMENT
{
    LPCWSTR szMethod;
    LPCWSTR szTargetUrl;
} PROTOCOL_ARGUMENT, *LPPROTOCOL_ARGUMENT;
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  IBindCallbackRedirect definition.
//
//---------------------------------------------------------------------------
cpp_quote("#ifndef _LPBINDCALLBACKREDIRECT_DEFINED")
cpp_quote("#define _LPBINDCALLBACKREDIRECT_DEFINED")
[
        local,
        object,
        uuid(11C81BC2-121E-4ed5-B9C4-B430BD54F2C0),
        pointer_default(unique)
]
interface IBindCallbackRedirect : IUnknown
{
    typedef [unique] IBindCallbackRedirect *LPBINDCALLBACKREDIRECT;

    HRESULT Redirect(
            [in] LPCWSTR lpcUrl,
            [out] VARIANT_BOOL *vbCancel
            );
}
cpp_quote("#endif")

//+---------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Contents:   IBindHttpSecurity definition
//
//----------------------------------------------------------------------------
cpp_quote("#ifndef _LPIBINDHTTPSECURITY_DEFINED")
cpp_quote("#define _LPIBINDHTTPSECURITY_DEFINED")
[
    object,
    uuid(a9eda967-f50e-4a33-b358-206f6ef3086d),
    helpstring("IBindHttpSecurity Interface")
]
interface IBindHttpSecurity : IUnknown
{
    HRESULT GetIgnoreCertMask(
        [out, ref] DWORD *pdwIgnoreCertMask
    );
}
cpp_quote("#endif") //_LPIBINDHTTPSECURITY_DEFINED

cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

cpp_quote("#if _MSC_VER >= 1200")
cpp_quote("#pragma warning(pop)")
cpp_quote("#endif")
