//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************
//
cpp_quote( "//=========================================================================" )
cpp_quote( "//" )
cpp_quote( "// Microsoft Windows Media Technologies" )
cpp_quote( "// Copyright (C) Microsoft Corporation.  All Rights Reserved." )
cpp_quote( "//" )
cpp_quote( "//=========================================================================" )

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and constants used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Imports, typedefs and forward declarations
//
cpp_quote("#include <winapifamily.h>")

#pragma region Desktop Family
cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

import "oaidl.idl";
import "wmsbuffer.idl";

typedef unsigned __int64 QWORD;

//
// Forward declarations of a few interfaces, so that things compile:
//
interface IWMMediaProps;
interface IWMVideoMediaProps;

interface IWMWriter;
interface IWMInputMediaProps;

interface IWMReader;
interface IWMOutputMediaProps;

interface IWMReaderCallback;

interface IWMMetadataEditor;
interface IWMMetadataEditor2;
interface IWMDRMEditor;

interface IWMHeaderInfo;

interface IWMProfile;
interface IWMProfileManager;
interface IWMStreamConfig;
interface IWMStreamList;
interface IWMMutualExclusion;
interface IWMBandwidthSharing;
interface IWMStreamPrioritization;
interface IWMPacketSize;
interface IWMPacketSize2;

interface IWMWriterAdvanced;
interface IWMWriterAdvanced2;
interface IWMWriterAdvanced3;
interface IWMWriterPreprocess;
interface IWMWriterSink;
interface IWMWriterFileSink;
interface IWMWriterNetworkSink;
interface IWMDRMWriter;
interface IWMDRMWriter2;
interface IWMDRMWriter3;

interface IWMReaderAdvanced;
interface IWMReaderAdvanced2;
interface IWMReaderAdvanced3;
interface IWMReaderAdvanced4;
interface IWMReaderAdvanced5;
interface IWMReaderAdvanced6;
interface IWMPlayerHook;
interface IWMReaderCallbackAdvanced;
interface IWMDRMReader;
interface IWMDRMReader2;
interface IWMDRMReader3;
interface IWMReaderPlaylistBurn;

interface IWMReaderAllocatorEx;

interface IWMReaderNetworkConfig;
interface IWMReaderNetworkConfig2;

interface IWMLicenseBackup;
interface IWMLicenseRestore;
interface IWMBackupRestoreProps;

interface IWMCodecInfo;
interface IWMCodecInfo2;
interface IWMCodecInfo3;

interface IWMSyncReader;

interface IWMLanguageList;

interface IWMImageInfo;
interface IWMAddressAccess;
interface IWMAddressAccess2;

interface IWMDeviceRegistration;
interface IWMRegisteredDevice;
interface IWMProximityDetection;
interface IWMDRMMessageParser;
interface IWMDRMTranscryptor;
interface IWMDRMTranscryptor2;
interface IWMDRMTranscryptionManager;
interface IWMLicenseRevocationAgent;


///////////////////////////////////////////////////////////////////////////////
//
// Attributes
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the special case attributes that give information " )
cpp_quote( "// about the Windows Media file." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMSpecialAttributes = 20;" )
cpp_quote( "static const WCHAR g_wszWMDuration[] =L\"Duration\";" )
cpp_quote( "static const WCHAR g_wszWMBitrate[] =L\"Bitrate\";" )
cpp_quote( "static const WCHAR g_wszWMSeekable[] =L\"Seekable\";" )
cpp_quote( "static const WCHAR g_wszWMStridable[] =L\"Stridable\";" )
cpp_quote( "static const WCHAR g_wszWMBroadcast[] =L\"Broadcast\";" )
cpp_quote( "static const WCHAR g_wszWMProtected[] =L\"Is_Protected\";" )
cpp_quote( "static const WCHAR g_wszWMTrusted[] =L\"Is_Trusted\";" )
cpp_quote( "static const WCHAR g_wszWMSignature_Name[] =L\"Signature_Name\";" )
cpp_quote( "static const WCHAR g_wszWMHasAudio[] =L\"HasAudio\";" )
cpp_quote( "static const WCHAR g_wszWMHasImage[] =L\"HasImage\";" )
cpp_quote( "static const WCHAR g_wszWMHasScript[] =L\"HasScript\";" )
cpp_quote( "static const WCHAR g_wszWMHasVideo[] =L\"HasVideo\";" )
cpp_quote( "static const WCHAR g_wszWMCurrentBitrate[] =L\"CurrentBitrate\";" )
cpp_quote( "static const WCHAR g_wszWMOptimalBitrate[] =L\"OptimalBitrate\";" )
cpp_quote( "static const WCHAR g_wszWMHasAttachedImages[] =L\"HasAttachedImages\";" )
cpp_quote( "static const WCHAR g_wszWMSkipBackward[] =L\"Can_Skip_Backward\";" )
cpp_quote( "static const WCHAR g_wszWMSkipForward[] =L\"Can_Skip_Forward\";" )
cpp_quote( "static const WCHAR g_wszWMNumberOfFrames[] =L\"NumberOfFrames\";" )
cpp_quote( "static const WCHAR g_wszWMFileSize[] =L\"FileSize\";" )
cpp_quote( "static const WCHAR g_wszWMHasArbitraryDataStream[] =L\"HasArbitraryDataStream\";" )
cpp_quote( "static const WCHAR g_wszWMHasFileTransferStream[] =L\"HasFileTransferStream\";" )
cpp_quote( "static const WCHAR g_wszWMContainerFormat[] =L\"WM/ContainerFormat\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The content description object supports 5 basic attributes." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMContentAttributes = 5;" )
cpp_quote( "static const WCHAR g_wszWMTitle[] =L\"Title\";" )
cpp_quote( "static const WCHAR g_wszWMTitleSort[] =L\"TitleSort\";" )
cpp_quote( "static const WCHAR g_wszWMAuthor[] =L\"Author\";" )
cpp_quote( "static const WCHAR g_wszWMAuthorSort[] =L\"AuthorSort\";" )
cpp_quote( "static const WCHAR g_wszWMDescription[] =L\"Description\";" )
cpp_quote( "static const WCHAR g_wszWMRating[] =L\"Rating\";" )
cpp_quote( "static const WCHAR g_wszWMCopyright[] =L\"Copyright\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These attributes are used to configure and query DRM settings in the reader and writer." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMUse_DRM[] = L\"Use_DRM\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_Flags[] = L\"DRM_Flags\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_Level[] = L\"DRM_Level\";" )
cpp_quote( "static const WCHAR g_wszWMUse_Advanced_DRM[] = L\"Use_Advanced_DRM\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_KeySeed[] = L\"DRM_KeySeed\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_KeyID[] = L\"DRM_KeyID\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_ContentID[] = L\"DRM_ContentID\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_SourceID[] = L\"DRM_SourceID\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_IndividualizedVersion[] = L\"DRM_IndividualizedVersion\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_LicenseAcqURL[] = L\"DRM_LicenseAcqURL\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_V1LicenseAcqURL[] = L\"DRM_V1LicenseAcqURL\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_HeaderSignPrivKey[] = L\"DRM_HeaderSignPrivKey\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_LASignaturePrivKey[] = L\"DRM_LASignaturePrivKey\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_LASignatureCert[] = L\"DRM_LASignatureCert\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_LASignatureLicSrvCert[] = L\"DRM_LASignatureLicSrvCert\";" )
cpp_quote( "static const WCHAR g_wszWMDRM_LASignatureRootCert[] = L\"DRM_LASignatureRootCert\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the additional attributes defined in the WM attribute" )
cpp_quote( "// namespace that give information about the content." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMAlbumTitle[] =L\"WM/AlbumTitle\";" )
cpp_quote( "static const WCHAR g_wszWMAlbumTitleSort[] =L\"WM/AlbumTitleSort\";" )
cpp_quote( "static const WCHAR g_wszWMTrack[] =L\"WM/Track\";" )
cpp_quote( "static const WCHAR g_wszWMPromotionURL[] =L\"WM/PromotionURL\";" )
cpp_quote( "static const WCHAR g_wszWMAlbumCoverURL[] =L\"WM/AlbumCoverURL\";" )
cpp_quote( "static const WCHAR g_wszWMGenre[] =L\"WM/Genre\";" )
cpp_quote( "static const WCHAR g_wszWMYear[] =L\"WM/Year\";" )
cpp_quote( "static const WCHAR g_wszWMGenreID[] =L\"WM/GenreID\";" )
cpp_quote( "static const WCHAR g_wszWMMCDI[] =L\"WM/MCDI\";" )
cpp_quote( "static const WCHAR g_wszWMComposer[] =L\"WM/Composer\";" )
cpp_quote( "static const WCHAR g_wszWMComposerSort[] =L\"WM/ComposerSort\";" )
cpp_quote( "static const WCHAR g_wszWMLyrics[] =L\"WM/Lyrics\";" )
cpp_quote( "static const WCHAR g_wszWMTrackNumber[] =L\"WM/TrackNumber\";" )
cpp_quote( "static const WCHAR g_wszWMToolName[] =L\"WM/ToolName\";" )
cpp_quote( "static const WCHAR g_wszWMToolVersion[] =L\"WM/ToolVersion\";" )
cpp_quote( "static const WCHAR g_wszWMIsVBR[] =L\"IsVBR\";" )

//
// WM/AlbumArtist is a potentially different value than Author
//
cpp_quote( "static const WCHAR g_wszWMAlbumArtist[] =L\"WM/AlbumArtist\";" )
cpp_quote( "static const WCHAR g_wszWMAlbumArtistSort[] =L\"WM/AlbumArtistSort\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These optional attributes may be used to give information " )
cpp_quote( "// about the branding of the content." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMBannerImageType[] =L\"BannerImageType\";" )
cpp_quote( "static const WCHAR g_wszWMBannerImageData[] =L\"BannerImageData\";" )
cpp_quote( "static const WCHAR g_wszWMBannerImageURL[] =L\"BannerImageURL\";" )
cpp_quote( "static const WCHAR g_wszWMCopyrightURL[] =L\"CopyrightURL\";" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Optional attributes, used to give information " )
cpp_quote( "// about video stream properties." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMAspectRatioX[] =L\"AspectRatioX\";" )
cpp_quote( "static const WCHAR g_wszWMAspectRatioY[] =L\"AspectRatioY\";" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Optional attributes, used to give information " )
cpp_quote( "// about the overall streaming properties of VBR files." )
cpp_quote( "// This attribute takes the format:" )
cpp_quote( "//  WORD wReserved (must be 0)" )
cpp_quote( "//  WM_LEAKY_BUCKET_PAIR pair1" )
cpp_quote( "//  WM_LEAKY_BUCKET_PAIR pair2" )
cpp_quote( "//  ..." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszASFLeakyBucketPairs[] =L\"ASFLeakyBucketPairs\";" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The NSC file supports the following attributes." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMNSCAttributes = 5;" )
cpp_quote( "static const WCHAR g_wszWMNSCName[] =L\"NSC_Name\";" )
cpp_quote( "static const WCHAR g_wszWMNSCAddress[] =L\"NSC_Address\";" )
cpp_quote( "static const WCHAR g_wszWMNSCPhone[] =L\"NSC_Phone\";" )
cpp_quote( "static const WCHAR g_wszWMNSCEmail[] =L\"NSC_Email\";" )
cpp_quote( "static const WCHAR g_wszWMNSCDescription[] =L\"NSC_Description\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Attributes introduced in V9" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMWriter[] =L\"WM/Writer\";" )
cpp_quote( "static const WCHAR g_wszWMConductor[] =L\"WM/Conductor\";" )
cpp_quote( "static const WCHAR g_wszWMProducer[] =L\"WM/Producer\";" )
cpp_quote( "static const WCHAR g_wszWMDirector[] =L\"WM/Director\";" )
cpp_quote( "static const WCHAR g_wszWMContentGroupDescription[] =L\"WM/ContentGroupDescription\";" )
cpp_quote( "static const WCHAR g_wszWMSubTitle[] =L\"WM/SubTitle\";" )
cpp_quote( "static const WCHAR g_wszWMPartOfSet[] =L\"WM/PartOfSet\";" )
cpp_quote( "static const WCHAR g_wszWMProtectionType[] =L\"WM/ProtectionType\";" )
cpp_quote( "static const WCHAR g_wszWMVideoHeight[] =L\"WM/VideoHeight\";" )
cpp_quote( "static const WCHAR g_wszWMVideoWidth[] =L\"WM/VideoWidth\";" )
cpp_quote( "static const WCHAR g_wszWMVideoFrameRate[] =L\"WM/VideoFrameRate\";" )
cpp_quote( "static const WCHAR g_wszWMMediaClassPrimaryID[] =L\"WM/MediaClassPrimaryID\";" )
cpp_quote( "static const WCHAR g_wszWMMediaClassSecondaryID[] =L\"WM/MediaClassSecondaryID\";" )
cpp_quote( "static const WCHAR g_wszWMPeriod[] = L\"WM/Period\";" )
cpp_quote( "static const WCHAR g_wszWMCategory[] = L\"WM/Category\";" )
cpp_quote( "static const WCHAR g_wszWMPicture[] =L\"WM/Picture\";" )
cpp_quote( "static const WCHAR g_wszWMLyrics_Synchronised[] =L\"WM/Lyrics_Synchronised\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalLyricist[] =L\"WM/OriginalLyricist\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalArtist[] =L\"WM/OriginalArtist\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalAlbumTitle[] =L\"WM/OriginalAlbumTitle\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalReleaseYear[] =L\"WM/OriginalReleaseYear\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalFilename[] =L\"WM/OriginalFilename\";" )
cpp_quote( "static const WCHAR g_wszWMPublisher[] =L\"WM/Publisher\";" )
cpp_quote( "static const WCHAR g_wszWMEncodedBy[] =L\"WM/EncodedBy\";" )
cpp_quote( "static const WCHAR g_wszWMEncodingSettings[] =L\"WM/EncodingSettings\";" )
cpp_quote( "static const WCHAR g_wszWMEncodingTime[] =L\"WM/EncodingTime\";" )
cpp_quote( "static const WCHAR g_wszWMAuthorURL[] =L\"WM/AuthorURL\";" )
cpp_quote( "static const WCHAR g_wszWMUserWebURL[] =L\"WM/UserWebURL\";" )
cpp_quote( "static const WCHAR g_wszWMAudioFileURL[] =L\"WM/AudioFileURL\";" )
cpp_quote( "static const WCHAR g_wszWMAudioSourceURL[] =L\"WM/AudioSourceURL\";" )
cpp_quote( "static const WCHAR g_wszWMLanguage[] =L\"WM/Language\";" )
cpp_quote( "static const WCHAR g_wszWMParentalRating[] =L\"WM/ParentalRating\";" )
cpp_quote( "static const WCHAR g_wszWMBeatsPerMinute[] =L\"WM/BeatsPerMinute\";" )
cpp_quote( "static const WCHAR g_wszWMInitialKey[] =L\"WM/InitialKey\";" )
cpp_quote( "static const WCHAR g_wszWMMood[] =L\"WM/Mood\";" )
cpp_quote( "static const WCHAR g_wszWMText[] =L\"WM/Text\";" )
cpp_quote( "static const WCHAR g_wszWMDVDID[] =L\"WM/DVDID\";" )
cpp_quote( "static const WCHAR g_wszWMWMContentID[] =L\"WM/WMContentID\";" )
cpp_quote( "static const WCHAR g_wszWMWMCollectionID[] =L\"WM/WMCollectionID\";" )
cpp_quote( "static const WCHAR g_wszWMWMCollectionGroupID[] =L\"WM/WMCollectionGroupID\";" )
cpp_quote( "static const WCHAR g_wszWMUniqueFileIdentifier[] =L\"WM/UniqueFileIdentifier\";" )
cpp_quote( "static const WCHAR g_wszWMModifiedBy[] =L\"WM/ModifiedBy\";" )
cpp_quote( "static const WCHAR g_wszWMRadioStationName[] =L\"WM/RadioStationName\";" )
cpp_quote( "static const WCHAR g_wszWMRadioStationOwner[] =L\"WM/RadioStationOwner\";" )
cpp_quote( "static const WCHAR g_wszWMPlaylistDelay[] =L\"WM/PlaylistDelay\";" )
cpp_quote( "static const WCHAR g_wszWMCodec[] =L\"WM/Codec\";" )
cpp_quote( "static const WCHAR g_wszWMDRM[] =L\"WM/DRM\";" )
cpp_quote( "static const WCHAR g_wszWMISRC[] =L\"WM/ISRC\";" )
cpp_quote( "static const WCHAR g_wszWMProvider[] =L\"WM/Provider\";" )
cpp_quote( "static const WCHAR g_wszWMProviderRating[] =L\"WM/ProviderRating\";" )
cpp_quote( "static const WCHAR g_wszWMProviderStyle[] =L\"WM/ProviderStyle\";" )
cpp_quote( "static const WCHAR g_wszWMContentDistributor[] =L\"WM/ContentDistributor\";" )
cpp_quote( "static const WCHAR g_wszWMSubscriptionContentID[] =L\"WM/SubscriptionContentID\";" )
cpp_quote( "static const WCHAR g_wszWMWMADRCPeakReference[] =L\"WM/WMADRCPeakReference\";" )
cpp_quote( "static const WCHAR g_wszWMWMADRCPeakTarget[] =L\"WM/WMADRCPeakTarget\";" )
cpp_quote( "static const WCHAR g_wszWMWMADRCAverageReference[] =L\"WM/WMADRCAverageReference\";" )
cpp_quote( "static const WCHAR g_wszWMWMADRCAverageTarget[] =L\"WM/WMADRCAverageTarget\";" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Attributes introduced in V10" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMStreamTypeInfo[] = L\"WM/StreamTypeInfo\";" )
cpp_quote( "static const WCHAR g_wszWMPeakBitrate[] = L\"WM/PeakBitrate\";" )
cpp_quote( "static const WCHAR g_wszWMASFPacketCount[] = L\"WM/ASFPacketCount\";" )
cpp_quote( "static const WCHAR g_wszWMASFSecurityObjectsSize[] = L\"WM/ASFSecurityObjectsSize\";" )
cpp_quote( "static const WCHAR g_wszWMSharedUserRating[] = L\"WM/SharedUserRating\";" )
cpp_quote( "static const WCHAR g_wszWMSubTitleDescription[] = L\"WM/SubTitleDescription\";" )
cpp_quote( "static const WCHAR g_wszWMMediaCredits[] = L\"WM/MediaCredits\";" )
cpp_quote( "static const WCHAR g_wszWMParentalRatingReason[] = L\"WM/ParentalRatingReason\";" )
cpp_quote( "static const WCHAR g_wszWMOriginalReleaseTime[] = L\"WM/OriginalReleaseTime\";" )
cpp_quote( "static const WCHAR g_wszWMMediaStationCallSign[] = L\"WM/MediaStationCallSign\";" )
cpp_quote( "static const WCHAR g_wszWMMediaStationName[] = L\"WM/MediaStationName\";" )
cpp_quote( "static const WCHAR g_wszWMMediaNetworkAffiliation[] = L\"WM/MediaNetworkAffiliation\";" )
cpp_quote( "static const WCHAR g_wszWMMediaOriginalChannel[] = L\"WM/MediaOriginalChannel\";" )
cpp_quote( "static const WCHAR g_wszWMMediaOriginalBroadcastDateTime[] = L\"WM/MediaOriginalBroadcastDateTime\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsStereo[] = L\"WM/MediaIsStereo\";" )
cpp_quote( "static const WCHAR g_wszWMVideoClosedCaptioning[] = L\"WM/VideoClosedCaptioning\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsRepeat[] = L\"WM/MediaIsRepeat\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsLive[] = L\"WM/MediaIsLive\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsTape[] = L\"WM/MediaIsTape\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsDelay[] = L\"WM/MediaIsDelay\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsSubtitled[] = L\"WM/MediaIsSubtitled\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsPremiere[] = L\"WM/MediaIsPremiere\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsFinale[] = L\"WM/MediaIsFinale\";" )
cpp_quote( "static const WCHAR g_wszWMMediaIsSAP[] = L\"WM/MediaIsSAP\";" )
cpp_quote( "static const WCHAR g_wszWMProviderCopyright[] = L\"WM/ProviderCopyright\";" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Attributes introduced in V11" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMISAN[] = L\"WM/ISAN\";" )
cpp_quote( "static const WCHAR g_wszWMADID[] = L\"WM/ADID\";" )
cpp_quote( "static const WCHAR g_wszWMWMShadowFileSourceFileType[] = L\"WM/WMShadowFileSourceFileType\";" )
cpp_quote( "static const WCHAR g_wszWMWMShadowFileSourceDRMType[] = L\"WM/WMShadowFileSourceDRMType\";" )
cpp_quote( "static const WCHAR g_wszWMWMCPDistributor[] =L\"WM/WMCPDistributor\";" )
cpp_quote( "static const WCHAR g_wszWMWMCPDistributorID[] =L\"WM/WMCPDistributorID\";" )
cpp_quote( "static const WCHAR g_wszWMSeasonNumber[] =L\"WM/SeasonNumber\";" )
cpp_quote( "static const WCHAR g_wszWMEpisodeNumber[] =L\"WM/EpisodeNumber\";" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are setting names for use in Get/SetOutputSetting" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszEarlyDataDelivery[] =L\"EarlyDataDelivery\";" )
cpp_quote( "static const WCHAR g_wszJustInTimeDecode[] =L\"JustInTimeDecode\";" )
cpp_quote( "static const WCHAR g_wszSingleOutputBuffer[] =L\"SingleOutputBuffer\";" )
cpp_quote( "static const WCHAR g_wszSoftwareScaling[] =L\"SoftwareScaling\";" )
cpp_quote( "static const WCHAR g_wszDeliverOnReceive[] =L\"DeliverOnReceive\";" )
cpp_quote( "static const WCHAR g_wszScrambledAudio[] =L\"ScrambledAudio\";" )
cpp_quote( "static const WCHAR g_wszDedicatedDeliveryThread[] =L\"DedicatedDeliveryThread\";" )
cpp_quote( "static const WCHAR g_wszEnableDiscreteOutput[] = L\"EnableDiscreteOutput\";" )
cpp_quote( "static const WCHAR g_wszSpeakerConfig[] = L\"SpeakerConfig\";" )
cpp_quote( "static const WCHAR g_wszDynamicRangeControl[] = L\"DynamicRangeControl\";" )
cpp_quote( "static const WCHAR g_wszAllowInterlacedOutput[] = L\"AllowInterlacedOutput\";" )
cpp_quote( "static const WCHAR g_wszVideoSampleDurations[] =L\"VideoSampleDurations\";" )
cpp_quote( "static const WCHAR g_wszStreamLanguage[] =L\"StreamLanguage\";" )
cpp_quote( "static const WCHAR g_wszEnableWMAProSPDIFOutput[] = L\"EnableWMAProSPDIFOutput\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are setting names for use in Get/SetInputSetting" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszDeinterlaceMode[] =L\"DeinterlaceMode\";" )
cpp_quote( "static const WCHAR g_wszInitialPatternForInverseTelecine[] =L\"InitialPatternForInverseTelecine\";" )
cpp_quote( "static const WCHAR g_wszJPEGCompressionQuality[] =L\"JPEGCompressionQuality\";" )
cpp_quote( "static const WCHAR g_wszWatermarkCLSID[] =L\"WatermarkCLSID\";" )
cpp_quote( "static const WCHAR g_wszWatermarkConfig[] =L\"WatermarkConfig\";" )
cpp_quote( "static const WCHAR g_wszInterlacedCoding[] =L\"InterlacedCoding\";" )
cpp_quote( "static const WCHAR g_wszFixedFrameRate[] =L\"FixedFrameRate\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// All known IWMPropertyVault property names" )
cpp_quote( "//" )
cpp_quote( "// g_wszOriginalSourceFormatTag is obsolete and has been superceded by g_wszOriginalWaveFormat" )
cpp_quote( "static const WCHAR g_wszOriginalSourceFormatTag[] =L\"_SOURCEFORMATTAG\";" )
cpp_quote( "static const WCHAR g_wszOriginalWaveFormat[] =L\"_ORIGINALWAVEFORMAT\";" )
cpp_quote( "static const WCHAR g_wszEDL[] =L\"_EDL\";" )
cpp_quote( "static const WCHAR g_wszComplexity[] =L\"_COMPLEXITYEX\";" )
cpp_quote( "static const WCHAR g_wszDecoderComplexityRequested[] =L\"_DECODERCOMPLEXITYPROFILE\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// All known IWMIStreamProps property names" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszReloadIndexOnSeek[] =L\"ReloadIndexOnSeek\";" )
cpp_quote( "static const WCHAR g_wszStreamNumIndexObjects[] =L\"StreamNumIndexObjects\";" )
cpp_quote( "static const WCHAR g_wszFailSeekOnError[] =L\"FailSeekOnError\";" )
cpp_quote( "static const WCHAR g_wszPermitSeeksBeyondEndOfStream[] =L\"PermitSeeksBeyondEndOfStream\";" )
cpp_quote( "static const WCHAR g_wszUsePacketAtSeekPoint[] =L\"UsePacketAtSeekPoint\";" )
cpp_quote( "static const WCHAR g_wszSourceBufferTime[] =L\"SourceBufferTime\";" )
cpp_quote( "static const WCHAR g_wszSourceMaxBytesAtOnce[] =L\"SourceMaxBytesAtOnce\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// VBR encoding settings" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszVBREnabled[] =L\"_VBRENABLED\";" )
cpp_quote( "static const WCHAR g_wszVBRQuality[] =L\"_VBRQUALITY\";" )
cpp_quote( "static const WCHAR g_wszVBRBitrateMax[] =L\"_RMAX\";" )
cpp_quote( "static const WCHAR g_wszVBRBufferWindowMax[] =L\"_BMAX\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// VBR Video settings" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszVBRPeak[] = L\"VBR Peak\";" )
cpp_quote( "static const WCHAR g_wszBufferAverage[] = L\"Buffer Average\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Codec encoding complexity settings" )
cpp_quote( "//" )
cpp_quote( "// g_wszComplexity should be used to set desired encoding complexity on the" )
cpp_quote( "// stream's IWMPropertyVault (see above for definition) " )
cpp_quote( "// The below settings can be queried from IWMCodecInfo3::GetCodecProp()" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszComplexityMax[] =L\"_COMPLEXITYEXMAX\";" )
cpp_quote( "static const WCHAR g_wszComplexityOffline[] =L\"_COMPLEXITYEXOFFLINE\";" )
cpp_quote( "static const WCHAR g_wszComplexityLive[] =L\"_COMPLEXITYEXLIVE\";" )
cpp_quote( "static const WCHAR g_wszIsVBRSupported[] =L\"_ISVBRSUPPORTED\";" )


cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Codec enumeration settings" )
cpp_quote( "//" )
cpp_quote( "// g_wszVBREnabled can be used as a codec enumeration setting (see above for definition)" )
cpp_quote( "static const WCHAR g_wszNumPasses[] = L\"_PASSESUSED\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are WMA Voice V9 attribute names and values" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszMusicSpeechClassMode[] = L\"MusicSpeechClassMode\";" )
cpp_quote( "static const WCHAR g_wszMusicClassMode[] = L\"MusicClassMode\";" )
cpp_quote( "static const WCHAR g_wszSpeechClassMode[] = L\"SpeechClassMode\";" )
cpp_quote( "static const WCHAR g_wszMixedClassMode[] = L\"MixedClassMode\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The WMA Voice V9 supports the following format property." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszSpeechCaps[] = L\"SpeechFormatCap\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Multi-channel WMA properties" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszPeakValue[] = L\"PeakValue\";" )
cpp_quote( "static const WCHAR g_wszAverageLevel[] = L\"AverageLevel\";" )
cpp_quote( "static const WCHAR g_wszFold6To2Channels3[] = L\"Fold6To2Channels3\";" )
cpp_quote( "static const WCHAR g_wszFoldToChannelsTemplate[] = L\"Fold%luTo%luChannels%lu\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Complexity profile description strings" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszDeviceConformanceTemplate[] = L\"DeviceConformanceTemplate\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Frame interpolation on video decode" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszEnableFrameInterpolation[] =L\"EnableFrameInterpolation\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Needs previous sample for Delta frame on video decode" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszNeedsPreviousSample[] =L\"NeedsPreviousSample\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Corresponds to iTunes Compilation flag" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR g_wszWMIsCompilation[] = L\"WM/IsCompilation\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and flags used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Flags that can be passed into the Start method of IWMReader" )
cpp_quote( "//" )
cpp_quote( "#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )" )
cpp_quote( "" )

//
// Flag to force overwrite of existing license backup
//
cpp_quote( "#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)" )
cpp_quote( "#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)" )

//
// Wave format ex type
//
cpp_quote( "#define WAVE_FORMAT_DRM            0x0009" )

//
// Define a type that can allow changing the declarations of interfaces such that they are const correct
// but do not break compilation of consumers.
//
typedef LPCWSTR LPCWSTR_WMSDK_TYPE_SAFE;

cpp_quote( "#ifdef WMSDK_TYPE_SAFE" )
cpp_quote( "#define LPCWSTR_WMSDK_TYPE_SAFE LPCWSTR" )
cpp_quote( "#else" )
cpp_quote( "#define LPCWSTR_WMSDK_TYPE_SAFE LPWSTR" )
cpp_quote( "#endif" )


//
// Sample type ids for Web Streams
//

enum
{
    WEBSTREAM_SAMPLE_TYPE_FILE           = 0x1,
    WEBSTREAM_SAMPLE_TYPE_RENDER         = 0x2
};

//
// The flags that can be set on a sample (input or output).
//
enum
{
    WM_SF_CLEANPOINT = 0x1,
    WM_SF_DISCONTINUITY = 0x2,
    WM_SF_DATALOSS = 0x4,
};

//
// These flags might be set for a call to the IWMReaderAllocatorEx methods.
//
enum
{
    WM_SFEX_NOTASYNCPOINT = 0x2,
    WM_SFEX_DATALOSS = 0x4,
};

//
// Status messages that the reader and index objects can
// pass in the OnStatus call.
//
typedef enum WMT_STATUS
{
    WMT_ERROR                       =  0,
    WMT_OPENED                      =  1,
    WMT_BUFFERING_START             =  2,
    WMT_BUFFERING_STOP              =  3,
    WMT_EOF                         =  4,
    WMT_END_OF_FILE                 =  4,
    WMT_END_OF_SEGMENT              =  5,
    WMT_END_OF_STREAMING            =  6,
    WMT_LOCATING                    =  7,
    WMT_CONNECTING                  =  8,
    WMT_NO_RIGHTS                   =  9,
    WMT_MISSING_CODEC               = 10,
    WMT_STARTED                     = 11,
    WMT_STOPPED                     = 12,
    WMT_CLOSED                      = 13,
    WMT_STRIDING                    = 14,
    WMT_TIMER                       = 15,
    WMT_INDEX_PROGRESS              = 16,
    WMT_SAVEAS_START                = 17,
    WMT_SAVEAS_STOP                 = 18,
    WMT_NEW_SOURCEFLAGS             = 19,
    WMT_NEW_METADATA                = 20,
    WMT_BACKUPRESTORE_BEGIN         = 21,
    WMT_SOURCE_SWITCH               = 22,
    WMT_ACQUIRE_LICENSE             = 23,
    WMT_INDIVIDUALIZE               = 24,
    WMT_NEEDS_INDIVIDUALIZATION     = 25,
    WMT_NO_RIGHTS_EX                = 26,
    WMT_BACKUPRESTORE_END           = 27,
    WMT_BACKUPRESTORE_CONNECTING    = 28,
    WMT_BACKUPRESTORE_DISCONNECTING = 29,
    WMT_ERROR_WITHURL               = 30,
    WMT_RESTRICTED_LICENSE          = 31,
    WMT_CLIENT_CONNECT              = 32,
    WMT_CLIENT_DISCONNECT           = 33,
    WMT_NATIVE_OUTPUT_PROPS_CHANGED = 34,
    WMT_RECONNECT_START             = 35,
    WMT_RECONNECT_END               = 36,
    WMT_CLIENT_CONNECT_EX           = 37,
    WMT_CLIENT_DISCONNECT_EX        = 38,
    WMT_SET_FEC_SPAN                = 39,
    WMT_PREROLL_READY               = 40,
    WMT_PREROLL_COMPLETE            = 41,
    WMT_CLIENT_PROPERTIES           = 42,
    WMT_LICENSEURL_SIGNATURE_STATE  = 43,
    WMT_INIT_PLAYLIST_BURN          = 44,
    WMT_TRANSCRYPTOR_INIT           = 45,
    WMT_TRANSCRYPTOR_SEEKED         = 46,
    WMT_TRANSCRYPTOR_READ           = 47,
    WMT_TRANSCRYPTOR_CLOSED         = 48,
    WMT_PROXIMITY_RESULT            = 49,
    WMT_PROXIMITY_COMPLETED         = 50,
    WMT_CONTENT_ENABLER             = 51
} WMT_STATUS;

//
// Stream selection statuses (stati?).
//
typedef enum WMT_STREAM_SELECTION
{
    WMT_OFF               = 0,
    WMT_CLEANPOINT_ONLY   = 1,
    WMT_ON                = 2,
} WMT_STREAM_SELECTION;

//
// Image types (used with CBO)
//
typedef enum WMT_IMAGE_TYPE
{
    WMT_IT_NONE      = 0,
    WMT_IT_BITMAP    = 1,
    WMT_IT_JPEG      = 2,
    WMT_IT_GIF       = 3
} WMT_IMAGE_TYPE;

//
// Attribute datatypes.
//
typedef enum WMT_ATTR_DATATYPE
{

    WMT_TYPE_DWORD      = 0,
    WMT_TYPE_STRING     = 1,
    WMT_TYPE_BINARY     = 2,
    WMT_TYPE_BOOL       = 3,
    WMT_TYPE_QWORD      = 4,
    WMT_TYPE_WORD       = 5,
    WMT_TYPE_GUID       = 6,

} WMT_ATTR_DATATYPE;

//
// Types of images that can be stored in the header of a Windows Media File.
//
typedef enum WMT_ATTR_IMAGETYPE
{
    WMT_IMAGETYPE_BITMAP = 1,
    WMT_IMAGETYPE_JPEG = 2,
    WMT_IMAGETYPE_GIF = 3,
} WMT_ATTR_IMAGETYPE;

//
// Windows Media versions.
//
typedef enum WMT_VERSION
{
    WMT_VER_4_0 = 0x00040000,
    WMT_VER_7_0 = 0x00070000,
    WMT_VER_8_0 = 0x00080000,
    WMT_VER_9_0 = 0x00090000,
} WMT_VERSION;

//
// Storage formats.  These are the values returned when querying
// the WM/ContainerFormat attribute (g_wszWMContainerFormat).
//
typedef enum tagWMT_STORAGE_FORMAT
{
    WMT_Storage_Format_MP3,
    WMT_Storage_Format_V1
} WMT_STORAGE_FORMAT;

typedef enum tagWMT_DRMLA_TRUST
{
    WMT_DRMLA_UNTRUSTED = 0,
    WMT_DRMLA_TRUSTED,
    WMT_DRMLA_TAMPERED
} WMT_DRMLA_TRUST;

//
// Type of data communication protocol (reliable or unreliable)
//
typedef enum tagWMT_TRANSPORT_TYPE
{
   WMT_Transport_Type_Unreliable,
   WMT_Transport_Type_Reliable
} WMT_TRANSPORT_TYPE;

//
// Protocols that the network sink supports.
//
typedef enum WMT_NET_PROTOCOL
{
    WMT_PROTOCOL_HTTP    = 0,
} WMT_NET_PROTOCOL;


//
// The reader supports a number of different types of playback, each with
// slightly different characteristics.
//
typedef enum WMT_PLAY_MODE
{
    WMT_PLAY_MODE_AUTOSELECT    = 0,
    WMT_PLAY_MODE_LOCAL         = 1,
    WMT_PLAY_MODE_DOWNLOAD      = 2,
    WMT_PLAY_MODE_STREAMING     = 3,
} WMT_PLAY_MODE;

//
// Network Proxy settings for the reader
//
typedef enum WMT_PROXY_SETTINGS
{
    WMT_PROXY_SETTING_NONE      = 0,
    WMT_PROXY_SETTING_MANUAL    = 1,
    WMT_PROXY_SETTING_AUTO      = 2,
    WMT_PROXY_SETTING_BROWSER   = 3,        // Only valid for HTTP
    WMT_PROXY_SETTING_MAX
} WMT_PROXY_SETTINGS;


typedef enum WMT_CODEC_INFO_TYPE
{
    WMT_CODECINFO_AUDIO         = 0,            // codec info is a word = wFormatTag
    WMT_CODECINFO_VIDEO         = 1,            // codec info is a dword = biCompression
    WMT_CODECINFO_UNKNOWN       = 0xFFFFFFFF,   // codec info is undefined
} WMT_CODEC_INFO_TYPE;

//
// These values can be passed in when setting the DeinterlaceMode
// setting on the writer
//
enum
{
    WM_DM_NOTINTERLACED                  = 0,
    WM_DM_DEINTERLACE_NORMAL             = 1,
    WM_DM_DEINTERLACE_HALFSIZE           = 2,
    WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE = 3,
    WM_DM_DEINTERLACE_INVERSETELECINE    = 4,
    WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE = 5,
};

//
// These values can be passed to further configure the inverse
// telecine process
//
enum
{
    WM_DM_IT_DISABLE_COHERENT_MODE       = 0,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_TOP   = 1,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_TOP   = 2,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_TOP   = 3,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_TOP   = 4,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_TOP   = 5,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_BOTTOM   = 6,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_BOTTOM   = 7,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_BOTTOM   = 8,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_BOTTOM   = 9,
    WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_BOTTOM   = 10
};

//
// Frame level access data structures
//
typedef enum tagWMT_OFFSET_FORMAT
{
    WMT_OFFSET_FORMAT_100NS,
    WMT_OFFSET_FORMAT_FRAME_NUMBERS,
    WMT_OFFSET_FORMAT_PLAYLIST_OFFSET,
    WMT_OFFSET_FORMAT_TIMECODE,
    WMT_OFFSET_FORMAT_100NS_APPROXIMATE
}   WMT_OFFSET_FORMAT;

//
// Indexer type and index type
//
typedef enum tagWMT_INDEXER_TYPE
{
    WMT_IT_PRESENTATION_TIME,
    WMT_IT_FRAME_NUMBERS,
    WMT_IT_TIMECODE
}   WMT_INDEXER_TYPE;

typedef enum tagWMT_INDEX_TYPE
{
    WMT_IT_NEAREST_DATA_UNIT = 1,
    WMT_IT_NEAREST_OBJECT,
    WMT_IT_NEAREST_CLEAN_POINT
}   WMT_INDEX_TYPE;

//
// The types of input accepted by the file sink
//
typedef enum tagWMT_FILESINK_MODE
{
    WMT_FM_SINGLE_BUFFERS       = 0x00000001,
    WMT_FM_FILESINK_DATA_UNITS  = 0x00000002,
    WMT_FM_FILESINK_UNBUFFERED  = 0x00000004
}   WMT_FILESINK_MODE;

//
// WMA Voice V9 supports several type of compression,
// profile settting are mapped to these constants
//
typedef enum tagWMT_MUSICSPEECH_CLASS_MODE
{
    WMT_MS_CLASS_MUSIC    = 0,
    WMT_MS_CLASS_SPEECH   = 1,
    WMT_MS_CLASS_MIXED    = 2
}   WMT_MUSICSPEECH_CLASS_MODE;

typedef enum tagWMT_WATERMARK_ENTRY_TYPE
{
    WMT_WMETYPE_AUDIO = 1,
    WMT_WMETYPE_VIDEO = 2
} WMT_WATERMARK_ENTRY_TYPE;

//
// Dynamic Range Control values for playback
//
enum
{
    WM_PLAYBACK_DRC_HIGH    = 0,
    WM_PLAYBACK_DRC_MEDIUM,
    WM_PLAYBACK_DRC_LOW
};

//
// Timecode frame rates.  These are meant to be used as the
// values for the stream-based frame rate metadata attribute.
// See the WM Format SDK docs for more details.
//
enum
{
    WMT_TIMECODE_FRAMERATE_30      = 0,
    WMT_TIMECODE_FRAMERATE_30DROP,
    WMT_TIMECODE_FRAMERATE_25,
    WMT_TIMECODE_FRAMERATE_24
};

//
// Flags that can be specified in IWMCredentialCallback::AcquireCredentials()
//
typedef enum WMT_CREDENTIAL_FLAGS
{
    WMT_CREDENTIAL_SAVE                 = 0x00000001,       // Save the credentials in a persistent manner
    WMT_CREDENTIAL_DONT_CACHE           = 0x00000002,       // Don't cache the credentials in memory
    WMT_CREDENTIAL_CLEAR_TEXT           = 0x00000004,       // Credentials will be sent in clear text
    WMT_CREDENTIAL_PROXY                = 0x00000008,       // Credentials are for a proxy server
    WMT_CREDENTIAL_ENCRYPT              = 0x00000010        // Encryption supported/used (in request/response, respectively)
} WMT_CREDENTIAL_FLAGS;

typedef enum WM_AETYPE
{
    WM_AETYPE_INCLUDE   = 'i',
    WM_AETYPE_EXCLUDE   = 'e'

} WM_AETYPE;

typedef enum WMT_RIGHTS
{
    WMT_RIGHT_PLAYBACK	= 0x1,
    WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
    WMT_RIGHT_COPY_TO_CD	= 0x8,
    WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
    WMT_RIGHT_ONE_TIME	= 0x20,
    WMT_RIGHT_SAVE_STREAM_PROTECTED	= 0x40,
    WMT_RIGHT_COPY	= 0x80,
    WMT_RIGHT_COLLABORATIVE_PLAY	= 0x100,
    WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
    WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
} 	WMT_RIGHTS;

///////////////////////////////////////////////////////////////////////////////
//
// Structures used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push)
#pragma pack(2)

//
// Stream prioritization struct
//
typedef struct _WMStreamPrioritizationRecord
{
    WORD wStreamNumber;
    BOOL fMandatory;
} WM_STREAM_PRIORITY_RECORD;

#pragma pack(pop)

//
// Writer Statistics struct
//
typedef struct _WMWriterStatistics
{
    QWORD qwSampleCount;
    QWORD qwByteCount;

    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;

    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;

    //
    // Sample rates are given as 1000 * (samples / second).
    //
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
} WM_WRITER_STATISTICS;

//
// Extended Writer Statistics
//
typedef struct _WMWriterStatisticsEx
{
    //
    // Bitrate that includes overhead
    //
    DWORD dwBitratePlusOverhead;

    //
    // Sample rates are given as 1000 * (samples / second)
    //
    DWORD dwCurrentSampleDropRateInQueue;
    DWORD dwCurrentSampleDropRateInCodec;
    DWORD dwCurrentSampleDropRateInMultiplexer;

    //
    // Cumulative sample drops
    //
    DWORD dwTotalSampleDropsInQueue;
    DWORD dwTotalSampleDropsInCodec;
    DWORD dwTotalSampleDropsInMultiplexer;

} WM_WRITER_STATISTICS_EX;

//
// Reader Statistics struct
//
typedef struct _WMReaderStatistics
{
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD  wQuality;
} WM_READER_STATISTICS;


//
// Reader Client Info struct
//
typedef struct _WMReaderClientInfo
{
    DWORD  cbSize;
    WCHAR  *wszLang;              // 2-3 letter language code
    WCHAR  *wszBrowserUserAgent;  // Embedded browser's user-agent string
    WCHAR  *wszBrowserWebPage;    // The web page that contains the plugin
    QWORD  qwReserved;            // Reserved
    LPARAM *pReserved;            // Reserved
    WCHAR  *wszHostExe;           // iexplore.exe, netscape.exe dshow.exe, etc
    QWORD  qwHostVersion;         // Version of the host application e.g.:4.70.12.15
    WCHAR  *wszPlayerUserAgent;   // String identifying the player application, e.g. WMPlayer/9.0.0.0
} WM_READER_CLIENTINFO;


//
// This structure is returned with the WMT_CLIENT_CONNECT and
// WMT_CLIENT_DISCONNECT status notifications.  It is also used
// by IWMClientConnections.
//
typedef struct _WMClientProperties
{
    DWORD   dwIPAddress;
    DWORD   dwPort;
} WM_CLIENT_PROPERTIES;


//
// This structure is returned with the WMT_CLIENT_CONNECT_EX, WMT_CLIENT_DISCONNECT_EX
// and WMT_CLIENT_PROPERTIES status notifications.
//
typedef struct _WMClientPropertiesEx
{
    DWORD    cbSize;                // size of structure
    LPCWSTR  pwszIPAddress;         // IP address in dot notation
    LPCWSTR  pwszPort;              // Client's port number
    LPCWSTR  pwszDNSName;           // DNS name of client, if known
} WM_CLIENT_PROPERTIES_EX;

//
// Inclusive port number range.
// Used by IWMReaderNetworkConfig.
//
typedef struct _WMPortNumberRange
{
    WORD   wPortBegin;
    WORD   wPortEnd;
} WM_PORT_NUMBER_RANGE;

//
// For passing data units to the file sink
//
typedef struct _WMT_BUFFER_SEGMENT
{
    INSSBuffer  *pBuffer;
    DWORD       cbOffset;
    DWORD       cbLength;
} WMT_BUFFER_SEGMENT;

typedef struct _WMT_PAYLOAD_FRAGMENT
{
    DWORD               dwPayloadIndex;
    WMT_BUFFER_SEGMENT  segmentData;
} WMT_PAYLOAD_FRAGMENT;


typedef struct _WMT_FILESINK_DATA_UNIT
{
    WMT_BUFFER_SEGMENT      packetHeaderBuffer;

    DWORD                   cPayloads;
    WMT_BUFFER_SEGMENT      *pPayloadHeaderBuffers;

    DWORD                   cPayloadDataFragments;
    WMT_PAYLOAD_FRAGMENT    *pPayloadDataFragments;

} WMT_FILESINK_DATA_UNIT;

typedef struct _WMT_WEBSTREAM_FORMAT
{
    WORD                    cbSize;                    // Set to sizeof( WMT_WEBSTREAM_FORMAT )
    WORD                    cbSampleHeaderFixedData;   // Length of the fixed part of the sample header should be
                                                       // set to sizeof( WMT_WEBSTREAM_SAMPLE_HEADER )
    WORD                    wVersion;
    WORD                    wReserved;                 // Reserved. Should be set to 0.
} WMT_WEBSTREAM_FORMAT;

typedef struct _WMT_WEBSTREAM_SAMPLE_HEADER
{
    WORD                    cbLength;                  // Length of this header including string data
                                                       // should be set to sizeof( WMT_WEBSTREAM_SAMPLE_HEADER ) +
                                                       // wcslen( wszURL ) * sizeof( WCHAR )
    WORD                    wPart;                     // Current part. From 0 to cTotalParts - 1
    WORD                    cTotalParts;               // Total number of parts for this file must be at least 1.
    WORD                    wSampleType;               // Sample type. Should be set to
                                                       //     WEBSTREAM_SAMPLE_TYPE_FILE = 0x0001 or
                                                       //     WEBSTREAM_SAMPLE_TYPE_RENDER = 0x0002
    WCHAR                   wszURL[1];                 // Variable length string data containing file url
} WMT_WEBSTREAM_SAMPLE_HEADER;


typedef struct _WMAddressAccessEntry
{
    DWORD       dwIPAddress;
    DWORD       dwMask;
} WM_ADDRESS_ACCESSENTRY;


///////////////////////////////////////////////////////////////////////////////
//
// Structures for complex metadata attributes
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push)
#pragma pack(1)

typedef struct _WMPicture
{
    LPWSTR pwszMIMEType;
    BYTE bPictureType;
    LPWSTR pwszDescription;
    DWORD dwDataLen;
    BYTE *pbData;
} WM_PICTURE;

typedef struct _WMSynchronisedLyrics
{
    BYTE bTimeStampFormat;
    BYTE bContentType;
    LPWSTR pwszContentDescriptor;
    DWORD dwLyricsLen;
    BYTE *pbLyrics;
} WM_SYNCHRONISED_LYRICS;

typedef struct _WMUserWebURL
{
    LPWSTR pwszDescription;
    LPWSTR pwszURL;
} WM_USER_WEB_URL;

typedef struct _WMUserText
{
    LPWSTR pwszDescription;
    LPWSTR pwszText;
} WM_USER_TEXT;

typedef struct _WMLeakyBucketPair
{
    DWORD dwBitrate;
    DWORD msBufferWindow;

} WM_LEAKY_BUCKET_PAIR;

typedef struct _WMStreamTypeInfo
{
    GUID guidMajorType;
    DWORD cbFormat;
} WM_STREAM_TYPE_INFO;

#pragma pack(pop)

///////////////////////////////////////////////////////////////////////////////
// Watermark entry
///////////////////////////////////////////////////////////////////////////////
typedef struct __WMT_WATERMARK_ENTRY
{
    WMT_WATERMARK_ENTRY_TYPE wmetType;
    CLSID                    clsid;
    UINT                     cbDisplayName;
    LPWSTR                   pwszDisplayName;
} WMT_WATERMARK_ENTRY;

///////////////////////////////////////////////////////////////////////////////
// VideoImage structs
///////////////////////////////////////////////////////////////////////////////

//
// dwControlFlags
//
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_INPUT_FRAME      1 // sample has input frame ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_OUTPUT_FRAME     2 // sample produces output frame ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_USES_CURRENT_INPUT_FRAME  4 ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_USES_PREVIOUS_INPUT_FRAME 8 ")

//
// dwInputFlags
//
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_MOTION       1 // acef used (includes resizing) ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_ROTATION     2 // bd also used (not valid without acef) ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_BLENDING     4 // BlendCoef1 used ")
cpp_quote( "#define WMT_VIDEOIMAGE_SAMPLE_ADV_BLENDING 8 // BlendCoef2 also used (not valid without BlendCoef1) ")

cpp_quote( "#define WMT_VIDEOIMAGE_INTEGER_DENOMINATOR 65536L ")

cpp_quote( "#define WMT_VIDEOIMAGE_MAGIC_NUMBER 0x1d4a45f2 ")
cpp_quote( "#define WMT_VIDEOIMAGE_MAGIC_NUMBER_2 0x1d4a45f3 ")

typedef struct __WMT_VIDEOIMAGE_SAMPLE {
    DWORD dwMagic;
    ULONG cbStruct; // size of structure; incudes dwMagic and cbStruct
    DWORD dwControlFlags;

    //
    // most recent input frame
    //
    DWORD dwInputFlagsCur;
    LONG lCurMotionXtoX;    // a
    LONG lCurMotionYtoX;    // b
    LONG lCurMotionXoffset; // c
    LONG lCurMotionXtoY;    // d
    LONG lCurMotionYtoY;    // e
    LONG lCurMotionYoffset; // f
    LONG lCurBlendCoef1;
    LONG lCurBlendCoef2;

    //
    // second most recent input frame
    //
    DWORD dwInputFlagsPrev;
    LONG lPrevMotionXtoX;    // a
    LONG lPrevMotionYtoX;    // b
    LONG lPrevMotionXoffset; // c
    LONG lPrevMotionXtoY;    // d
    LONG lPrevMotionYtoY;    // e
    LONG lPrevMotionYoffset; // f
    LONG lPrevBlendCoef1;
    LONG lPrevBlendCoef2;
}   WMT_VIDEOIMAGE_SAMPLE;


//
// Transition IDs for use with WMT_VIDEOIMAGE_SAMPLE2
//
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_BOW_TIE           11")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_CIRCLE            12")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_CROSS_FADE        13")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_DIAGONAL          14")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_DIAMOND           15")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_FADE_TO_COLOR     16")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_FILLED_V          17")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_FLIP              18")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_INSET             19")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_IRIS              20")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_PAGE_ROLL         21")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_RECTANGLE         23")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_REVEAL            24")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_SLIDE             27")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_SPLIT             29")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_STAR              30")
cpp_quote( "#define WMT_VIDEOIMAGE_TRANSITION_WHEEL             31")

typedef struct __WMT_VIDEOIMAGE_SAMPLE2 {
    DWORD dwMagic;
    DWORD dwStructSize; // size of structure; incudes dwMagic and cbStruct
    DWORD dwControlFlags;

    // Viewport size
    DWORD dwViewportWidth;
    DWORD dwViewportHeight;

    // Current image
    DWORD dwCurrImageWidth;
    DWORD dwCurrImageHeight;
    FLOAT fCurrRegionX0;
    FLOAT fCurrRegionY0;
    FLOAT fCurrRegionWidth;
    FLOAT fCurrRegionHeight;
    FLOAT fCurrBlendCoef;

    // Previous image
    DWORD dwPrevImageWidth;
    DWORD dwPrevImageHeight;
    FLOAT fPrevRegionX0;
    FLOAT fPrevRegionY0;
    FLOAT fPrevRegionWidth;
    FLOAT fPrevRegionHeight;
    FLOAT fPrevBlendCoef;

    // Transition effect type
    DWORD dwEffectType;

    // Transition effect parameters
    DWORD dwNumEffectParas;
    FLOAT fEffectPara0;
    FLOAT fEffectPara1;
    FLOAT fEffectPara2;
    FLOAT fEffectPara3;
    FLOAT fEffectPara4;

    // Keep previous image
    BOOL bKeepPrevImage;
} WMT_VIDEOIMAGE_SAMPLE2;


///////////////////////////////////////////////////////////////////////////////
//
// Media-type structures and GUIDs.
//
///////////////////////////////////////////////////////////////////////////////

//
// We use DirectShow media types in this SDK. However, to avoid conflict with
// their names, we define our own version of the structure. This is exactly
// the same as an AM_MEDIA_TYPE!
//
typedef struct _WMMediaType
{
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    [size_is(cbFormat)] BYTE *pbFormat;
} WM_MEDIA_TYPE;


cpp_quote( "typedef struct tagWMVIDEOINFOHEADER" )
cpp_quote( "{" )
cpp_quote( "    //" )
cpp_quote( "    // The bit we really want to use." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcSource;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Where the video should go." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcTarget;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Approximate bit data rate." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Bit error rate for this stream." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitErrorRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Average time per frame (100ns units)." )
cpp_quote( "    //" )
cpp_quote( "    LONGLONG AvgTimePerFrame;" )
cpp_quote( "" )
cpp_quote( "    BITMAPINFOHEADER bmiHeader;" )
cpp_quote( "} WMVIDEOINFOHEADER;" )


cpp_quote( "typedef struct tagWMVIDEOINFOHEADER2" )
cpp_quote( "{" )
cpp_quote( "    //" )
cpp_quote( "    // The bit we really want to use." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcSource;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Where the video should go." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcTarget;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Approximate bit data rate." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Bit error rate for this stream." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitErrorRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Average time per frame (100ns units)." )
cpp_quote( "    //" )
cpp_quote( "    LONGLONG AvgTimePerFrame;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Use AMINTERLACE_* defines. Reject connection if undefined bits are not 0." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwInterlaceFlags;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwCopyProtectFlags;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // X dimension of picture aspect ratio, e.g. 16 for 16x9 display." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwPictAspectRatioX;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwPictAspectRatioY;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Must be 0; reject connection otherwise." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwReserved1;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Must be 0; reject connection otherwise." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwReserved2;" )
cpp_quote( "" )
cpp_quote( "    BITMAPINFOHEADER bmiHeader;" )
cpp_quote( "} WMVIDEOINFOHEADER2;" )


cpp_quote( "typedef struct tagWMMPEG2VIDEOINFO" )
cpp_quote( "{" )
cpp_quote( "    //" )
cpp_quote( "    // Video info header2." )
cpp_quote( "    //" )
cpp_quote( "    WMVIDEOINFOHEADER2 hdr;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Not used for DVD." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwStartTimeCode;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Is 0 for DVD (no sequence header)." )
cpp_quote( "    //" )
cpp_quote( "    DWORD cbSequenceHeader;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Use enum MPEG2Profile." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwProfile;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Use enum MPEG2Level." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwLevel;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Use AMMPEG2_* defines.  Reject connection if undefined bits are not 0." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwFlags;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Sequence header." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwSequenceHeader[1];" )
cpp_quote( "" )
cpp_quote( "} WMMPEG2VIDEOINFO;" )

cpp_quote( "typedef struct tagWMSCRIPTFORMAT" )
cpp_quote( "{" )
cpp_quote( "    GUID    scriptType; ")
cpp_quote( "} WMSCRIPTFORMAT;" )

//
// This special GUID is used to create a subtype from an audio format tag, or
// video four-character code. Just fill in the first DWORD of the GUID with
// the appropriate value.
//
cpp_quote( "// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_Base, " )
cpp_quote( "0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Video, " )
cpp_quote( "0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB1, " )
cpp_quote( "0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB4, " )
cpp_quote( "0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB8, " )
cpp_quote( "0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB565, " )
cpp_quote( "0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB555, " )
cpp_quote( "0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB24, " )
cpp_quote( "0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB32, " )
cpp_quote( "0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// 30323449-0000-0010-8000-00AA00389B71  'I420' ==  MEDIASUBTYPE_I420 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_I420, " )
cpp_quote( "0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 56555949-0000-0010-8000-00AA00389B71  'IYUV' ==  MEDIASUBTYPE_IYUV " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_IYUV, " )
cpp_quote( "0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YV12, " )
cpp_quote( "0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YUY2, " )
cpp_quote( "0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 32323450-0000-0010-8000-00AA00389B71  'P422' == MEDIASUBTYPE_P422 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_P422, " )
cpp_quote( "0x32323450, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_UYVY, " )
cpp_quote( "0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVYU, " )
cpp_quote( "0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVU9, " )
cpp_quote( "0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 1d4a45f2-e5f6-4b44-8388-f0ae5c0e0c37            MEDIASUBTYPE_VIDEOIMAGE " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_VIDEOIMAGE,  " )
cpp_quote( "0x1d4a45f2, 0xe5f6, 0x4b44, 0x83, 0x88, 0xf0, 0xae, 0x5c, 0x0e, 0x0c, 0x37); " )

cpp_quote( "// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP43, " )
cpp_quote( "0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP4S, " )
cpp_quote( "0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 3253344D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_M4S2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_M4S2, " )
cpp_quote( "0x3253344D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMV1, " )
cpp_quote( "0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 32564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMV2, " )
cpp_quote( "0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MSS1, " )
cpp_quote( "0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// E06D8026-DB46-11CF-B4D1-00805F6CBBEA            WMMEDIASUBTYPE_MPEG2_VIDEO " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MPEG2_VIDEO, " )
cpp_quote( "0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea); " )

cpp_quote( "// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Audio, " )
cpp_quote( "0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_PCM, " )
cpp_quote( "0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_DRM, " )
cpp_quote( "0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000162-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV9 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV9, " )
cpp_quote( "0x00000162, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000163-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudio_Lossless " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudio_Lossless, " )
cpp_quote( "0x00000163, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 3253534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MSS2, " )
cpp_quote( "0x3253534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 0000000A-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMSP1 " )
cpp_quote( "EXTERN_GUID( WMMEDIASUBTYPE_WMSP1, " )
cpp_quote( "0x0000000A,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71); " )

cpp_quote( "// 0000000B-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMSP2 " )
cpp_quote( "EXTERN_GUID( WMMEDIASUBTYPE_WMSP2, " )
cpp_quote( "0x0000000B,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71); " )

cpp_quote( "// 33564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV3 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMV3, " )
cpp_quote( "0x33564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 50564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMVP " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMVP, " )
cpp_quote( "0x50564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 32505657-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WVP2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WVP2, " )
cpp_quote( "0x32505657, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 41564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMVA " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMVA, " )
cpp_quote( "0x41564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 31435657-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WVC1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WVC1, " )
cpp_quote( "0x31435657, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

//
// WM Audio v2 and v7 are actually compatible bitstreams.
//
cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV8 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV8, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, " )
cpp_quote( "0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000055-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP3 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP3, " )
cpp_quote( "0x00000055, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 776257D4-C627-41CB-8F81-7AC7FF1C40CC            WMMEDIASUBTYPE_WebStream " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WebStream, " )
cpp_quote( "0x776257d4, 0xc627, 0x41cb, 0x8f, 0x81, 0x7a, 0xc7, 0xff, 0x1c, 0x40, 0xcc); " )

cpp_quote( "// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == WMMEDIATYPE_Script " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Script, " )
cpp_quote( "0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31  'imag' == WMMEDIATYPE_Image " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Image, " )
cpp_quote( "0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); " )

cpp_quote( "// D9E47579-930E-4427-ADFC-AD80F290E470  'fxfr' == WMMEDIATYPE_FileTransfer " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_FileTransfer, " )
cpp_quote( "0xd9e47579, 0x930e, 0x4427, 0xad, 0xfc, 0xad, 0x80, 0xf2, 0x90, 0xe4, 0x70); " )

cpp_quote( "// 9BBA1EA7-5AB2-4829-BA57-0940209BCF3E      'text' == WMMEDIATYPE_Text " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Text, " )
cpp_quote( "0x9bba1ea7, 0x5ab2, 0x4829, 0xba, 0x57, 0x9, 0x40, 0x20, 0x9b, 0xcf, 0x3e); " )

cpp_quote( "// 05589F80-C356-11CE-BF01-00AA0055595A        WMFORMAT_VideoInfo " )
cpp_quote( "EXTERN_GUID(WMFORMAT_VideoInfo, " )
cpp_quote( "0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// E06D80E3-DB46-11CF-B4D1-00805F6CBBEA        WMFORMAT_MPEG2Video " )
cpp_quote( "EXTERN_GUID(WMFORMAT_MPEG2Video, " )
cpp_quote( "0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea); " )

cpp_quote( "// 05589F81-C356-11CE-BF01-00AA0055595A        WMFORMAT_WaveFormatEx " )
cpp_quote( "EXTERN_GUID(WMFORMAT_WaveFormatEx, " )
cpp_quote( "0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// 5C8510F2-DEBE-4CA7-BBA5-F07A104F8DFF        WMFORMAT_Script " )
cpp_quote( "EXTERN_GUID(WMFORMAT_Script, " )
cpp_quote( "0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); " )

cpp_quote( "// DA1E6B13-8359-4050-B398-388E965BF00C        WMFORMAT_WebStream " )
cpp_quote( "EXTERN_GUID(WMFORMAT_WebStream, " )
cpp_quote( "0xda1e6b13, 0x8359, 0x4050, 0xb3, 0x98, 0x38, 0x8e, 0x96, 0x5b, 0xf0, 0x0c); " )

cpp_quote( "// 82F38A70-C29F-11D1-97AD-00A0C95EA850        WMSCRIPTTYPE_TwoStrings " )
cpp_quote( "EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, " )
cpp_quote( "0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); " )

//////////////////////////////////////////////////////////////////////////////
//
// GUIDs for common buffer properties
//
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_OutputCleanPoint, 0xf72a3c6f, 0x6eb4, 0x4ebc, 0xb1, 0x92, 0x9, 0xad, 0x97, 0x59, 0xe8, 0x28 );" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_Timecode, 0x399595ec, 0x8667, 0x4e2d, 0x8f, 0xdb, 0x98, 0x81, 0x4c, 0xe7, 0x6c, 0x1e);" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_ChromaLocation, 0x4c5acca0, 0x9276, 0x4b2c, 0x9e, 0x4c, 0xa0, 0xed, 0xef, 0xdd, 0x21, 0x7e);" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_ColorSpaceInfo, 0xf79ada56, 0x30eb, 0x4f2b, 0x9f, 0x7a, 0xf2, 0x4b, 0x13, 0x9a, 0x11, 0x57 );" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_UserDataInfo, 0x732bb4fa, 0x78be, 0x4549, 0x99, 0xbd, 0x2, 0xdb, 0x1a, 0x55, 0xb7, 0xa8 );" )

//
// This buffer property is used in conjunction with file transfer streams.
// It is the name of the file being transfered (in WCHARs).
//
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_FileName, 0xe165ec0e, 0x19ed, 0x45d7, 0xb4, 0xa7, 0x25, 0xcb, 0xd1, 0xe2, 0x8e, 0x9b);" )

cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_ContentType, 0xd590dc20, 0x07bc, 0x436c, 0x9c, 0xf7, 0xf3, 0xbb, 0xfb, 0xf1, 0xa4, 0xdc );" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_PixelAspectRatio, 0x1b1ee554, 0xf9ea, 0x4bc8, 0x82, 0x1a, 0x37, 0x6b, 0x74, 0xe4, 0xc4, 0xb8 );" )
cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_SampleDuration, 0xc6bd9450, 0x867f, 0x4907, 0x83, 0xa3, 0xc7, 0x79, 0x21, 0xb7, 0x33, 0xad );" )

cpp_quote( "EXTERN_GUID( WM_SampleExtensionGUID_SampleProtectionSalt, 0x5403deee, 0xb9ee, 0x438f, 0xaa, 0x83, 0x38, 0x4, 0x99, 0x7e, 0x56, 0x9d );" )


//
// Constants for use with the corresponding sample extension properties
//
cpp_quote( "#define WM_SampleExtension_ContentType_Size         1" )
cpp_quote( "#define WM_SampleExtension_PixelAspectRatio_Size    2" )
cpp_quote( "#define WM_SampleExtension_Timecode_Size           14" )
cpp_quote( "#define WM_SampleExtension_SampleDuration_Size      2" )
cpp_quote( "#define WM_SampleExtension_ChromaLocation_Size      1" )
cpp_quote( "#define WM_SampleExtension_ColorSpaceInfo_Size      3" )

///////////////////////////////////////////////////////////////////////////////
//
// Content Types to be used with WM_SampleExtensionGUID_ContentType
// on INSSBuffer3::SetProperty/GetProperty
//
///////////////////////////////////////////////////////////////////////////////
cpp_quote( "#define WM_CT_REPEAT_FIRST_FIELD 0x10" )
cpp_quote( "#define WM_CT_BOTTOM_FIELD_FIRST 0x20" )
cpp_quote( "#define WM_CT_TOP_FIELD_FIRST    0x40" )
cpp_quote( "#define WM_CT_INTERLACED         0x80" )

///////////////////////////////////////////////////////////////////////////////
//
// Chroma Locations to be used with WM_SampleExtensionGUID_ChromaLocation
// on INSSBuffer3::SetProperty/GetProperty
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "#define WM_CL_INTERLACED420   0" )
cpp_quote( "#define WM_CL_PROGRESSIVE420  1" )

///////////////////////////////////////////////////////////////////////////////
//
// Color Space Info to be used with WM_SampleExtension_ColorSpaceInfo
// on INSSBuffer3::SetProperty/GetProperty
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push)
#pragma pack(1)

typedef struct _WMT_COLORSPACEINFO_EXTENSION_DATA
{
    BYTE ucColorPrimaries;
    BYTE ucColorTransferChar;
    BYTE ucColorMatrixCoef;
} WMT_COLORSPACEINFO_EXTENSION_DATA;

#pragma pack(pop)

///////////////////////////////////////////////////////////////////////////////
//
// Timecode structures to be used with WM_SampleExtensionGUID_Timecode
// on INSSBuffer3::SetProperty/GetProperty.  The timecode DWORD
// contains the following timecode representation:
//
// BYTE  MSB             LSB
// ----------------------------------------------
// 1     Tens of hour    Hour
// 2     Tens of minute  Minute
// 3     Tens of second  Second
// 4     Tens of frame   Frame
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push)
#pragma pack(2)

typedef struct _WMT_TIMECODE_EXTENSION_DATA
{
    WORD wRange;
    DWORD dwTimecode;
    DWORD dwUserbits;
    DWORD dwAmFlags;
} WMT_TIMECODE_EXTENSION_DATA;

#pragma pack(pop)


///////////////////////////////////////////////////////////////////////////////
//
// WMDRM-ND structures and constants
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _DRM_VAL16
{
    BYTE val[16];

} DRM_VAL16;

///////////////////////////////////////////////////////////////////////////////
//
// IID GUIDs defined here.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMSyncReader,         0x9397f121,0x7705,0x4dc9,0xb0,0x49,0x98,0xb6,0x98,0x18,0x84,0x14 );" )
cpp_quote( "EXTERN_GUID( IID_IWMSyncReader2,        0xfaed3d21,0x1b6b,0x4af7,0x8c,0xb6,0x3e,0x18,0x9b,0xbc,0x18,0x7b );" )
cpp_quote( "EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );" )
cpp_quote( "EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMetadataEditor2,    0x203cffe3,0x2e18,0x4fdf,0xb5,0x9d,0x6e,0x71,0x53,0x05,0x34,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMEditor,          0xFF130EBC,0xA6C3,0x42A6,0xB4,0x01,0xC3,0x38,0x2C,0x3E,0x08,0xB3 );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo3,        0x15CC68E3,0x27CC,0x4ecd,0xB2,0x22,0x3F,0x5D,0x02,0xD8,0x0B,0xD5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManagerLanguage, 0xba4dcc78,0x7ee0,0x4ab8,0xb2,0x7a,0xdb,0xce,0x8b,0xc5,0x14,0x54 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile3,           0x00ef96cc,0xa461,0x4546,0x8b,0xcd,0xc9,0xa2,0x8f,0x0e,0x06,0xf5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamConfig2,      0x7688d8cb,0xfc0d,0x43bd,0x94,0x59,0x5a,0x8d,0xec,0x20,0x0c,0xfa );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamConfig3,      0xcb164104,0x3aa9,0x45a7,0x9a,0xc9,0x4d,0xae,0xe1,0x31,0xd6,0xe1 );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMutualExclusion2,   0x302b57d,0x89d1,0x4ba2,0x85,0xc9,0x16,0x6f,0x2c,0x53,0xeb,0x91 );" )
cpp_quote( "EXTERN_GUID( IID_IWMBandwidthSharing,   0xad694af1,0xf8d9,0x42f8,0xbc,0x47,0x70,0x31,0x1b,0x0c,0x4f,0x9e );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamPrioritization, 0x8c1c6090,0xf9a8,0x4748,0x8e,0xc3,0xdd,0x11,0x08,0xba,0x1e,0x77 );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced3,    0x2cd6492d,0x7c37,0x4e76,0x9d,0x3b,0x59,0x26,0x11,0x83,0xa2,0x2e );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterPreprocess,   0xfc54a285,0x38c4,0x45b5,0xaa,0x23,0x85,0xb9,0xf7,0xcb,0x42,0x4b );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink3,    0x3fea4feb,0x2945,0x47a7,0xa1,0xdd,0xc5,0x3a,0x8f,0xc4,0xc4,0x5c );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );" )
cpp_quote( "EXTERN_GUID( IID_IWMClientConnections2, 0x4091571e,0x4701,0x4593,0xbb,0x3d,0xd5,0xf5,0xf0,0xc7,0x42,0x46 ); " )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced3,    0x5dc0674b,0xf04b,0x4a4e,0x9f,0x2a,0xb1,0xaf,0xde,0x2c,0x81,0x00 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced4,    0x945a76a2,0x12ae,0x4d48,0xbd,0x3c,0xcd,0x1d,0x90,0x39,0x9b,0x85 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced5,    0x24c44db0,0x55d1,0x49ae,0xa5,0xcc,0xf1,0x38,0x15,0xe3,0x63,0x63 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced6,    0x18a2e7f8,0x428f,0x4acd,0x8a,0x00,0xe6,0x46,0x39,0xbc,0x93,0xde );" )
cpp_quote( "EXTERN_GUID( IID_IWMPlayerHook,         0xe5b7ca9a,0x0f1c,0x4f66,0x90,0x02,0x74,0xec,0x50,0xd8,0xb3,0x04 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMReader2,         0xbefe7a75,0x9f1d,0x4075,0xb9,0xd9,0xa3,0xc3,0x7b,0xda,0x49,0xa0 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMReader3,         0xe08672de,0xf1e7,0x4ff4,0xa0,0xa3,0xfc,0x4b,0x08,0xe4,0xca,0xf8 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderPlaylistBurn, 0xf28c0300,0x9baa,0x4477,0xa8,0x46,0x17,0x44,0xd9,0xcb,0xf5,0x33 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMIndexer2,           0xb70f1e42,0x6255,0x4df0,0xa6,0xb9,0x02,0xb2,0x12,0xd9,0xe2,0xbb );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);")
cpp_quote( "EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);")
cpp_quote( "EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);")
cpp_quote( "EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);")
cpp_quote( "EXTERN_GUID( IID_IWMPacketSize2,        0x8bfc2b9e,0xb646,0x4233,0xa8,0x77,0x1c,0x6a,0x7,0x96,0x69,0xdc);")
cpp_quote( "EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);")
cpp_quote( "EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);")
cpp_quote( "EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);")
cpp_quote( "EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);")
cpp_quote( "EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);")
cpp_quote( "EXTERN_GUID( IID_IWMCodecInfo3,         0x7e51f487,0x4d93,0x4f98,0x8a,0xb4,0x27,0xd0,0x56,0x5a,0xdc,0x51);")
cpp_quote( "EXTERN_GUID( IID_IWMPropertyVault,      0x72995A79,0x5090,0x42a4,0x9C,0x8C,0xD9,0xD0,0xB6,0xD3,0x4B,0xE5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMIStreamProps,       0x6816dad3,0x2b4b,0x4c8e,0x81,0x49,0x87,0x4c,0x34,0x83,0xa7,0x53 );" )
cpp_quote( "EXTERN_GUID( IID_IWMLanguageList,       0xdf683f00,0x2d49,0x4d8e,0x92,0xb7,0xfb,0x19,0xf6,0xa0,0xdc,0x57 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMWriter,          0xd6ea5dd0,0x12a0,0x43f4,0x90,0xab,0xa3,0xfd,0x45,0x1e,0x6a,0x07 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMWriter2,         0x38ee7a94,0x40e2,0x4e10,0xaa,0x3f,0x33,0xfd,0x32,0x10,0xed,0x5b );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMWriter3,         0xa7184082,0xa4aa,0x4dde,0xac,0x9c,0xe7,0x5d,0xbd,0x11,0x17,0xce );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterPushSink,      0xdc10e6a5,0x072c,0x467d,0xbf,0x57,0x63,0x30,0xa9,0xdd,0xe1,0x2a );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderNetworkConfig2,0xd979a853,0x042b,0x4050,0x83,0x87,0xc9,0x39,0xdb,0x22,0x01,0x3f );" )
cpp_quote( "EXTERN_GUID( IID_IWMWatermarkInfo,       0x6f497062,0xf2e2,0x4624,0x8e,0xa7,0x9d,0xd4,0x0d,0x81,0xfc,0x8d );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAccelerator,   0xbddc4d08,0x944d,0x4d52,0xa6,0x12,0x46,0xc3,0xfd,0xa0,0x7d,0xd4 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderTimecode,        0xf369e2f0,0xe081,0x4fe6,0x84,0x50,0xb8,0x10,0xb2,0xf4,0x10,0xd1 );" )
cpp_quote( "EXTERN_GUID( IID_IWMImageInfo,            0x9f0aa3b6,0x7267,0x4d89,0x88,0xf2,0xba,0x91,0x5a,0xa5,0xc4,0xc6);" )
cpp_quote( "EXTERN_GUID( IID_IWMAddressAccess,        0xBB3C6389,0x1633,0x4e92,0xAF,0x14,0x9F,0x31,0x73,0xBA,0x39,0xD0 );" )
cpp_quote( "EXTERN_GUID( IID_IWMAddressAccess2,       0x65a83fc2,0x3e98,0x4d4d,0x81,0xb5,0x2a,0x74,0x28,0x86,0xb3,0x3d );" )
cpp_quote( "EXTERN_GUID( IID_IWMDeviceRegistration,   0xf6211f03,0x8d21,0x4e94,0x93,0xe6,0x85,0x10,0x80,0x5f,0x2d,0x99 );" )
cpp_quote( "EXTERN_GUID( IID_IWMRegisteredDevice,     0xa4503bec,0x5508,0x4148,0x97,0xac,0xbf,0xa7,0x57,0x60,0xa7,0x0d );" )
cpp_quote( "EXTERN_GUID( IID_IWMProximityDetection,   0x6A9FD8EE,0xB651,0x4bf0,0xB8,0x49,0x7D,0x4E,0xCE,0x79,0xA2,0xB1 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMMessageParser,     0xa73a0072,0x25a0,0x4c99,0xb4,0xa5,0xed,0xe8,0x10,0x1a,0x6c,0x39 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMTranscryptor,      0x69059850,0x6e6f,0x4bb2,0x80,0x6f,0x71,0x86,0x3d,0xdf,0xc4,0x71 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMTranscryptor2,     0xe0da439f,0xd331,0x496a,0xbe,0xce,0x18,0xe5,0xba,0xc5,0xdd,0x23 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMTranscryptionManager, 0xb1a887b2,0xa4f0,0x407a,0xb0,0x2e,0xef,0xbd,0x23,0xbb,0xec,0xdf );" )
cpp_quote( "EXTERN_GUID( IID_IWMLicenseRevocationAgent, 0x6967f2c9,0x4e26,0x4b57,0x88,0x94,0x79,0x98,0x80,0xf7,0xac,0x7b );" )


///////////////////////////////////////////////////////////////////////////////
//
// Other GUIDs defined here
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Language, 0xD6E22A00,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )
cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )
cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Presentation, 0xD6E22A02,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )
cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Unknown, 0xD6E22A03,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )

cpp_quote( "EXTERN_GUID( CLSID_WMBandwidthSharing_Exclusive, 0xaf6060aa,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );" )
cpp_quote( "EXTERN_GUID( CLSID_WMBandwidthSharing_Partial, 0xaf6060ab,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );" )

cpp_quote( "// {B42CDE2B-6178-4a2c-A375-89DD3FD7F497}" )
cpp_quote( "EXTERN_GUID( WMT_DMOCATEGORY_AUDIO_WATERMARK, 0x65221c5a, 0xfa75, 0x4b39, 0xb5, 0x0c, 0x06, 0xc3, 0x36, 0xb6, 0xa3, 0xef );" )
cpp_quote( "// {E77797C6-18AF-4458-BBDD-492D3F78FC8F}" )
cpp_quote( "EXTERN_GUID( WMT_DMOCATEGORY_VIDEO_WATERMARK, 0x187cc922, 0x8efc, 0x4404, 0x9d, 0xaf, 0x63, 0xf4, 0x83, 0x0d, 0xf1, 0xbc );" )

///////////////////////////////////////////////////////////////////////////////
//
// Max Video Streams / Bands
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "#define WM_MAX_VIDEO_STREAMS            0x3f" )
cpp_quote( "#define WM_MAX_STREAMS                  0x3f" )

///////////////////////////////////////////////////////////////////////////////
//
// Creation functions.
//
// The SDK supports 3 major objects:
// - CLSID_WMWriter - For writing out WM content.
// - CLSID_WMReader - For playing back WM content.
// - CLSID_WMMetadataEditor - For getting and editing header metadata in WM
//   content.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// This function examines a file and determines whether or not it is DRM protected.
//
cpp_quote( "HRESULT STDMETHODCALLTYPE WMIsContentProtected( const WCHAR *pwszFileName, BOOL *pfIsProtected );" )
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateSyncReader( IUnknown* pUnkCert, DWORD dwRights, IWMSyncReader **ppSyncReader );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );" )

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterPushSink( IWMWriterPushSink **ppSink );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateDeviceRegistration( IWMDeviceRegistration **ppDevReg );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateDRMTranscryptor( IWMDRMTranscryptor **ppTranscryptor );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateDRMTranscryptionManager( IWMDRMTranscryptionManager **ppTranscryptionManager );" )

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateLicenseRevocationAgent( IUnknown *pCallback, IWMLicenseRevocationAgent ** ppLicenseRevocationAgent );" )

///////////////////////////////////////////////////////////////////////////////
//
// The following interfaces define the media types that this SDK supports.
// These media types are used by the writer, the reader, and the profile
// object, to identify the media-type specific properties of a media stream.
//
// The main media type is stored in the WM_MEDIA_TYPE structure. Some
// interesting (option) parameters may exist for particular stream types;
// in that case, an IWM<x>MediaProps interface can be used to get and set
// these additional parameters.
//


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMMediaProps : IUnknown
{
    //
    // GetType is provided for convenience; it returns the same as the
    // majortype of the WM_MEDIA_TYPE.
    //
    HRESULT GetType( [out] GUID *pguidType );

    HRESULT GetMediaType( [out] WM_MEDIA_TYPE *pType,
                          [in, out] DWORD *pcbType );

    HRESULT SetMediaType( [in] WM_MEDIA_TYPE *pType );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCF-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMVideoMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMVideoMediaProps : IWMMediaProps
{
    HRESULT GetMaxKeyFrameSpacing( [out] LONGLONG *pllTime );

    HRESULT SetMaxKeyFrameSpacing( [in] LONGLONG llTime );

    HRESULT GetQuality( [out] DWORD *pdwQuality );

    HRESULT SetQuality( [in] DWORD dwQuality );
};

///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMWriter basic interfaces.
//
// Usage scenario is as follows:
// 1) SetProfile to define the configuration.
// 2) Set the outputs.
// 3) Call GetInputCount (which is valid after (1)), and GetInputProps for
//    each stream. Get the default input format, and change it if desired.
// 3.5) Call SetAttribute to add metadata to the header
// At this point, the writer has been configured.
// 4) Call WriteSample repeatedly, until done. (Note that the AllocateSample
//    call is just provided for convenience. You are welcome to pass in your
//    own samples.)
// 5) Call Flush to write out any buffered data, and update the header and
//    index.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriter Interface"),
    pointer_default(unique),
    local
]
interface IWMWriter : IUnknown
{
    // This interface QI's for IWMHeaderInfo, and IWMWriterAdvanced.

    //
    // There are 3 options for setting the profile on the writer. Note that
    // setting the profile means that the profile is copied into the writer.
    // Further editing of that profile object will have no effect, unless
    // SetProfile() is called again.
    //
    // Calling SetProfile() removes any previously set header attribute info
    //
    HRESULT SetProfileByID( [in] REFGUID guidProfile );

    HRESULT SetProfile( [in] IWMProfile *pProfile );

    //
    // The easiest way to use the writer is just to write to file.
    //
    HRESULT SetOutputFilename( [in] const WCHAR *pwszFilename );

    //
    // The user can enumerate through the various inputs, and get the input
    // format. Note that these are not ASF streams; one input stream may map
    // to multiple ASF streams in a MEB scenario.
    //
    // Manipulating the IWMInputMediaProps has no effect on the writer, unless
    // the user calls SetInputProps to configure the input.
    //
    HRESULT GetInputCount( [out] DWORD *pcInputs );

    HRESULT GetInputProps( [in] DWORD dwInputNum,
                           [out] IWMInputMediaProps **ppInput );

    HRESULT SetInputProps( [in] DWORD dwInputNum,
                           [in] IWMInputMediaProps *pInput );

    //
    // Used for determining all possible format types supported by this
    // input on the writer.
    //
    HRESULT GetInputFormatCount(    [in] DWORD dwInputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetInputFormat( [in] DWORD dwInputNumber,
                            [in] DWORD dwFormatNumber,
                            [out] IWMInputMediaProps** pProps );

    //
    // You must call BeginWriting before sending any samples, and
    // you must call EndWriting when you're done sending samples.
    //
    HRESULT BeginWriting();

    //
    // EndWriting flushes everything, updates indices and headers,
    // and closes the file.
    //
    HRESULT EndWriting();

    //
    // Allocate a sample. This is optional; the user is welcome to allocate
    // their own buffer class.
    //
    HRESULT AllocateSample( [in] DWORD dwSampleSize,
                            [out] INSSBuffer **ppSample );

    HRESULT WriteSample( [in] DWORD dwInputNum,
                         [in] QWORD cnsSampleTime,
                         [in] DWORD dwFlags,
                         [in] INSSBuffer *pSample );

    //
    // Flush() will flush the writer, but leaves the writer prepared to run
    // again, when WriteSample() is called again.
    // Flush() also causes an updated header to be sent to the sink.
    //
    HRESULT Flush();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( d6ea5dd0-12a0-43f4-90ab-a3fd451e6a07 ),
    helpstring( "IWMDRMWriter Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides helpers
// to generate DRM keys.
//
interface IWMDRMWriter : IUnknown
{
    HRESULT GenerateKeySeed( [out, size_is( *pcwchLength )] WCHAR *pwszKeySeed,
                             [in, out] DWORD *pcwchLength );

    HRESULT GenerateKeyID( [out, size_is( *pcwchLength )] WCHAR *pwszKeyID,
                           [in, out] DWORD *pcwchLength );

    HRESULT GenerateSigningKeyPair( [out, size_is( *pcwchPrivKeyLength )] WCHAR *pwszPrivKey,
                                    [in, out] DWORD *pcwchPrivKeyLength,
                                    [out, size_is( *pcwchPubKeyLength )] WCHAR *pwszPubKey,
                                    [in, out] DWORD *pcwchPubKeyLength );

    HRESULT SetDRMAttribute( [in] WORD wStreamNum,
                             [in] LPCWSTR pszName,
                             [in] WMT_ATTR_DATATYPE Type,
                             [in, size_is( cbLength )] const BYTE *pValue,
                             [in] WORD cbLength );
};

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "#ifndef WMDRM_IMPORT_INIT_STRUCT_DEFINED" )
cpp_quote( "#define WMDRM_IMPORT_INIT_STRUCT_DEFINED 1")
typedef struct WMDRM_IMPORT_INIT_STRUCT
{
    DWORD    dwVersion;
    DWORD    cbEncryptedSessionKeyMessage;
    BYTE    *pbEncryptedSessionKeyMessage;
    DWORD    cbEncryptedKeyMessage;
    BYTE    *pbEncryptedKeyMessage;
} WMDRM_IMPORT_INIT_STRUCT;
cpp_quote( "#endif // WMDRM_IMPORT_INIT_STRUCT_DEFINED" )

[
    object,
    uuid( 38ee7a94-40e2-4e10-aa3f-33fd3210ed5b ),
    helpstring( "IWMDRMWriter2 Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMWriter2 : IWMDRMWriter
{
    HRESULT SetWMDRMNetEncryption( [in] BOOL fSamplesEncrypted,
                                   [in] BYTE *pbKeyID,
                                   [in] DWORD cbKeyID );
}

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( a7184082-a4aa-4dde-ac9c-e75dbd1117ce ),
    helpstring( "IWMDRMWriter3 Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMWriter3 : IWMDRMWriter2
{
    HRESULT SetProtectStreamSamples( [in] WMDRM_IMPORT_INIT_STRUCT *pImportInitStruct );
}

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMInputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMInputMediaProps : IWMMediaProps
{
    HRESULT GetConnectionName( [out, size_is( *pcchName )] WCHAR *pwszName,
                               [in, out] WORD *pcchName );

    HRESULT GetGroupName( [out, size_is( *pcchName )] WCHAR *pwszName,
                          [in, out] WORD *pcchName );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 72995A79-5090-42a4-9C8C-D9D0B6D34BE5 ),
    helpstring( "IWMPropertyVault Interface"),
    pointer_default(unique),
    local
]
interface IWMPropertyVault : IUnknown
{
    HRESULT GetPropertyCount(
                              [in] DWORD   *pdwCount );

    HRESULT GetPropertyByName(
                              [in] LPCWSTR pszName,
                              [out] WMT_ATTR_DATATYPE *pType,
                              [out, size_is( *pdwSize )] BYTE *pValue,
                              [in, out] DWORD *pdwSize );

    HRESULT SetProperty(
                              [in] LPCWSTR pszName,
                              [in] WMT_ATTR_DATATYPE pType,
                              [in] BYTE *pValue,
                              [in] DWORD dwSize );

    HRESULT GetPropertyByIndex(
                              [in] DWORD   dwIndex,
                              [out, size_is( *pdwNameLen )] LPWSTR pszName,
                              [in, out]  DWORD *pdwNameLen,
                              [out] WMT_ATTR_DATATYPE *pType,
                              [out, size_is( *pdwSize )] BYTE *pValue,
                              [in, out] DWORD *pdwSize );

    HRESULT CopyPropertiesFrom(
                              [in] IWMPropertyVault    *pIWMPropertyVault );

    HRESULT Clear();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6816dad3-2b4b-4c8e-8149-874c3483a753 ),
    helpstring( "IWMIStreamProps Interface"),
    pointer_default(unique),
    local
]
interface IWMIStreamProps : IUnknown
{
    HRESULT GetProperty(      [in] LPCWSTR pszName,
                              [out] WMT_ATTR_DATATYPE *pType,
                              [out, size_is( *pdwSize )] BYTE *pValue,
                              [in, out] DWORD *pdwSize );
};

///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMReader basic interfaces.
//
// Usage is as follows:
// 1) Call Open with a URL (possibly a local filename) and a user-supplied
//    callback. After open has completed, the file has been opened and parsed.
// 2) Call GetOutputCount, and GetOutputProps for each output. This
//    is valid after (1). This allows the user to get the output format for
//    each output.
// 3) Call Start. Status messages and samples will begin arriving in the
//    callback function.
// 4) Continue with any combination of Start/Stop/Pause, until finished.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD6-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReader Interface"),
    pointer_default(unique),
    local
]
interface IWMReader : IUnknown
{
    //
    // This interface QI's for IWMHeaderInfo, IWMProfile, IWMReaderAdvanced,
    // IWMReaderAdvanced2, and IWMReaderAdvanced3.
    //

    //
    // Open is an asynch call; it returns almost immediately (if the URL
    // is valid), and the user should wait for appropriate OnStatus calls to
    // be sent to the callback.
    //
    HRESULT Open( [in] const WCHAR *pwszURL,
                  [in] IWMReaderCallback *pCallback,
                  [in] void *pvContext );

    HRESULT Close();

    //
    // The user can enumerate through the various outputs, and get the
    // output format for that data.
    //
    // Manipulating the IWMOutputMediaProps has no effect on the output, unless
    // the user also calls SetOutputProps.
    //
    HRESULT GetOutputCount( [out] DWORD *pcOutputs );

    HRESULT GetOutputProps( [in] DWORD dwOutputNum,
                            [out] IWMOutputMediaProps **ppOutput );

    HRESULT SetOutputProps( [in] DWORD dwOutputNum,
                            [in] IWMOutputMediaProps *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader.
    //
    HRESULT GetOutputFormatCount(   [in] DWORD dwOutputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetOutputFormat( [in] DWORD dwOutputNumber,
                             [in] DWORD dwFormatNumber,
                             [out] IWMOutputMediaProps** ppProps );

    //
    // If duration is 0, play to the end of the file.
    // If msStart is set to WM_START_CURRENTPOSITION then don't perform a seek
    // operation.  A good use for this is when you want to change the rate but
    // not the current file position.
    //
    // Note that any call to start while Paused will be treated as a seek.
    // Even calls to Start( WM_START_CURRENTPOSITION, ... ).  If your intention
    // is to seek (which will incur the buffering penalty from network files)
    // then you can go ahead and call Start.  However, if your intention was
    // to continue playing from where the user paused, you should call Resume
    // instead.
    //
    HRESULT Start( [in] QWORD cnsStart,
                   [in] QWORD cnsDuration,
                   [in] float fRate,
                   [in] void *pvContext );

    HRESULT Stop();

    HRESULT Pause();

    HRESULT Resume();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 9397F121-7705-4dc9-B049-98B698188414 ),
    helpstring( "IWMSyncReader interface" ),
    pointer_default( unique ),
    local
]
interface IWMSyncReader : IUnknown
{
    //
    // This interface can be QI'ed for IWMProfile, IWMHeaderInfo and
    // IWMReaderTimecode interfaces
    //

    //
    // Open is an synchronous call. We do not support streaming at this time.
    // All open with http:// etc would fail. We do support MP3 or Windows
    // media files from both local file or UNC path.
    //
    HRESULT Open( [in] const WCHAR *pwszFilename );

    HRESULT Close();

    //
    // SetRange is basically a seek method, you can only set same range
    // for all streams. Use cnsDuration=0 to specify reading to end of file.
    //
    HRESULT SetRange(   [in]  QWORD     cnsStartTime,
                        [in]  LONGLONG  cnsDuration );

    //
    // SetRangeByFrame is frame-based access, the file has to be frame
    // indexed to succeeded this call. If the call is successful, all
    // streams are synchronized to the same position based on time.
    // Also use cFramesToRead=0 to specify reading to end of file.
    //
    HRESULT SetRangeByFrame(    [in]  WORD      wStreamNum,
                                [in]  QWORD     qwFrameNumber,
                                [in]  LONGLONG  cFramesToRead );

    //
    // If a valid stream number is specified, next sample from that stream
    // will be returned, pwStreamNum can be NULL in this case. Otherwise,
    // GetNextSample returns the next sample in time line (regardless of
    // which stream). The sample's stream number will be returned.
    // Time line is presentation time if no output setting is specified.
    // To get early delivery for some stream, use SetOutputSetting
    //
    HRESULT GetNextSample(  [in]  WORD           wStreamNum,
                            [out] INSSBuffer   **ppSample,
                            [out] QWORD         *pcnsSampleTime,
                            [out] QWORD         *pcnsDuration,
                            [out] DWORD         *pdwFlags,
                            [out] DWORD         *pdwOutputNum,
                            [out] WORD          *pwStreamNum );

    //
    // Stream selection methods are the same as asynchronous interface
    //
    HRESULT SetStreamsSelected( [in]  WORD                  cStreamCount,
                                [in]  WORD                 *pwStreamNumbers,
                                [in]  WMT_STREAM_SELECTION *pSelections );

    HRESULT GetStreamSelected( [in]  WORD                   wStreamNum,
                               [out] WMT_STREAM_SELECTION  *pSelection );

    HRESULT SetReadStreamSamples( [in]  WORD    wStreamNum,
                                  [in]  BOOL    fCompressed );

    HRESULT GetReadStreamSamples( [in]  WORD    wStreamNum,
                                  [out] BOOL   *pfCompressed );

    //
    // The following two methods are the same as the ones in
    // IWMReaderAdvanced2 interface. We don't support JustInTimeDecode
    // in this interface
    //
    HRESULT GetOutputSetting(   [in]     DWORD              dwOutputNum,
                                [in]     LPCWSTR            pszName,
                                [out]    WMT_ATTR_DATATYPE *pType,
                                [out, size_is( *pcbLength )]    BYTE              *pValue,
                                [in, out] WORD              *pcbLength );

    //
    // Sets a named setting for a particular output
    //
    HRESULT SetOutputSetting(   [in] DWORD              dwOutputNum,
                                [in] LPCWSTR            pszName,
                                [in] WMT_ATTR_DATATYPE  Type,
                                [in, size_is( cbLength )] const BYTE        *pValue,
                                [in] WORD               cbLength );

    //
    // The following methods are important for receiving uncompressed samples,
    // they are identical to methods in asynchronous Reader interface.
    //
    HRESULT GetOutputCount( [out] DWORD                *pcOutputs );

    HRESULT GetOutputProps( [in]  DWORD                 dwOutputNum,
                            [out] IWMOutputMediaProps **ppOutput );

    HRESULT SetOutputProps( [in]  DWORD                 dwOutputNum,
                            [in]  IWMOutputMediaProps  *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader.
    //
    HRESULT GetOutputFormatCount( [in]  DWORD   dwOutputNum,
                                  [out] DWORD  *pcFormats );

    HRESULT GetOutputFormat( [in]  DWORD                    dwOutputNum,
                             [in]  DWORD                    dwFormatNum,
                             [out] IWMOutputMediaProps    **ppProps );

    //
    // Methods provided to relate output numbers with stream numbers
    //
    HRESULT GetOutputNumberForStream(   [in]  WORD      wStreamNum,
                                        [out] DWORD    *pdwOutputNum );

    HRESULT GetStreamNumberForOutput(   [in]  DWORD     dwOutputNum,
                                        [out] WORD     *pwStreamNum );

    HRESULT GetMaxOutputSampleSize( [in]  DWORD     dwOutput,
                                    [out] DWORD    *pcbMax );

    HRESULT GetMaxStreamSampleSize( [in]  WORD      wStream,
                                    [out] DWORD    *pcbMax );

    //
    // Same as IWMSyncReader::Open but takes an IStream interface pointer
    // instead of an file name to be opened. This method is typically
    // used for custom source.
    //
    HRESULT OpenStream( [in] IStream    *pStream );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( faed3d21-1b6b-4af7-8cb6-3e189bbc187b ),
    helpstring( "IWMSyncReader2 interface" ),
    pointer_default( unique ),
    local
]
interface IWMSyncReader2 : IWMSyncReader
{
    //
    // SetRangeByTimecode is timecode-based access, the file has to be timecode
    // indexed to succeeded this call. If the call is successful, all
    // streams are synchronized to the same position based on presentation
    // time.
    //
    HRESULT SetRangeByTimecode( [in] WORD wStreamNum,
                                [in] WMT_TIMECODE_EXTENSION_DATA *pStart,
                                [in] WMT_TIMECODE_EXTENSION_DATA *pEnd );

    //
    // SetRangeByFrame is frame-based access, the file has to be frame
    // indexed to succeeded this call. If the call is successful, all
    // streams are synchronized to the same position based on time.
    // Also use cFramesToRead=0 to specify reading to end of file.
    //
    HRESULT SetRangeByFrameEx(  [in]  WORD      wStreamNum,
                                [in]  QWORD     qwFrameNumber,
                                [in]  LONGLONG  cFramesToRead,
                                [out]  QWORD    *pcnsStartTime );

    //
    // The following four methods are for user buffer allocations
    //
    HRESULT SetAllocateForOutput( [in]  DWORD dwOutputNum,
                                  [in]  IWMReaderAllocatorEx *pAllocator );

    HRESULT GetAllocateForOutput( [in]  DWORD dwOutputNum,
                                  [out] IWMReaderAllocatorEx **ppAllocator );

    HRESULT SetAllocateForStream( [in]  WORD wStreamNum,
                                  [in]  IWMReaderAllocatorEx *pAllocator );

    HRESULT GetAllocateForStream( [in]  WORD dwSreamNum,
                                  [out] IWMReaderAllocatorEx **ppAllocator );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMOutputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMOutputMediaProps : IWMMediaProps
{
    //
    // A Stream Group and type together uniquely identify each output. (The
    // type is on IWMMediaProps).
    //
    HRESULT GetStreamGroupName( [out, size_is( *pcchName )] WCHAR *pwszName,
                                [in, out] WORD *pcchName );

    HRESULT GetConnectionName( [out, size_is( *pcchName )] WCHAR *pwszName,
                               [in, out] WORD *pcchName );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc70-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMStatusCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMStatusCallback : IUnknown
{
    //
    // The contents of pValue depends on the Status.
    //
    HRESULT OnStatus( [in] WMT_STATUS Status,
                      [in] HRESULT hr,
                      [in] WMT_ATTR_DATATYPE dwType,
                      [in] BYTE *pValue,
                      [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD8-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderCallback : IWMStatusCallback
{
    //
    // cnsSampleDuration will be 0 for most media types.
    //
    HRESULT OnSample( [in] DWORD dwOutputNum,
                      [in] QWORD cnsSampleTime,
                      [in] QWORD cnsSampleDuration,
                      [in] DWORD dwFlags,
                      [in] INSSBuffer *pSample,
                      [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 342e0eb7-e651-450c-975b-2ace2c90c48e ),
    helpstring( "IWMCredentialCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMCredentialCallback : IUnknown
{
    HRESULT AcquireCredentials( [in] WCHAR *pwszRealm,
                                [in] WCHAR *pwszSite,
                                [out, size_is( cchUser )] WCHAR *pwszUser,
                                [in] DWORD cchUser,
                                [out, size_is( cchPassword )] WCHAR *pwszPassword,
                                [in] DWORD cchPassword,
                                [in] HRESULT hrStatus,
                                [out] DWORD *pdwFlags );    // Combination of WMT_CREDENTIAL_FLAGS
};

///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMMetadataEditor basic interfaces.
//
// Usage:
// 1) Call Open with a filename.
// 2) QI for IWMHeaderInfo, and use that to get and set attributes as
//    needed.
// 3) Flush() will cause any changes to be written back to disk (if possible).
// 4) Close() closes the file without writing any changes to disk.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD9-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMetadataEditor Interface"),
    pointer_default(unique),
    local
]
interface IWMMetadataEditor : IUnknown
{
    // QI this for IWMHeaderInfo to edit the header attributes.

    //
    // Manage the file
    //
    HRESULT Open( [in] const WCHAR *pwszFilename );

    HRESULT Close();

    HRESULT Flush();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 203CFFE3-2E18-4fdf-B59D-6E71530534CF ),
    helpstring( "IWMMetadataEditor2 Interface" ),
    pointer_default(unique),
    local
]
interface IWMMetadataEditor2 : IWMMetadataEditor
{
    //
    // The flags to dwDesiredAccess and dwShareMode match the flags to
    // (the win32 API) CreateFile.
    //
    // Supported combinations are:
    //
    //   dwDesiredAccess               dwShareMode
    //   ----------------------------  -----------
    //   GENERIC_READ | GENERIC_WRITE  0
    //   GENERIC_READ | GENERIC_WRITE  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE
    //   GENERIC_READ                  0
    //   GENERIC_READ                  FILE_SHARE_READ
    //   GENERIC_READ                  FILE_SHARE_DELETE
    //   GENERIC_READ                  FILE_SHARE_READ | FILE_SHARE_DELETE
    //
    HRESULT OpenEx( [in] const WCHAR *pwszFilename,
                    [in] DWORD dwDesiredAccess,
                    [in] DWORD dwShareMode );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( FF130EBC-A6C3-42A6-B401-C3382C3E08B3 ),
    helpstring( "IWMDRMEditor Interface" ),
    pointer_default(unique),
    local
]
interface IWMDRMEditor: IUnknown
{
    //
    // For accessing DRM properties from the metadata editor.
    //

    HRESULT GetDRMProperty( [in] LPCWSTR pwstrName,
                            [out] WMT_ATTR_DATATYPE* pdwType,
                            [out, size_is( *pcbLength )] BYTE *pValue,
                            [in, out] WORD *pcbLength );
};

///////////////////////////////////////////////////////////////////////////////
//
// Below are utility interfaces used across all 3 of the main objects.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMHeaderInfo Interface"),
    pointer_default(unique),
    local
]
//
// The 3 main interface (IWMWriter, IWMReader, and
// IWMMetadataEditor) can be QI'd for this interface to get and set
// header attributes, and markers.
//
interface IWMHeaderInfo : IUnknown
{
    //
    // For attributes, the stream number passed in means:
    // -1 (0xffff) to specifies "any or no stream".
    // 0 specifies "no stream".
    // Any other value indicates the stream number.
    //
    // Windows Media version 4 and earlier does not support per stream
    // attributes, so any stream number other than 0 will fail.
    //
    HRESULT GetAttributeCount( [in] WORD wStreamNum,
                               [out] WORD *pcAttributes );

    HRESULT GetAttributeByIndex( [in] WORD wIndex,
                                 [in, out] WORD *pwStreamNum,
                                 [out, size_is( *pcchNameLen )] WCHAR *pwszName,
                                 [in, out] WORD *pcchNameLen,
                                 [out] WMT_ATTR_DATATYPE *pType,
                                 [out, size_is( *pcbLength )] BYTE *pValue,
                                 [in, out] WORD *pcbLength );

    HRESULT GetAttributeByName( [in, out] WORD *pwStreamNum,
                                [in] LPCWSTR pszName,
                                [out] WMT_ATTR_DATATYPE *pType,
                                [out, size_is( *pcbLength )] BYTE *pValue,
                                [in, out] WORD *pcbLength );

    HRESULT SetAttribute( [in] WORD wStreamNum,
                          [in] LPCWSTR pszName,
                          [in] WMT_ATTR_DATATYPE Type,
                          [in, size_is( cbLength )] const BYTE *pValue,
                          [in] WORD cbLength );

    //
    // Marker methods.
    //
    HRESULT GetMarkerCount( [out] WORD *pcMarkers );

    HRESULT GetMarker( [in] WORD wIndex,
                       [out, size_is( *pcchMarkerNameLen )] WCHAR *pwszMarkerName,
                       [in, out] WORD *pcchMarkerNameLen,
                       [out] QWORD *pcnsMarkerTime );

    HRESULT AddMarker( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszMarkerName,
                       [in] QWORD cnsMarkerTime );

    HRESULT RemoveMarker( [in] WORD wIndex );

    //
    // Script command methods.
    //
    HRESULT GetScriptCount( [out] WORD *pcScripts );

    HRESULT GetScript( [in] WORD wIndex,
                       [out, size_is( *pcchTypeLen )] WCHAR *pwszType,
                       [in, out] WORD *pcchTypeLen,
                       [out, size_is( *pcchCommandLen )] WCHAR *pwszCommand,
                       [in, out] WORD *pcchCommandLen,
                       [out] QWORD *pcnsScriptTime );

    HRESULT AddScript( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszType,
                       [in] LPCWSTR_WMSDK_TYPE_SAFE pwszCommand,
                       [in] QWORD cnsScriptTime );

    HRESULT RemoveScript( [in] WORD wIndex );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 15CF9781-454E-482e-B393-85FAE487A810 ),
    helpstring( "IWMHeaderInfo2 Interface"),
    pointer_default(unique),
    local
]
//
// The 3 main interface (IWMWriter, IWMReader, and
// IWMMetadataEditor) can be QI'd for this interface to get and set
// header attributes, and markers.
//
interface IWMHeaderInfo2 : IWMHeaderInfo
{
    HRESULT GetCodecInfoCount(  [out] DWORD* pcCodecInfos );

    HRESULT GetCodecInfo(       [in] DWORD   wIndex,
                                [in, out] WORD* pcchName,
                                [out, size_is( *pcchName )] WCHAR*  pwszName,
                                [in, out] WORD* pcchDescription,
                                [out, size_is( *pcchDescription )] WCHAR*  pwszDescription,
                                [out] WMT_CODEC_INFO_TYPE* pCodecType,
                                [in, out] WORD* pcbCodecInfo,
                                [out, size_is( *pcbCodecInfo )] BYTE* pbCodecInfo );
};

///////////////////////////////////////////////////////////////////////////////
//
// IWMHeaderInfo3 - V9 metadata features. This interface extends IWMHeaderInfo
// functionality:
//  - allows >64k attributes;
//  - allows multiple attributes with the same name;
//  - works with attribute languages.
//
///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 15CC68E3-27CC-4ecd-B222-3F5D02D80BD5 ),
    helpstring( "IWMHeaderInfo3 Interface"),
    pointer_default(unique),
    local
]
interface IWMHeaderInfo3 : IWMHeaderInfo2
{
    HRESULT GetAttributeCountEx(
                            [in] WORD wStreamNum,
                            [out] WORD *pcAttributes );

    HRESULT GetAttributeIndices(
                            [in] WORD wStreamNum,
                            [in] LPCWSTR pwszName,
                            [in] WORD *pwLangIndex,
                            [out, size_is( *pwCount )] WORD *pwIndices,
                            [in, out] WORD *pwCount );

   HRESULT GetAttributeByIndexEx(
                            [in] WORD wStreamNum,
                            [in] WORD wIndex,
                            [out, size_is( *pwNameLen )] LPWSTR pwszName,
                            [in, out] WORD *pwNameLen,
                            [out] WMT_ATTR_DATATYPE *pType,
                            [out] WORD *pwLangIndex,
                            [out, size_is( *pdwDataLength )] BYTE *pValue,
                            [in, out] DWORD *pdwDataLength );

    HRESULT ModifyAttribute(
                            [in] WORD wStreamNum,
                            [in] WORD wIndex,
                            [in] WMT_ATTR_DATATYPE Type,
                            [in] WORD wLangIndex,
                            [in, size_is( dwLength )] const BYTE *pValue,
                            [in] DWORD dwLength );

    HRESULT AddAttribute(
                            [in] WORD wStreamNum,
                            [in] LPCWSTR pszName,
                            [out] WORD *pwIndex,
                            [in] WMT_ATTR_DATATYPE Type,
                            [in] WORD wLangIndex,
                            [in, size_is( dwLength )] const BYTE *pValue,
                            [in] DWORD dwLength );

    HRESULT DeleteAttribute(
                            [in] WORD wStreamNum,
                            [in] WORD wIndex );

    HRESULT AddCodecInfo(
                            [in] LPCWSTR_WMSDK_TYPE_SAFE pwszName,
                            [in] LPCWSTR_WMSDK_TYPE_SAFE pwszDescription,
                            [in] WMT_CODEC_INFO_TYPE codecType,
                            [in] WORD cbCodecInfo,
                            [in, size_is( cbCodecInfo )] BYTE *pbCodecInfo );
};

///////////////////////////////////////////////////////////////////////////////
//
// The profile API. The intention is that most users don't touch the profile
// API, but just use pre-existing profiles.
//
// Profiles define authoring configurations, such as stream types, bitrates,
// etc.
//
///////////////////////////////////////////////////////////////////////////////


[
    object,
    uuid( d16679f2-6ca0-472d-8d31-2f5d55aee155 ),
    helpstring( "IWMProfileManager Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManager : IUnknown
{
    //
    // Create a profile with nothing in it.
    //
    HRESULT CreateEmptyProfile( [in] WMT_VERSION dwVersion,
                                [out] IWMProfile **ppProfile );

    //
    // Load a system profile given its ID.
    //
    HRESULT LoadProfileByID( [in] REFGUID guidProfile,
                             [out] IWMProfile **ppProfile );

    //
    // Load a profile from a stored string.
    //
    HRESULT LoadProfileByData( [in] const WCHAR *pwszProfile,
                               [out] IWMProfile **ppProfile );

    //
    // Save profile specified by its string.
    //
    HRESULT SaveProfile( [in] IWMProfile *pIWMProfile,
                         [in] WCHAR *pwszProfile,
                         [in, out] DWORD *pdwLength );

    //
    // Iterate through the system profiles.
    //
    HRESULT GetSystemProfileCount( [out] DWORD *pcProfiles );

    HRESULT LoadSystemProfile( [in] DWORD dwProfileIndex,
                               [out] IWMProfile **ppProfile );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 7A924E51-73C1-494d-8019-23D37ED9B89A ),
    helpstring( "IWMProfileManager2 Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManager2 : IWMProfileManager
{
    //
    // Set the version number of the system profiles that the profile manager
    // will enumerate. WMT_VER_4_0 is the default, for compatibility reasons,
    // so be sure to set this to the latest version if that is the desired
    // result.
    //
    HRESULT GetSystemProfileVersion( WMT_VERSION *pdwVersion );
    HRESULT SetSystemProfileVersion( WMT_VERSION dwVersion );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( BA4DCC78-7EE0-4ab8-B27A-DBCE8BC51454 ),
    helpstring( "IWMProfileManagerLanguage Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManagerLanguage : IUnknown
{
    //
    // Set the language ID that user prefers to use, it must be a valid
    // LANGID we support and the corresponding localized profile must
    // present. Or we'll use English as default
    //
    HRESULT GetUserLanguageID( WORD *wLangID );
    HRESULT SetUserLanguageID( WORD wLangID );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMProfile Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile : IUnknown
{
    //
    // By default, when the user creates a profile, it will use the latest
    // version of Windows Media. To create a backward-compatible profile,
    // call IWMProfileManager::CreateEmptyProfile with the appropriate version
    // number.
    //
    HRESULT GetVersion( [out] WMT_VERSION *pdwVersion );

    //
    // Profiles have names and descriptions, for use when displaying lists
    // of profiles, etc.
    //
    HRESULT GetName( [out, size_is( *pcchName )] WCHAR *pwszName,
                     [in, out] DWORD *pcchName );

    HRESULT SetName( [in] const WCHAR *pwszName );

    HRESULT GetDescription( [out, size_is( *pcchDescription )] WCHAR *pwszDescription,
                            [in, out] DWORD *pcchDescription );

    HRESULT SetDescription( [in] const WCHAR *pwszDescription );

    //
    // Methods for enumerating the streams. Note that updating the
    // returned IWMStreamConfig has no effect on the profile until you
    // call ReconfigStream().
    //
    HRESULT GetStreamCount( [out] DWORD *pcStreams );

    HRESULT GetStream( [in] DWORD dwStreamIndex,
                       [out] IWMStreamConfig **ppConfig );

    HRESULT GetStreamByNumber( [in] WORD wStreamNum,
                               [out] IWMStreamConfig **ppConfig );
    //
    // Remove a stream.
    //
    HRESULT RemoveStream( [in] IWMStreamConfig *pConfig );

    HRESULT RemoveStreamByNumber( [in] WORD wStreamNum );

    //
    // Adding a stream copies the config into the profile.
    //
    HRESULT AddStream( [in] IWMStreamConfig *pConfig );

    HRESULT ReconfigStream( [in] IWMStreamConfig *pConfig );

    //
    // Create a new stream config object (avoiding the need to CoCreate).
    // This will still need to be added to the profile using the AddStream()
    // call (but only after it has been configured).
    //
    HRESULT CreateNewStream( [in] REFGUID guidStreamType,
                             [out] IWMStreamConfig **ppConfig );

    //
    // Mutual Exclusion. As above, only Add and Remove actual change the
    // profile.
    //
    HRESULT GetMutualExclusionCount( [out] DWORD *pcME );

    HRESULT GetMutualExclusion( [in] DWORD dwMEIndex,
                                [out] IWMMutualExclusion **ppME );

    HRESULT RemoveMutualExclusion( [in] IWMMutualExclusion *pME );

    HRESULT AddMutualExclusion( [in] IWMMutualExclusion *pME );

    HRESULT CreateNewMutualExclusion( [out] IWMMutualExclusion **ppME );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 07E72D33-D94E-4be7-8843-60AE5FF7E5F5 ),
    helpstring( "IWMProfile2 Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile2 : IWMProfile
{
    //
    // Get/set this profile's unique identifier
    //
    HRESULT GetProfileID( [out] GUID*       pguidID );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid(00EF96CC-A461-4546-8BCD-C9A28F0E06F5),
    helpstring("IWMProfile3 Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile3 : IWMProfile2
{
    //
    // Get/set the storage format.  These calls have been deprecated.
    // Query the WM/ContainerFormat attribute instead.
    //
    HRESULT GetStorageFormat([out] WMT_STORAGE_FORMAT *pnStorageFormat);

    HRESULT SetStorageFormat([in] WMT_STORAGE_FORMAT nStorageFormat);

    //
    // Bandwidth sharing. Only Add and Remove actually change the
    // profile.
    //
    HRESULT GetBandwidthSharingCount( [out] DWORD *pcBS );

    HRESULT GetBandwidthSharing( [in] DWORD dwBSIndex,
                                [out] IWMBandwidthSharing **ppBS );

    HRESULT RemoveBandwidthSharing( [in] IWMBandwidthSharing *pBS );

    HRESULT AddBandwidthSharing( [in] IWMBandwidthSharing *pBS );

    HRESULT CreateNewBandwidthSharing( [out] IWMBandwidthSharing **ppBS );

    //
    // Stream prioritization.  Only Set and Remove actually
    // change the profile.
    // Note that there can be at most one such object.
    //
    HRESULT GetStreamPrioritization( [out] IWMStreamPrioritization **ppSP );

    HRESULT SetStreamPrioritization( [in] IWMStreamPrioritization *pSP );

    HRESULT RemoveStreamPrioritization();

    HRESULT CreateNewStreamPrioritization( [out] IWMStreamPrioritization **ppSP);

    //
    // Get information about how the muxing will be done
    //
    HRESULT GetExpectedPacketCount( [in] QWORD msDuration,
                                    [out] QWORD *pcPackets );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDC-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamConfig Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamConfig represents an ASF stream.
//
interface IWMStreamConfig : IUnknown
{
    // This interface QI's for IWMMediaProps and one of it's inheritors.
    // (IWMVideoMediaProps, for instance).

    HRESULT GetStreamType( [out] GUID *pguidStreamType );

    HRESULT GetStreamNumber( [out] WORD *pwStreamNum );

    HRESULT SetStreamNumber( [in] WORD wStreamNum );

    HRESULT GetStreamName( [out, size_is( *pcchStreamName )] WCHAR *pwszStreamName,
                           [in, out] WORD *pcchStreamName );

    HRESULT SetStreamName( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszStreamName );

    HRESULT GetConnectionName( [out, size_is( *pcchInputName )] WCHAR *pwszInputName,
                               [in, out] WORD *pcchInputName );

    HRESULT SetConnectionName( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszInputName );

    HRESULT GetBitrate( [out] DWORD *pdwBitrate );

    HRESULT SetBitrate( [in] DWORD pdwBitrate );

    //
    // A buffer window of -1 (0xffffffff) indicates that the buffer window
    // is unknown. On the writer side, this means the writer can use whatever
    // buffer window it chooses.
    //
    HRESULT GetBufferWindow( [out] DWORD *pmsBufferWindow );

    HRESULT SetBufferWindow( [in] DWORD msBufferWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 7688D8CB-FC0D-43BD-9459-5A8DEC200CFA ),
    helpstring( "IWMStreamConfig2 Interface"),
    pointer_default(unique),
    local
]
interface IWMStreamConfig2 : IWMStreamConfig
{
    //
    // Get/set the type of data communication protocol (reliable or unreliable)
    //
    HRESULT GetTransportType ([out] WMT_TRANSPORT_TYPE *pnTransportType);

    HRESULT SetTransportType([in] WMT_TRANSPORT_TYPE nTransportType);

    //
    // Add/Get data unit extension systems (for attaching user-defined
    // data to samples in the output file)
    //
    HRESULT AddDataUnitExtension(       [in]    GUID    guidExtensionSystemID,
                                        [in]    WORD    cbExtensionDataSize,
                                        [in, size_is( cbExtensionSystemInfo )]    BYTE    *pbExtensionSystemInfo,
                                        [in]    DWORD   cbExtensionSystemInfo );

    HRESULT GetDataUnitExtensionCount(  [out]   WORD    *pcDataUnitExtensions );

    HRESULT GetDataUnitExtension(       [in]    WORD    wDataUnitExtensionNumber,
                                        [out]   GUID    *pguidExtensionSystemID,
                                        [out]   WORD    *pcbExtensionDataSize,
                                        [out, size_is( *pcbExtensionSystemInfo )]   BYTE    *pbExtensionSystemInfo,
                                        [in, out]   DWORD   *pcbExtensionSystemInfo );

    HRESULT RemoveAllDataUnitExtensions();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( CB164104-3AA9-45a7-9AC9-4DAEE131D6E1 ),
    helpstring( "IWMStreamConfig3 Interface"),
    pointer_default(unique),
    local
]
interface IWMStreamConfig3 : IWMStreamConfig2
{
    //
    // Get/set language info for this stream as an RFC1766 string.
    //

    HRESULT GetLanguage(    [out, size_is( *pcchLanguageStringLength )]   WCHAR *pwszLanguageString,
                            [in, out] WORD *pcchLanguageStringLength );

    HRESULT SetLanguage(    [in] LPCWSTR_WMSDK_TYPE_SAFE pwszLanguageString );
}


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( CDFB97AB-188F-40b3-B643-5B7903975C59 ),
    helpstring( "IWMPacketSize Interface"),
    pointer_default(unique),
    local
]
//
// Controls how big packets can get in an ASF file.
//
interface IWMPacketSize : IUnknown
{
    HRESULT GetMaxPacketSize( [out] DWORD *pdwMaxPacketSize );

    HRESULT SetMaxPacketSize( [in]  DWORD dwMaxPacketSize );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 8BFC2B9E-B646-4233-A877-1C6A079669DC ),
    helpstring( "IWMPacketSize2 Interface"),
    pointer_default(unique),
    local
]
//
// Controls how small packets can get in an ASF file.
//
interface IWMPacketSize2 : IWMPacketSize
{
    HRESULT GetMinPacketSize(   [out] DWORD *pdwMinPacketSize );

    HRESULT SetMinPacketSize(   [in]  DWORD dwMinPacketSize );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDD-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamList Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamList is used for the various objects that define relationships
// between streams.
//
interface IWMStreamList : IUnknown
{
    HRESULT GetStreams( [out, size_is( *pcStreams )] WORD *pwStreamNumArray,
                        [in, out] WORD *pcStreams );

    HRESULT AddStream( [in] WORD wStreamNum );

    HRESULT RemoveStream( [in] WORD wStreamNum );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMutualExclusion Interface"),
    pointer_default(unique),
    local
]
//
// IWMMutualExclusion specifies a group of streams, of which only one can
// be played at once. These are used to do MEB (stream selection based on
// bandwidth).
//
interface IWMMutualExclusion : IWMStreamList
{
    //
    // The possible types of mutual exclusion are defined in the ASF
    // header.
    //
    HRESULT GetType( [out] GUID *pguidType );

    HRESULT SetType( [in] REFGUID guidType );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 0302B57D-89D1-4ba2-85C9-166F2C53EB91 ),
    helpstring( "IWMMutualExclusion2 interface" ),
    pointer_default(unique),
    local
]
//
// IWMMutualExclusion2 extends IWMMutualExclusion to incorporate more advanced
// mutual exclusion concepts.
//
interface IWMMutualExclusion2 : IWMMutualExclusion
{
    //
    // Methods to get and set the name of the mutual exclusion.
    //
    HRESULT GetName( [out, size_is( *pcchName )] WCHAR *pwszName,
                     [in, out] WORD *pcchName );

    HRESULT SetName( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszName );

    //
    // Methods to query and manipulate the records in the object.
    //
    HRESULT GetRecordCount( [out] WORD *pwRecordCount );

    HRESULT AddRecord();

    HRESULT RemoveRecord( [in] WORD wRecordNumber );

    //
    // Methods to get and set the name associated with a record.
    //
    HRESULT GetRecordName( [in] WORD wRecordNumber,
                           [out, size_is( *pcchRecordName )] WCHAR *pwszRecordName,
                           [in, out] WORD *pcchRecordName );

    HRESULT SetRecordName( [in] WORD wRecordNumber,
                           [in] LPCWSTR_WMSDK_TYPE_SAFE pwszRecordName );

    //
    // Methods to get and set the streams in a record.
    //
    HRESULT GetStreamsForRecord( [in] WORD wRecordNumber,
                                 [out, size_is( *pcStreams )] WORD *pwStreamNumArray,
                                 [in, out] WORD *pcStreams );

    HRESULT AddStreamForRecord( [in] WORD wRecordNumber,
                                [in] WORD wStreamNumber );

    HRESULT RemoveStreamForRecord( [in] WORD wRecordNumber,
                                   [in] WORD wStreamNumber );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( AD694AF1-F8D9-42F8-BC47-70311B0C4F9E ),
    helpstring( "IWMBandwidthSharing Interface"),
    pointer_default(unique),
    local
]
//
// IWMBandwidthSharing specifies a group of streams whose combined bitrate
// and buffer size are not to exceed the parameters given to this interface,
// even though the sum of their individual bitrates may be more.
//
interface IWMBandwidthSharing : IWMStreamList
{
    //
    // The possible types of bandwidth are defined in the ASF
    // header.
    //
    HRESULT GetType( [out] GUID *pguidType );

    HRESULT SetType( [in] REFGUID guidType );

    //
    // Methods to get and set properties of the combined streams.
    // Buffer windows are given in milliseconds
    //
    HRESULT GetBandwidth(   [out] DWORD *pdwBitrate,
                            [out] DWORD *pmsBufferWindow );

    HRESULT SetBandwidth(   [in] DWORD dwBitrate,
                            [in] DWORD msBufferWindow );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 8C1C6090-F9A8-4748-8EC3-DD1108BA1E77 ),
    helpstring( "IWMStreamPrioritization Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamPrioritization specifies the author's intentions as to which
// streams should or should not be dropped in response to various network
// congestion situations.
//
interface IWMStreamPrioritization : IUnknown
{
    //
    // Records in a stream prioritization object are given in order of
    // decreasing priority
    //
    HRESULT GetPriorityRecords( [out, size_is( *pcRecords )] WM_STREAM_PRIORITY_RECORD *pRecordArray,
                                [in, out] WORD *pcRecords );

    HRESULT SetPriorityRecords( [in] WM_STREAM_PRIORITY_RECORD *pRecordArray,
                                [in] WORD cRecords );
};

///////////////////////////////////////////////////////////////////////////////
//
// Advanced features.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE3-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced : IUnknown
{
    //
    // Sinks are where the output ASF data goes.
    //
    HRESULT GetSinkCount( [out] DWORD *pcSinks );

    HRESULT GetSink( [in] DWORD dwSinkNum,
                     [out] IWMWriterSink **ppSink );

    HRESULT AddSink( [in] IWMWriterSink *pSink );

    HRESULT RemoveSink( [in] IWMWriterSink *pSink );

    //
    // By default, the user provides samples to an input on the
    // IWMWriter interface, and the samples may be compressed, put
    // into a MEB stream, etc. However, the user can use this interface to
    // put the samples directly into the ASF, with no compression etc.
    //
    HRESULT WriteStreamSample( [in] WORD wStreamNum,
                               [in] QWORD cnsSampleTime,
                               [in] DWORD msSampleSendTime,
                               [in] QWORD cnsSampleDuration,
                               [in] DWORD dwFlags,
                               [in] INSSBuffer *pSample );

    //
    // The writer may be running in real-time. If so, it's interesting to
    // get the current time from the writer.
    //
    HRESULT SetLiveSource( BOOL fIsLiveSource );

    HRESULT IsRealTime( [out] BOOL *pfRealTime );

    HRESULT GetWriterTime( [out] QWORD *pcnsCurrentTime );

    //
    // To get statistics, pass in a WM_WRITER_STATISTICS structure, which
    // will be filled out by the GetStatistics() call with the requested
    // stats.
    //
    // Pass in a stream number to get statistics for a specific stream, or
    // pass 0 to get statistics for the entire ASF file.
    //
    HRESULT GetStatistics( [in] WORD wStreamNum,
                           [out] WM_WRITER_STATISTICS *pStats );

    //
    // Sync tolerance determines how far out of sync the inputs will be allowed
    // to get before samples are thrown away.  Default is 3000 ms.
    //
    HRESULT SetSyncTolerance(   [in]    DWORD   msWindow );
    HRESULT GetSyncTolerance(   [out]   DWORD*  pmsWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 962dc1ec-c046-4db8-9cc7-26ceae500817 ),
    helpstring( "IWMWriterAdvanced2 Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced2 : IWMWriterAdvanced
{
    //
    // Retrieves a setting for a particular output by name
    //
    HRESULT GetInputSetting(
                    [in] DWORD dwInputNum,
                    [in] LPCWSTR pszName,
                    [out] WMT_ATTR_DATATYPE *pType,
                    [out, size_is( *pcbLength )] BYTE *pValue,
                    [in, out] WORD *pcbLength );

    //
    // Sets a named setting for a particular input
    //
    HRESULT SetInputSetting(
                    [in] DWORD dwInputNum,
                    [in] LPCWSTR pszName,
                    [in] WMT_ATTR_DATATYPE Type,
                    [in, size_is( cbLength )] const BYTE *pValue,
                    [in] WORD cbLength );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 2cd6492d-7c37-4e76-9d3b-59261183a22e ),
    helpstring( "IWMWriterAdvanced3 Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced3 : IWMWriterAdvanced2
{
    //
    // To get extended statistics, pass in a WM_WRITER_STATISTICS_EX structure, which
    // will be filled out by the GetStatisticsEx() call with the requested
    // stats.
    //
    // Pass in a stream number to get extended statistics for a specific stream, or
    // pass 0 to get extended statistics for the entire ASF file.
    //
    HRESULT GetStatisticsEx(
                            [in] WORD wStreamNum,
                            [out] WM_WRITER_STATISTICS_EX *pStats );
    //
    // Calling this function tells the writer not block the callers thread.
    //
    HRESULT SetNonBlocking( );

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( fc54a285-38c4-45b5-aa23-85b9f7cb424b ),
    helpstring( "IWMWriterPreprocess Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides multi-pass
// encoding functionality.
//
interface IWMWriterPreprocess : IUnknown
{
    HRESULT GetMaxPreprocessingPasses(
                                [in] DWORD dwInputNum,
                                [in] DWORD dwFlags,
                                [out] DWORD *pdwMaxNumPasses );

    HRESULT SetNumPreprocessingPasses(
                                [in] DWORD dwInputNum,
                                [in] DWORD dwFlags,
                                [in] DWORD dwNumPasses );

    HRESULT BeginPreprocessingPass(
                                [in] DWORD dwInputNum,
                                [in] DWORD dwFlags );

    HRESULT PreprocessSample(
                                [in] DWORD dwInputNum,
                                [in] QWORD cnsSampleTime,
                                [in] DWORD dwFlags,
                                [in] INSSBuffer *pSample );

    HRESULT EndPreprocessingPass(
                                [in] DWORD dwInputNum,
                                [in] DWORD dwFlags );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( D9D6549D-A193-4f24-B308-03123D9B7F8D ),
    helpstring( "IWMWriterPostViewCallback Interface"),
    pointer_default(unique),
    local
]
//
// This is the interface that receives uncompressed samples from the writer
// to preview (well, postview) what the codec is doing.
//
interface IWMWriterPostViewCallback : IWMStatusCallback
{

    //
    // cnsSampleDuration will be 0 for most media types.
    //
    HRESULT OnPostViewSample(   [in] WORD  wStreamNumber,
                                [in] QWORD cnsSampleTime,
                                [in] QWORD cnsSampleDuration,
                                [in] DWORD dwFlags,
                                [in] INSSBuffer *pSample,
                                [in] void *pvContext );

    HRESULT AllocateForPostView([in] WORD wStreamNum,
                                [in] DWORD cbBuffer,
                                [out] INSSBuffer **ppBuffer,
                                [in] void *pvContext );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 81E20CE4-75EF-491a-8004-FC53C45BDC3E ),
    helpstring( "IWMWriterPostView Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterPostView : IUnknown
{
    //
    // Specify the callback to use for PostView
    //
    HRESULT SetPostViewCallback( IWMWriterPostViewCallback*  pCallback, void* pvContext );

    //
    // Turns on delivery of postview samples for a given stream
    //
    HRESULT SetReceivePostViewSamples(  [in] WORD wStreamNum,
                                        [in] BOOL fReceivePostViewSamples );

    HRESULT GetReceivePostViewSamples(  [in] WORD wStreamNum,
                                        [out] BOOL *pfReceivePostViewSamples );

    //
    // The user can enumerate through the various outputs, and get the
    // output format for that data.
    //
    // Manipulating the IWMOutputMediaProps has no effect on the output, unless
    // the user also calls SetOutputProps.
    //
    HRESULT GetPostViewProps(   [in] WORD wStreamNumber,
                                [out] IWMMediaProps **ppOutput );

    HRESULT SetPostViewProps(   [in] WORD wStreamNumber,
                                [in] IWMMediaProps *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader.
    //
    HRESULT GetPostViewFormatCount( [in]  WORD wStreamNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetPostViewFormat(  [in] WORD  wStreamNumber,
                                [in] DWORD dwFormatNumber,
                                [out] IWMMediaProps** ppProps );

    //
    // The user can register himself to provide buffers for any of the outputs
    // (for instance, DDraw buffers). The actual allocation is on the
    // IWMReaderCallbackAdvanced interface.
    //
    HRESULT SetAllocateForPostView( [in] WORD wStreamNumber,
                                    [in] BOOL fAllocate );

    HRESULT GetAllocateForPostView( [in]  WORD wStreamNumber,
                                    [out] BOOL *pfAllocate );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterSink Interface"),
    pointer_default(unique),
    local
]
//
// This is the interface that receives raw ASF from the writer.
//
interface IWMWriterSink : IUnknown
{
    HRESULT OnHeader( [in] INSSBuffer *pHeader );

    //
    // Some sinks require that data be fed to them in real-time.
    //
    HRESULT IsRealTime( [out] BOOL *pfRealTime );

    HRESULT AllocateDataUnit( [in] DWORD cbDataUnit,
                              [out] INSSBuffer **ppDataUnit );

    HRESULT OnDataUnit( [in] INSSBuffer *pDataUnit );

    //
    // This function is called when the writer is done sending data.
    //
    HRESULT OnEndWriting();
};



///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( CF4B1F99-4DE2-4e49-A363-252740D99BC1 ),
    helpstring( "IWMRegisterCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMRegisterCallback : IUnknown
{
    HRESULT Advise( [in]    IWMStatusCallback*  pCallback,
                    [in]    void*               pvContext );

    HRESULT Unadvise( [in]  IWMStatusCallback*  pCallback,
                    [in]    void*               pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterFileSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink : IWMWriterSink
{
    HRESULT Open( [in] const WCHAR *pwszFilename );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 14282BA7-4AEF-4205-8CE5-C229035A05BC ),
    helpstring( "IWMWriterFileSink2 Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink2 : IWMWriterFileSink
{
    HRESULT Start(  [in]    QWORD cnsStartTime );

    HRESULT Stop(   [in]    QWORD cnsStopTime );

    HRESULT IsStopped(       [out] BOOL *pfStopped );

    HRESULT GetFileDuration( [out] QWORD *pcnsDuration );

    HRESULT GetFileSize(     [out] QWORD *pcbFile );

    HRESULT Close();

    HRESULT IsClosed(        [out] BOOL *pfClosed );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 3FEA4FEB-2945-47A7-A1DD-C53A8FC4C45C ),
    helpstring( "IWMWriterFileSink3 Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink3 : IWMWriterFileSink2
{
    HRESULT SetAutoIndexing(    [in]    BOOL fDoAutoIndexing );

    HRESULT GetAutoIndexing(    [out]   BOOL *pfAutoIndexing );

    HRESULT SetControlStream(   [in]    WORD wStreamNumber,
                                [in]    BOOL fShouldControlStartAndStop );

    HRESULT GetMode(            [out]   DWORD *pdwFileSinkMode );

    HRESULT OnDataUnitEx(       [in]    WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit );

    HRESULT SetUnbufferedIO(    [in]    BOOL fUnbufferedIO,
                                [in]    BOOL fRestrictMemUsage );

    HRESULT GetUnbufferedIO(    [out]   BOOL *pfUnbufferedIO );

    HRESULT CompleteOperations( );
}

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterNetworkSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterNetworkSink : IWMWriterSink
{
    //
    // Determine the maximum number of clients that can connect to this sink.
    // Default is 5.
    //
    HRESULT SetMaximumClients( [in] DWORD dwMaxClients );

    HRESULT GetMaximumClients( [out] DWORD *pdwMaxClients );

    //
    // The network protocol that the network sink will use.
    //
    HRESULT SetNetworkProtocol( [in] WMT_NET_PROTOCOL protocol );

    HRESULT GetNetworkProtocol( [out] WMT_NET_PROTOCOL *pProtocol );

    //
    // Find out the name of the URL on which we're broadcasting
    //
    HRESULT GetHostURL( [out] WCHAR *pwszURL,
                        [in, out] DWORD *pcchURL );

    //
    // The method claims the network port number. Close the sink to release
    // the port.
    //
    // Specify 0 for the port number and the sink will select a port for
    // the user.
    //
    HRESULT Open( [in, out] DWORD *pdwPortNum );

    //
    // Disconnect all connected clients.
    //
    HRESULT Disconnect();

    //
    // Close and release the open port.
    //
    HRESULT Close();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 73C66010-A299-41df-B1F0-CCF03B09C1C6 ),
    helpstring( "IWMClientConnections Interface"),
    pointer_default(unique),
    local
]
interface IWMClientConnections : IUnknown
{
    //
    // Determine the number of connected clients
    //
    HRESULT GetClientCount( [out] DWORD* pcClients );

    //
    // Get information about a connected client
    //
    HRESULT GetClientProperties( [in] DWORD dwClientNum,
                                 [out] WM_CLIENT_PROPERTIES *pClientProperties );

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 4091571e-4701-4593-bb3d-d5f5f0c74246 ),
    helpstring( "IWMClientConnections2 Interface"),
    pointer_default(unique),
    local
]
interface IWMClientConnections2 : IWMClientConnections
{
    //
    // Get information about a connected client
    //
    HRESULT GetClientInfo( [in] DWORD dwClientNum,
                           [out, size_is( *pcchNetworkAddress )] WCHAR *pwszNetworkAddress,
                           [in, out] DWORD *pcchNetworkAddress,
                           [out, size_is( *pcchPort )] WCHAR *pwszPort,
                           [in, out] DWORD *pcchPort,
                           [out, size_is( *pcchDNSName )] WCHAR *pwszDNSName,
                           [in, out] DWORD *pcchDNSName
                           );
};



///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The reader can be QI'd for this interface for advanced functionality.
//
interface IWMReaderAdvanced : IUnknown
{
    //
    // The user may want to drive the clock himself, particularly if he wants
    // to source from a file faster-than-realtime. This call may fail if the
    // current source does not support user-driven clocks.
    //
    // The proper way for a user to drive the clock is for the user to call
    // DeliverTime, and then wait for the OnTime call on
    // IWMReaderCallbackAdvanced to reach the time he specified.
    //
    HRESULT SetUserProvidedClock( [in] BOOL fUserClock );

    HRESULT GetUserProvidedClock( [out] BOOL *pfUserClock );

    HRESULT DeliverTime( [in] QWORD cnsTime );

    //
    // The user can select streams manually, instead of relying on the
    // automatic bandwidth stream selection that the reader will
    // normally do. To figure out what streams are in this ASF and what their
    // numbers are, QI for IWMProfile.
    //
    // When SetManualStreamSelection( TRUE ) is called, all streams are
    // selected by default.
    //
    HRESULT SetManualStreamSelection( [in] BOOL fSelection );

    HRESULT GetManualStreamSelection( [out] BOOL *pfSelection );

    HRESULT SetStreamsSelected( [in] WORD cStreamCount,
                                [in] WORD *pwStreamNumbers,
                                [in] WMT_STREAM_SELECTION *pSelections );

    HRESULT GetStreamSelected( [in] WORD wStreamNum,
                               [out] WMT_STREAM_SELECTION *pSelection );

    //
    // The user can also choose to get callbacks when automatic stream
    // selection occurs.
    //
    HRESULT SetReceiveSelectionCallbacks( [in] BOOL fGetCallbacks );

    HRESULT GetReceiveSelectionCallbacks( [out] BOOL *pfGetCallbacks );

    //
    // The user can register himself to receive samples directly from the
    // ASF streams, rather than letting the Reader decompress them. Note that
    // to do this, the IWMReaderCallback (supplied by the user) must support
    // IWMReaderCallbackAdvanced.
    //
    // To get actual information about the contents of a stream, QI the
    // object for IWMProfile.
    //
    HRESULT SetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [in] BOOL fReceiveStreamSamples );

    HRESULT GetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [out] BOOL *pfReceiveStreamSamples );

    //
    // The user can register himself to provide buffers for any of the outputs
    // (for instance, DDraw buffers). The actual allocation is on the
    // IWMReaderCallbackAdvanced interface.
    //
    HRESULT SetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [in] BOOL fAllocate );

    HRESULT GetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [out] BOOL *pfAllocate );

    HRESULT SetAllocateForStream( [in] WORD wStreamNum,
                                  [in] BOOL fAllocate );

    HRESULT GetAllocateForStream( [in] WORD dwSreamNum,
                                  [out] BOOL *pfAllocate );

    //
    // Get statistics on demand
    //
    HRESULT GetStatistics( [in, out] WM_READER_STATISTICS *pStatistics );

    //
    // Set client side information used for logging
    //
    HRESULT SetClientInfo( [in] WM_READER_CLIENTINFO *pClientInfo );

    //
    // Get the maximum required buffer sizes that the SDK will allocate.
    // The first is for output buffers, the second for stream buffers.
    //
    HRESULT GetMaxOutputSampleSize( [in] DWORD dwOutput,
                                    [out] DWORD *pcbMax );

    HRESULT GetMaxStreamSampleSize( [in] WORD wStream,
                                    [out] DWORD *pcbMax );

    //
    // Used to notify the reader that it's delivering data
    // too slowly to the client.  The reader will try to speed
    // up.
    //
    HRESULT NotifyLateDelivery( QWORD cnsLateness );

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( ae14a945-b90c-4d0d-9127-80d665f7d73e ),
    helpstring( "IWMReaderAdvanced2 Interface"),
    pointer_default(unique),
    local
]
//
// The reader can be QI'd for this interface for advanced functionality.
//
interface IWMReaderAdvanced2 : IWMReaderAdvanced
{
    //
    // Set the play mode to WMT_PLAY_MODE_AUTOSELECT to allow the reader
    // to pick the mode. (This is the default). If you select a play mode that
    // is impossible for the requested URL, an error will be returned when
    // the URL is opened.
    //
    HRESULT SetPlayMode( [in] WMT_PLAY_MODE Mode );

    //
    // Get the current play mode.
    //
    HRESULT GetPlayMode( [out] WMT_PLAY_MODE *pMode );

    //
    // Between WMT_BUFFERING_START and WMT_BUFFERING_STOP this call will
    // return progress values. pdwPercent returns the percentage of buffering
    // that has completed, and pcnsBuffering returns the amount of buffering
    // remaining.
    //
    HRESULT GetBufferProgress( [out] DWORD *pdwPercent,
                               [out] QWORD *pcnsBuffering );

    //
    // When the play mode is WMT_PLAY_MODE_DOWNLOAD, this call will return
    // progress values. pdwPercent returns the percentage of the download
    // that has completed, pqwBytesDownloaded returns the number of bytes
    // that have been downloaded, and pcnsDownload returns the amount of
    // downloading remaining.
    //
    HRESULT GetDownloadProgress( [out] DWORD *pdwPercent,
                                 [out] QWORD *pqwBytesDownloaded,
                                 [out] QWORD *pcnsDownload );

    //
    // When saving a file, the operation may take awhile. Between
    // WMT_SAVEAS_START and WMT_SAVEAS_STOP, this call will return progress
    // values. pdwPercent returns the percentage of the save as that has
    // completed.
    //
    HRESULT GetSaveAsProgress( [out] DWORD *pdwPercent );

    //
    // Save the current file. This only works for WMT_PLAY_MODE_DOWNLOAD.
    // This operation is asynchronous; WMT_SAVEAS_STOP indicates that the
    // save has completed. Closing the reader will abort a save operation
    // that has not completed.
    //
    HRESULT SaveFileAs( [in] const WCHAR *pwszFilename );

    //
    // Returns the name of the protocol that is currently being used.
    // The protocol name is a URL scheme, such as "mmsu", "http", "file", etc.
    // Note, however, that the protocol name may differ from the URL scheme
    // that was specified in IWMReader::Open().
    // This method may return an empty string if the protocol name cannot be determined.
    //
    HRESULT GetProtocolName( [out, size_is( *pcchProtocol )] WCHAR *pwszProtocol,
                             [in, out] DWORD *pcchProtocol );

    //
    // Same as IWMReader::Start, but uses a marker index instead of a time value.
    //
    HRESULT StartAtMarker( [in] WORD wMarkerIndex,
                           [in] QWORD cnsDuration,
                           [in] float fRate,
                           [in] void *pvContext );

    //
    // Retrieves a setting for a particular output by name
    //
    HRESULT GetOutputSetting(
                    [in] DWORD dwOutputNum,
                    [in] LPCWSTR pszName,
                    [out] WMT_ATTR_DATATYPE *pType,
                    [out, size_is( *pcbLength )] BYTE *pValue,
                    [in, out] WORD *pcbLength );

    //
    // Sets a named setting for a particular output
    //
    HRESULT SetOutputSetting(
                    [in] DWORD dwOutputNum,
                    [in] LPCWSTR pszName,
                    [in] WMT_ATTR_DATATYPE Type,
                    [in, size_is( cbLength )] const BYTE *pValue,
                    [in] WORD cbLength );

    //
    // Used to begin prerolling the reader.  Call this method
    // when you know you're going to call Start soon and want
    // to start buffering data in advance.  cnsStart, cnsDuration
    // and fRate should be the same as the values you plan to pass
    // to Start in the future.
    //
    HRESULT Preroll(
                [in] QWORD cnsStart,
                [in] QWORD cnsDuration,
                [in] float fRate );

    //
    // Specifies whether the SDK should send the client's unique identifier
    // to the server when streaming.
    //
    HRESULT SetLogClientID( [in] BOOL fLogClientID );

    HRESULT GetLogClientID( [out] BOOL *pfLogClientID );

    //
    // This method requests that the Reader send WMT_BUFFERING_STOP as soon
    // as possible. The Reader will only honor the request if it is currently
    // buffering, i.e., it has sent a WMT_BUFFERING_START, but not yet sent the
    // corresponding WMT_BUFFERING_STOP.
    //
    HRESULT StopBuffering( );

    //
    // Same as IWMReader::Open but takes an IStream interface pointer instead
    // of an URL to be opened
    //
    HRESULT OpenStream( [in] IStream *pStream,
                        [in] IWMReaderCallback *pCallback,
                        [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100 ),
    helpstring( "IWMReaderAdvanced3 Interface" ),
    pointer_default(unique),
    local
]
//
// The reader can be QI'ed for this interface for frame access functionality.
//
interface IWMReaderAdvanced3 : IWMReaderAdvanced2
{
    //
    // This method is used when you want to stop net streaming right away but
    // continue to receive samples that SDK have gotten so far.
    //
    // If it's successful, user should receive an END_OF_STREAMING quickly.
    //
    HRESULT StopNetStreaming( );

    //
    // This method supports extended start functionality. The currently
    // support start formats are:
    //
    // WMT_OFFSET_FORMAT_100NS
    // WMT_OFFSET_FORMAT_FRAME_NUMBERS
    // WMT_OFFSET_FORMAT_PLAYLIST_OFFSET
    // WMT_OFFSET_FORMAT_TIMECODE
    //

    HRESULT StartAtPosition(  [in] WORD              wStreamNum,
                              [in] void              *pvOffsetStart,
                              [in] void              *pvDuration,
                              [in] WMT_OFFSET_FORMAT dwOffsetFormat,
                              [in] float             fRate,
                              [in] void              *pvContext );

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 945A76A2-12AE-4d48-BD3C-CD1D90399B85 ),
    helpstring( "IWMReaderAdvanced4 Interface" ),
    pointer_default(unique),
    local
]
//
// The reader can be QI'ed for this interface for frame access functionality.
//
interface IWMReaderAdvanced4 : IWMReaderAdvanced3
{
    HRESULT GetLanguageCount(
                [in] DWORD dwOutputNum,
                [out] WORD *pwLanguageCount );

    HRESULT GetLanguage(
                [in] DWORD dwOutputNum,
                [in] WORD wLanguage,
                [out, size_is( *pcchLanguageStringLength )] WCHAR *pwszLanguageString,
                [in, out] WORD *pcchLanguageStringLength );

    HRESULT GetMaxSpeedFactor(
                [out] double *pdblFactor );

    HRESULT IsUsingFastCache(
                [out] BOOL  *pfUsingFastCache );

    HRESULT AddLogParam(
                [in] LPCWSTR wszNameSpace,
                [in] LPCWSTR wszName,
                [in] LPCWSTR wszValue );

    HRESULT SendLogParams( );

    //
    // Sets output parameter to TRUE if IWMReaderAdvanced2::SaveFileAs() is
    // can be invoked for the current content.
    //
    HRESULT CanSaveFileAs( [out] BOOL *pfCanSave );

    //
    // Cancels the current FileSaveAs operation
    //
    HRESULT CancelSaveFileAs( );

    //
    // This method returns the URL currently being played.  This URL might be
    // different from the URL passed in to IWMReader::Open, because the Reader
    // may have been redirected to an alternate URL.
    //
    HRESULT GetURL( [out, size_is( *pcchURL )] WCHAR *pwszURL,
                    [in, out] DWORD *pcchURL );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 24C44DB0-55D1-49ae-A5CC-F13815E36363 ),
    helpstring( "IWMReaderAdvanced5 Interface" ),
    pointer_default(unique),
    local
]
//
// Implemeted by FSDK for DXVA support
//
interface IWMReaderAdvanced5 : IWMReaderAdvanced4
{
    HRESULT SetPlayerHook(
                [in] DWORD         dwOutputNum,
                [in] IWMPlayerHook *pHook );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 18A2E7F8-428F-4acd-8A00-E64639BC93DE ),
    helpstring( "IWMReaderAdvanced6 Interface" ),
    pointer_default(unique),
    local
]
//
// The reader can be QI'ed for this interface for sample protection functionality.
//
interface IWMReaderAdvanced6 : IWMReaderAdvanced5
{
    HRESULT SetProtectStreamSamples( [in, size_is( cbCertificate )]  BYTE *pbCertificate,
                                     [in]  DWORD cbCertificate,
                                     [in]  DWORD dwCertificateType,
                                     [in]  DWORD dwFlags,
                                     [out, size_is( *pcbInitializationVector )] BYTE *pbInitializationVector,
                                     [in, out] DWORD *pcbInitializationVector );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( e5b7ca9a-0f1c-4f66-9002-74ec50d8b304 ),
    helpstring( "IWMPlayerHook Interface" ),
    pointer_default(unique),
    local
]
//
// Implemented by the player
//
interface IWMPlayerHook : IUnknown
{
    HRESULT PreDecode();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 9F762FA7-A22E-428d-93C9-AC82F3AAFE5A ),
    helpstring( "IWMReaderAllocatorEx Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderAllocatorEx : IUnknown
{
    HRESULT AllocateForStreamEx( [in] WORD wStreamNum,
                                 [in] DWORD cbBuffer,
                                 [out] INSSBuffer **ppBuffer,
                                 [in] DWORD dwFlags,
                                 [in] QWORD cnsSampleTime,
                                 [in] QWORD cnsSampleDuration,
                                 [in] void *pvContext );

    HRESULT AllocateForOutputEx( [in] DWORD dwOutputNum,
                                 [in] DWORD cbBuffer,
                                 [out] INSSBuffer **ppBuffer,
                                 [in] DWORD dwFlags,
                                 [in] QWORD cnsSampleTime,
                                 [in] QWORD cnsSampleDuration,
                                 [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( FDBE5592-81A1-41ea-93BD-735CAD1ADC05 ),
    helpstring( "IWMReaderTypeNegotiation Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderTypeNegotiation : IUnknown
{
    HRESULT TryOutputProps( [in] DWORD dwOutputNum,
                            [in] IWMOutputMediaProps *pOutput );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallbackAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// For some advanced functionality, the IWMReaderCallback must support this
// interface.
//
interface IWMReaderCallbackAdvanced : IUnknown
{
    //
    // Receive a sample directly from the ASF. To get this call, the user
    // must register himself to receive samples for a particular stream.
    //
    HRESULT OnStreamSample( [in] WORD wStreamNum,
                            [in] QWORD cnsSampleTime,
                            [in] QWORD cnsSampleDuration,
                            [in] DWORD dwFlags,
                            [in] INSSBuffer *pSample,
                            [in] void *pvContext );

    //
    // In some cases, the user may want to get callbacks telling what the
    // reader thinks the current time is. This is interesting in 2 cases:
    // - If the ASF has gaps in it; say no audio for 10 seconds. This call
    //   will continue to be called, while OnSample won't be called.
    // - If the user is driving the clock, the reader needs to communicate
    //   back to the user its time, to avoid the user overrunning the reader.
    //
    HRESULT OnTime( [in] QWORD cnsCurrentTime,
                    [in] void *pvContext );

    //
    // The user can also get callbacks when stream selection occurs.
    //
    HRESULT OnStreamSelection( [in] WORD wStreamCount,
                               [in] WORD *pStreamNumbers,
                               [in] WMT_STREAM_SELECTION *pSelections,
                               [in] void *pvContext );


    //
    // Will be called if the user got an async result from their
    // call to SetOutputProps.  The next sample you receive for
    // this output will have these properties.  The contents of the
    // media type after calling SetOutputProps and before receiving
    // an OutputPropsChanged notification are undefined.
    //
    HRESULT OnOutputPropsChanged( [in] DWORD dwOutputNum,
                                  [in] WM_MEDIA_TYPE *pMediaType,
                                  [in] void *pvContext );

    //
    // If the user has registered to allocate buffers, this is where he must
    // do it.
    //
    HRESULT AllocateForStream( [in] WORD wStreamNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );

    HRESULT AllocateForOutput( [in] DWORD dwOutputNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( D2827540-3EE7-432c-B14C-DC17F085D3B3 ),
    helpstring( "IWMDRMReader Interface"),
    pointer_default(unique),
    local
]
//
// Used to access advanced DRM functionality.
//
interface IWMDRMReader : IUnknown
{
    HRESULT AcquireLicense( [in]    DWORD   dwFlags );
    HRESULT CancelLicenseAcquisition();

    HRESULT Individualize( [in]     DWORD   dwFlags );
    HRESULT CancelIndividualization();

    HRESULT MonitorLicenseAcquisition();
    HRESULT CancelMonitorLicenseAcquisition();

    HRESULT SetDRMProperty( [in]    LPCWSTR pwstrName,
                            [in]    WMT_ATTR_DATATYPE dwType,
                            [in, size_is( cbLength )]    const BYTE *pValue,
                            [in]    WORD cbLength );
    HRESULT GetDRMProperty( [in]    LPCWSTR pwstrName,
                            [out]   WMT_ATTR_DATATYPE* pdwType,
                            [out, size_is( *pcbLength )]   BYTE *pValue,
                            [in, out]   WORD *pcbLength );
};

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "#ifndef DRM_OPL_TYPES" )
cpp_quote( "#define DRM_OPL_TYPES 1")

typedef struct __tagDRM_MINIMUM_OUTPUT_PROTECTION_LEVELS
{
    WORD wCompressedDigitalVideo;
    WORD wUncompressedDigitalVideo;
    WORD wAnalogVideo;
    WORD wCompressedDigitalAudio;
    WORD wUncompressedDigitalAudio;
} DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS;

typedef struct __tagDRM_OPL_OUTPUT_IDS
{
    WORD  cIds;
    GUID  *rgIds;

} DRM_OPL_OUTPUT_IDS;

typedef struct __tagDRM_OUTPUT_PROTECTION
{
    GUID guidId;
    BYTE bConfigData;
} DRM_OUTPUT_PROTECTION;

typedef DRM_OUTPUT_PROTECTION DRM_VIDEO_OUTPUT_PROTECTION;

typedef struct __tagDRM_VIDEO_OUTPUT_PROTECTION_IDS
{
    WORD cEntries;
    DRM_VIDEO_OUTPUT_PROTECTION *rgVop;
} DRM_VIDEO_OUTPUT_PROTECTION_IDS;

typedef struct __tagDRM_PLAY_OPL
{
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS minOPL;
    DRM_OPL_OUTPUT_IDS                   oplIdReserved;
    DRM_VIDEO_OUTPUT_PROTECTION_IDS      vopi;
} DRM_PLAY_OPL;

typedef struct __tagDRM_COPY_OPL
{
    WORD           wMinimumCopyLevel;
    DRM_OPL_OUTPUT_IDS oplIdIncludes;
    DRM_OPL_OUTPUT_IDS oplIdExcludes;
} DRM_COPY_OPL;

cpp_quote( "#endif // DRM_OPL_TYPES" )

[
    object,
    uuid( befe7a75-9f1d-4075-b9d9-a3c37bda49a0 ),
    helpstring( "IWMDRMReader2 Interface"),
    pointer_default(unique),
    local
]
//
// Used to access advanced DRM functionality.
//
interface IWMDRMReader2 : IWMDRMReader
{
    HRESULT SetEvaluateOutputLevelLicenses( [in] BOOL fEvaluate );
    HRESULT GetPlayOutputLevels(
        [out, size_is( *pcbLength )] DRM_PLAY_OPL *pPlayOPL,
        [in, out] DWORD *pcbLength,
        [out] DWORD *pdwMinAppComplianceLevel );
    HRESULT GetCopyOutputLevels(
        [out, size_is( *pcbLength )] DRM_COPY_OPL *pCopyOPL,
        [in, out] DWORD *pcbLength,
        [out] DWORD *pdwMinAppComplianceLevel );
    HRESULT TryNextLicense();
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( e08672de-f1e7-4ff4-a0a3-fc4b08e4caf8 ),
    helpstring( "IWMDRMReader3 Interface"),
    pointer_default(unique),
    local
]
//
// Used to access advanced DRM functionality.
//
interface IWMDRMReader3 : IWMDRMReader2
{
    //
    //  An array of GUIDs will be allocated and returned to the caller.  This should be freed with CoTaskMemFree.
    //
    HRESULT GetInclusionList( [out] GUID **ppGuids, [out] DWORD *pcGuids );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( f28c0300-9baa-4477-a846-1744d9cbf533 ),
    helpstring( "IWMReaderPlaylistBurn Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderPlaylistBurn : IUnknown
{
    HRESULT InitPlaylistBurn( [in] DWORD cFiles,
                              [in] LPCWSTR_WMSDK_TYPE_SAFE *ppwszFilenames,
                              [in] IWMStatusCallback *pCallback,
                              [in] void *pvContext );
    HRESULT GetInitResults( [in] DWORD cFiles,
                            [out] HRESULT *phrStati );
    HRESULT Cancel();
    HRESULT EndPlaylistBurn( [in] HRESULT hrBurnResult );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( 96406BEC-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderNetworkConfig Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderNetworkConfig : IUnknown
{
    //
    // Get and set the amount of time the network source will buffer
    // data before rendering it.
    //
    HRESULT GetBufferingTime( [out] QWORD *pcnsBufferingTime );

    HRESULT SetBufferingTime( [in] QWORD cnsBufferingTime );

    //
    // Returns the UDP port number ranges that will be used for receiving
    // data.  If no ranges are available, random UDP port numbers will be used.
    //
    HRESULT GetUDPPortRanges( [out, size_is( *pcRanges )] WM_PORT_NUMBER_RANGE *pRangeArray,
                              [in, out] DWORD *pcRanges );

    //
    // Sets the UDP port number ranges that can be used for receiving data.
    // If no ranges are specified, random UDP port numbers will be used.
    //
    HRESULT SetUDPPortRanges( [in, size_is( cRanges )] WM_PORT_NUMBER_RANGE *pRangeArray,
                              [in] DWORD cRanges );


    //
    // Proxy settings: Manual proxy, Autodetect, UseBrowser (only for HTTP), or No Proxy.
    //
    HRESULT GetProxySettings( [in] LPCWSTR pwszProtocol,
                              [out] WMT_PROXY_SETTINGS *pProxySetting );

    HRESULT SetProxySettings( [in] LPCWSTR pwszProtocol,
                              [in] WMT_PROXY_SETTINGS ProxySetting );

    //
    // The host to use as the proxy.
    //
    HRESULT GetProxyHostName( [in] LPCWSTR pwszProtocol,
                              [out, size_is( *pcchHostName )] WCHAR *pwszHostName,
                              [in, out] DWORD *pcchHostName );

    HRESULT SetProxyHostName( [in] LPCWSTR pwszProtocol,
                              [in] LPCWSTR pwszHostName );

    //
    // The port to use as the proxy.
    //
    HRESULT GetProxyPort( [in] LPCWSTR pwszProtocol,
                          [out] DWORD *pdwPort );

    HRESULT SetProxyPort( [in] LPCWSTR pwszProtocol,
                          [in] DWORD dwPort );

    //
    // Get and set the proxy exception list.
    //
    HRESULT GetProxyExceptionList( [in] LPCWSTR pwszProtocol,
                                   [out, size_is( *pcchExceptionList )] WCHAR *pwszExceptionList,
                                   [in, out] DWORD *pcchExceptionList );

    HRESULT SetProxyExceptionList( [in] LPCWSTR pwszProtocol,
                                   [in] LPCWSTR pwszExceptionList );

    //
    // Whether or not to bypass proxy for local hosts
    //
    HRESULT GetProxyBypassForLocal( [in] LPCWSTR pwszProtocol,
                                    [out] BOOL *pfBypassForLocal );

    HRESULT SetProxyBypassForLocal( [in] LPCWSTR pwszProtocol,
                                    [in] BOOL fBypassForLocal );

    //
    // Whether to force a wpad discovery on the next run
    //
    HRESULT GetForceRerunAutoProxyDetection( [out] BOOL *pfForceRerunDetection );

    HRESULT SetForceRerunAutoProxyDetection( [in] BOOL fForceRerunDetection );

    //
    // Whether or not to use multicast, http, tcp, or udp
    //
    HRESULT GetEnableMulticast( [out] BOOL *pfEnableMulticast );

    HRESULT SetEnableMulticast( [in] BOOL fEnableMulticast );

    HRESULT GetEnableHTTP( [out] BOOL *pfEnableHTTP );

    HRESULT SetEnableHTTP( [in] BOOL fEnableHTTP );

    HRESULT GetEnableUDP( [out] BOOL *pfEnableUDP );

    HRESULT SetEnableUDP( [in] BOOL fEnableUDP );

    HRESULT GetEnableTCP( [out] BOOL *pfEnableTCP );

    HRESULT SetEnableTCP( [in] BOOL fEnableTCP );

    //
    // Forgets automatic protocol detection settings and redetects next time.
    //
    HRESULT ResetProtocolRollover( );

    //
    // Return or set the client's link bandwidth in bps.  This is an optional
    // setting.  By default, the SDK will automatically detect its connection
    // bandwidth to the streaming media server.
    //
    HRESULT GetConnectionBandwidth( [out] DWORD *pdwConnectionBandwidth );

    HRESULT SetConnectionBandwidth( [in] DWORD dwConnectionBandwidth );

    //
    // Iterate through the network protocols supported by this reader
    //
    HRESULT GetNumProtocolsSupported( [out] DWORD *pcProtocols );

    HRESULT GetSupportedProtocolName( [in]  DWORD dwProtocolNum,
                                      [out, size_is( *pcchProtocolName )] WCHAR *pwszProtocolName,
                                      [in, out] DWORD *pcchProtocolName);


    //
    // Adds the specified pszUrl to the list of URL's to recieve logging data.
    // This list is in addition to the origin server.
    //
    HRESULT AddLoggingUrl( [in] LPCWSTR pwszUrl );

    //
    // Fills the buffer with the URL corresponding to index dwIndex.
    //
    HRESULT GetLoggingUrl( [in] DWORD dwIndex,
                           [out, size_is( *pcchUrl )] LPWSTR pwszUrl,
                           [in, out] DWORD *pcchUrl );

    //
    // Returns the number of URLs in the current list of logging URLs.
    //
    HRESULT GetLoggingUrlCount( [out] DWORD *pdwUrlCount );

    //
    // Clears the list of logging URLs
    //
    HRESULT ResetLoggingUrlList( );

}

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( d979a853-042b-4050-8387-c939db22013f ),
    helpstring( "IWMReaderNetworkConfig2 Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderNetworkConfig2 : IWMReaderNetworkConfig
{
    //
    // If enabled, allows streaming content (WMT_PLAY_MODE_STREAMING)
    // to be cached locally.
    //
    HRESULT GetEnableContentCaching( [out] BOOL *pfEnableContentCaching );

    HRESULT SetEnableContentCaching( [in] BOOL fEnableContentCaching );

    //
    // If enabled, allows streaming content to be streamed at a rate higher
    // than the playback rate.  This feature requires ContentCaching to be
    // enabled as well.
    //
    HRESULT GetEnableFastCache( [out] BOOL *pfEnableFastCache );

    HRESULT SetEnableFastCache( [in] BOOL fEnableFastCache );

    HRESULT GetAcceleratedStreamingDuration( [out] QWORD *pcnsAccelDuration );

    HRESULT SetAcceleratedStreamingDuration( [in] QWORD cnsAccelDuration );

    HRESULT GetAutoReconnectLimit( [out] DWORD *pdwAutoReconnectLimit );

    HRESULT SetAutoReconnectLimit( [in] DWORD dwAutoReconnectLimit );

    HRESULT GetEnableResends( [out] BOOL *pfEnableResends );

    HRESULT SetEnableResends( [in] BOOL fEnableResends );

    HRESULT GetEnableThinning( [out] BOOL *pfEnableThinning );

    HRESULT SetEnableThinning( [in] BOOL fEnableThinning );

    HRESULT GetMaxNetPacketSize( [out] DWORD *pdwMaxNetPacketSize );
}

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BED-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderStreamClock Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderStreamClock : IUnknown
{
    //
    // Get the current value of the stream clock
    //
    HRESULT GetTime( [in] QWORD *pcnsNow );

    //
    // Timer methods: All timers are automatically
    // killed whenever you stop the Reader.  When a timer
    // expires, you'll receive a WMT_TIMER OnStatus callback
    // with hr == S_OK, pValue = TimerId and pvContext == pvParam.
    //
    //
    HRESULT SetTimer( [in] QWORD cnsWhen,
                      [in] void *pvParam,
                      [out] DWORD *pdwTimerId );

    HRESULT KillTimer( [in] DWORD dwTimerId );
}


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc71-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMIndexer Interface"),
    pointer_default(unique),
    local
]
interface IWMIndexer : IUnknown
{
    //
    // Start is an asynchronous call; it returns almost immediately and the user
    // should wait for appropriate OnStatus calls to be sent to the callback.
    //
    HRESULT StartIndexing( [in] const WCHAR *pwszURL,
                           [in] IWMStatusCallback *pCallback,
                           [in] void *pvContext );

    HRESULT Cancel();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( B70F1E42-6255-4df0-A6B9-02B212D9E2BB ),
    helpstring( "IWMIndexer2 Interface"),
    pointer_default(unique),
    local
]
interface IWMIndexer2 : IWMIndexer
{
    HRESULT Configure( [in] WORD wStreamNum,
                       [in] WMT_INDEXER_TYPE nIndexerType,
                       [in] void *pvInterval,
                       [in] void *pvIndexType );
}


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8 ),
    helpstring( "IWMLicenseBackup Interface"),
    pointer_default(unique),
    local
]
interface IWMLicenseBackup : IUnknown
{

    HRESULT BackupLicenses( [in] DWORD dwFlags,
                            [in] IWMStatusCallback *pCallback );

    HRESULT CancelLicenseBackup();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( C70B6334-A22E-4efb-A245-15E65A004A13 ),
    helpstring( "IWMLicenseRestore Interface"),
    pointer_default(unique),
    local
]
interface IWMLicenseRestore : IUnknown
{
    HRESULT RestoreLicenses( [in] DWORD dwFlags,
                             [in] IWMStatusCallback *pCallback );

    HRESULT CancelLicenseRestore();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E ),
    helpstring( "IWMBackupRestoreProps Interface"),
    pointer_default(unique),
    local
]
interface IWMBackupRestoreProps : IUnknown
{
    HRESULT GetPropCount( [out] WORD *pcProps );

    HRESULT GetPropByIndex( [in] WORD wIndex,
                       [out, size_is( *pcchNameLen )] WCHAR *pwszName,
                       [in, out] WORD *pcchNameLen,
                       [out] WMT_ATTR_DATATYPE *pType,
                       [out, size_is( *pcbLength )] BYTE *pValue,
                       [in, out] WORD *pcbLength );

    HRESULT GetPropByName( [in] LPCWSTR pszName,
                           [out] WMT_ATTR_DATATYPE *pType,
                           [out, size_is( *pcbLength )] BYTE *pValue,
                           [in, out] WORD *pcbLength );

    HRESULT SetProp( [in] LPCWSTR pszName,
                     [in] WMT_ATTR_DATATYPE Type,
                     [in, size_is( cbLength )] const BYTE *pValue,
                     [in] WORD cbLength );

    HRESULT RemoveProp( [in] LPCWSTR pcwszName );

    HRESULT RemoveAllProps();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( A970F41E-34DE-4a98-B3BA-E4B3CA7528F0 ),
    helpstring( "IWMCodecInfo Interface"),
    pointer_default(unique),
    local
]
interface IWMCodecInfo : IUnknown
{
    HRESULT GetCodecInfoCount(   [in]      REFGUID guidType,
                                 [out]     DWORD *pcCodecs );

    HRESULT GetCodecFormatCount( [in]      REFGUID guidType,
                                 [in]      DWORD dwCodecIndex,
                                 [out]     DWORD *pcFormat );

    HRESULT GetCodecFormat(      [in]      REFGUID guidType,
                                 [in]      DWORD dwCodecIndex,
                                 [in]      DWORD dwFormatIndex,
                                 [out]     IWMStreamConfig **ppIStreamConfig );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( AA65E273-B686-4056-91EC-DD768D4DF710 ),
    helpstring( "IWMCodecInfo2 Interface"),
    pointer_default(unique),
    local
]
interface IWMCodecInfo2 : IWMCodecInfo
{
    HRESULT GetCodecName( [in]  REFGUID guidType,
                          [in]  DWORD dwCodecIndex,
                          [out, size_is( *pcchName )] WCHAR *wszName,
                          [in, out] DWORD *pcchName );

    HRESULT GetCodecFormatDesc( [in]       REFGUID guidType,
                                [in]       DWORD dwCodecIndex,
                                [in]       DWORD dwFormatIndex,
                                [out]      IWMStreamConfig **ppIStreamConfig,
                                [out, size_is( *pcchDesc )]      WCHAR *wszDesc,
                                [in, out]  DWORD *pcchDesc );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 7e51f487-4d93-4f98-8ab4-27d0565adc51 ),
    helpstring( "IWMCodecInfo3 Interface"),
    pointer_default(unique),
    local
]
interface IWMCodecInfo3 : IWMCodecInfo2
{
    HRESULT GetCodecFormatProp( [in]       REFGUID guidType,
                                [in]       DWORD dwCodecIndex,
                                [in]       DWORD dwFormatIndex,
                                [in]       LPCWSTR pszName,
                                [out]      WMT_ATTR_DATATYPE *pType,
                                [out, size_is( *pdwSize )]      BYTE *pValue,
                                [in, out]   DWORD *pdwSize );

    HRESULT GetCodecProp(   [in]       REFGUID guidType,
                            [in]       DWORD dwCodecIndex,
                            [in]       LPCWSTR pszName,
                            [out]      WMT_ATTR_DATATYPE *pType,
                            [out, size_is( *pdwSize )]      BYTE *pValue,
                            [in, out]   DWORD *pdwSize );

    HRESULT SetCodecEnumerationSetting( [in]    REFGUID guidType,
                                        [in]    DWORD dwCodecIndex,
                                        [in]    LPCWSTR pszName,
                                        [in]    WMT_ATTR_DATATYPE Type,
                                        [in, size_is( dwSize )]    const BYTE *pValue,
                                        [in]    DWORD dwSize );

    HRESULT GetCodecEnumerationSetting( [in]    REFGUID guidType,
                                        [in]    DWORD dwCodecIndex,
                                        [in]    LPCWSTR pszName,
                                        [out]   WMT_ATTR_DATATYPE *pType,
                                        [out, size_is( *pdwSize )]   BYTE *pValue,
                                        [in,out]DWORD *pdwSize );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( DF683F00-2D49-4d8e-92B7-FB19F6A0DC57 ),
    helpstring( "IWMLanguageList Interface"),
    pointer_default(unique),
    local
]
interface IWMLanguageList : IUnknown
{
    HRESULT GetLanguageCount( [out] WORD *pwCount );

    HRESULT GetLanguageDetails( [in] WORD wIndex,
                                [out, size_is( *pcchLanguageStringLength )] WCHAR *pwszLanguageString,
                                [in, out] WORD *pcchLanguageStringLength );

    HRESULT AddLanguageByRFC1766String( [in] LPCWSTR_WMSDK_TYPE_SAFE pwszLanguageString,
                                        [out] WORD *pwIndex );
};



///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( dc10e6a5-072c-467d-bf57-6330a9dde12a ),
    helpstring( "IWMWriterPushSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterPushSink : IWMWriterSink
{
    //
    // Connect to a publishing point on the server.
    // If the publishing point does not exist, and pwszTemplateURL is
    // non-NULL, an attempt will be made to create a new publishing point based
    // on the template URL.
    //
    HRESULT Connect(
        [in] LPCWSTR pwszURL,
        [in] LPCWSTR pwszTemplateURL,              // may be NULL
        [in] BOOL fAutoDestroy
        );

    //
    // Terminate the control connection with the downstream server. The data path on the
    // downstream server remains active for 5 minutes after which it is cleaned up.
    //
    HRESULT Disconnect( );

    //
    // Gracefully end the push distribution session. This shuts down the data path on
    // the server for the publishing point.
    //
    HRESULT EndSession();

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( f6211f03-8d21-4e94-93e6-8510805f2d99 ),
    helpstring( "IWMDeviceRegistration Interface"),
    pointer_default(unique),
    local
]
interface IWMDeviceRegistration : IUnknown
{
    HRESULT RegisterDevice(
            [in] DWORD dwRegisterType,
            [in, size_is(cbCertificate)] BYTE *pbCertificate,
            [in] DWORD cbCertificate,
            [in] DRM_VAL16 SerialNumber,
            [out] IWMRegisteredDevice **ppDevice
            );

    HRESULT UnregisterDevice(
            [in] DWORD dwRegisterType,
            [in, size_is(cbCertificate)] BYTE *pbCertificate,
            [in] DWORD cbCertificate,
            [in] DRM_VAL16 SerialNumber
            );

    HRESULT GetRegistrationStats(
            [in] DWORD dwRegisterType,
            [out] DWORD *pcRegisteredDevices
            );

    HRESULT GetFirstRegisteredDevice(
            [in] DWORD dwRegisterType,
            [out] IWMRegisteredDevice **ppDevice
            );

    HRESULT GetNextRegisteredDevice(
            [out] IWMRegisteredDevice **ppDevice
            );

    HRESULT GetRegisteredDeviceByID(
            [in] DWORD dwRegisterType,
            [in, size_is(cbCertificate)] BYTE *pbCertificate,
            [in] DWORD cbCertificate,
            [in] DRM_VAL16 SerialNumber,
            [out] IWMRegisteredDevice **ppDevice
            );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( a4503bec-5508-4148-97ac-bfa75760a70d ),
    helpstring( "IWMRegisteredDevice Interface"),
    pointer_default(unique),
    local
]
interface IWMRegisteredDevice : IUnknown
{
    HRESULT GetDeviceSerialNumber(
            [out] DRM_VAL16 *pSerialNumber
            );

    HRESULT GetDeviceCertificate(
            [out] INSSBuffer **ppCertificate
            );

    HRESULT GetDeviceType(
            [out] DWORD *pdwType
            );

    HRESULT GetAttributeCount(
            [out] DWORD *pcAttributes
            );

    HRESULT GetAttributeByIndex(
            [in] DWORD dwIndex,
            [out] BSTR *pbstrName,
            [out] BSTR *pbstrValue
            );

    HRESULT GetAttributeByName(
            [in] BSTR bstrName,
            [out] BSTR *pbstrValue
            );

    HRESULT SetAttributeByName(
            [in] BSTR bstrName,
            [in] BSTR bstrValue
            );

    HRESULT Approve(
            [in] BOOL fApprove
            );

    HRESULT IsValid(
            [out] BOOL *pfValid
            );

    HRESULT IsApproved(
            [out] BOOL *pfApproved
            );

    HRESULT IsWmdrmCompliant(
            [out] BOOL *pfCompliant
            );

    HRESULT IsOpened(
            [out] BOOL *pfOpened
            );

    HRESULT Open();

    HRESULT Close();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6A9FD8EE-B651-4bf0-B849-7D4ECE79A2B1 ),
    helpstring( "IWMProximityDetection Interface"),
    pointer_default(unique),
    local
]
interface IWMProximityDetection : IUnknown
{
    //
    // Generates a WMT_PROXIMITY_COMPLETED callback with a status code
    // indicating success or failure of the proximity detection.
    //
    HRESULT StartDetection(
            [in, size_is(cbRegistrationMsg)] BYTE *pbRegistrationMsg,
            [in] DWORD cbRegistrationMsg,
            [in, size_is(cbLocalAddress)] BYTE *pbLocalAddress,
            [in] DWORD cbLocalAddress,
            [in] DWORD dwExtraPortsAllowed,
            [out] INSSBuffer **ppRegistrationResponseMsg,
            [in] IWMStatusCallback *pCallback,
            [in] void *pvContext
            );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( A73A0072-25A0-4c99-B4A5-EDE8101A6C39 ),
    helpstring( "IWMDRMMessageParser Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMMessageParser : IUnknown
{
    //
    // This method parses the Registration Request message and returns
    // the Device Cert and Id.
    //
    HRESULT ParseRegistrationReqMsg(
            [in, size_is(cbRegistrationReqMsg)] BYTE *pbRegistrationReqMsg,
            [in] DWORD cbRegistrationReqMsg,
            [out] INSSBuffer **ppDeviceCert,
            [out] DRM_VAL16 *pDeviceSerialNumber
            );

    //
    // This method parses the License Request message and returns
    // the Device Certificate, Device Id and action
    //
    HRESULT ParseLicenseRequestMsg(
            [in, size_is(pbLicenseRequestMsg)] BYTE *pbLicenseRequestMsg,
            [in] DWORD cbLicenseRequestMsg,
            [out] INSSBuffer **ppDeviceCert,
            [out] DRM_VAL16 *pDeviceSerialNumber,
            [out] BSTR *pbstrAction
            );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 69059850-6E6F-4bb2-806F-71863DDFC471 ),
    helpstring( "IWMDRMTranscryptor Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMTranscryptor : IUnknown
{
    //
    // Generates a WMT_TRANSCRYPTOR_INIT callback with a status code
    // indicating success.
    //
    HRESULT Initialize(
            [in] BSTR bstrFileName,
            [in, size_is(cbLicenseRequestMsg) ] BYTE *pbLicenseRequestMsg,
            [in] DWORD cbLicenseRequestMsg,
            [out] INSSBuffer **ppLicenseResponseMsg,
            [in] IWMStatusCallback *pCallback,
            [in] void *pvContext
            );

    //
    // Generates a WMT_TRANSCRYPTOR_SEEKED callback with a status code
    // indicating success.
    //
    HRESULT Seek(
            [in] QWORD hnsTime
            );

    //
    // Generates a WMT_TRANSCRYPTOR_READ callback with a status code
    // indicating success. The pbData buffer isn't filled in until this
    // callback is fired.
    //
    // The special success code NS_S_TRANSCRYPTOR_EOF indicates that the
    // entire file has been read.
    //
    HRESULT Read(
            [in] BYTE *pbData,
            [in] DWORD *pcbData
            );
    //
    // Generates a WMT_TRANSCRYPTOR_CLOSED callback.
    //
    HRESULT Close();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( e0da439f-d331-496a-bece-18e5bac5dd23 ),
    helpstring( "IWMDRMTranscryptor2 Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMTranscryptor2 : IWMDRMTranscryptor
{
    //
    // cnsStartTime : Time to seek to, in hundreds of nanoseconds.
    // cnsDuration : Maximum duration of the transcrypted content. Set this parameter to 0 for no limit.
    // flRate: Transcrypted content to be encoded for playback at this rate.  This parameter should be set to 1 for
    //         normal playback.  An error will be returned if flRate is set to an unsupported rate.
    // fIncludeFileHeader: If TRUE, the first Read() call will include the ASF File Header.
    //
    // This function call generates a WMT_TRANSCRYPTOR_SEEKED callback with a status code
    // indicating success.
    //
    HRESULT SeekEx(
            [in] QWORD cnsStartTime,
            [in] QWORD cnsDuration,
            [in] float flRate,
            [in] BOOL fIncludeFileHeader
            );

    //
    // fEnable: If TRUE, the timestamps in the ASF packets returned after Seek() or SeekEx() will start
    // at zero.  This is the default behavior.  If the parameter is FALSE, the timestamps in the ASF packets
    // will reflect the real seek position.
    //
    HRESULT ZeroAdjustTimestamps( [in] BOOL fEnable );

    //
    // Returns the actual time that the transcryptor seeked to in result to a call to Seek() or SeekEx().  
    // The actual start time may differ from the start time specified in Seek() or SeekEx().
    // The actual start time is not available until after the first WMT_TRANSCRYPTOR_READ callback 
    // has been delivered.  If GetSeekStartTime() is invoked prior to that, it will return the 
    // start time specified in the call to Seek() or SeekEx().
    //
    HRESULT GetSeekStartTime( [out] QWORD *pcnsTime );

    //
    // Returns the total duration of the content
    //
    HRESULT GetDuration( [out] QWORD *pcnsDuration );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( b1a887b2-a4f0-407a-b02e-efbd23bbecdf ),
    helpstring( "IWMDRMTranscryptionManager Interface"),
    pointer_default(unique),
    local
]
interface IWMDRMTranscryptionManager : IUnknown
{
    //
    // IWMDRMTranscryptionManager provides an alternative way to create the
    // transcryptor objects. When this approach is used, the transcryptor
    // objects are optimized for faster turnaround times in initializing the
    // transcryption. This results in lower open latencies while using these
    // transcryptor objects.
    //
    HRESULT CreateTranscryptor(
                [out] IWMDRMTranscryptor **ppTranscryptor
                );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6f497062-f2e2-4624-8ea7-9dd40d81fc8d ),
    helpstring( "IWMWatermarkInfo Interface"),
    pointer_default(unique),
    local
]

//
// The writer can be QI'd for this interface to enumerate all of the
// watermark DMOs installed on a system.
//

interface IWMWatermarkInfo : IUnknown
{
    HRESULT GetWatermarkEntryCount(
                [in] WMT_WATERMARK_ENTRY_TYPE wmetType,
                [out] DWORD* pdwCount
                );

    HRESULT GetWatermarkEntry(
                [in] WMT_WATERMARK_ENTRY_TYPE wmetType,
                [in] DWORD dwEntryNum,
                [out] WMT_WATERMARK_ENTRY* pEntry
                );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( BDDC4D08-944D-4d52-A612-46C3FDA07DD4 ),
    helpstring( "IWMReaderAccelerator Interface" ),
    pointer_default( unique ),
    local
]

//
// The Reader can be QI'ed for this interface for DirectX-VA support
//
interface IWMReaderAccelerator : IUnknown
{
    HRESULT GetCodecInterface( [in]             DWORD  dwOutputNum,
                               [in]             REFIID riid,
                               [out] void     **ppvCodecInterface );

    HRESULT Notify( [in]  DWORD             dwOutputNum,
                    [in]  WM_MEDIA_TYPE    *pSubtype );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( f369e2f0-e081-4fe6-8450-b810b2f410d1 ),
    helpstring( "IWMReaderTimecode Interface" ),
    pointer_default(unique),
    local
]
interface IWMReaderTimecode : IUnknown
{
    //
    // Get the number of ranges of timecode data for a given stream in the file.
    // Returns 0 if there is no timecode index for the specified stream.
    //
    HRESULT GetTimecodeRangeCount( [in] WORD wStreamNum,
                                   [out] WORD *pwRangeCount );

    //
    // Gets the first and last timecode available for a given range.
    //
    HRESULT GetTimecodeRangeBounds( [in] WORD wStreamNum,
                                    [in] WORD wRangeNum,
                                    [out] DWORD *pStartTimecode,
                                    [out] DWORD *pEndTimecode );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( BB3C6389-1633-4e92-AF14-9F3173BA39D0 ),
    helpstring( "IWMAddressAccess Interface"),
    pointer_default(unique),
    local
]
interface IWMAddressAccess : IUnknown
{
    //
    // Determine the number of access list entries (by type)
    //
    HRESULT GetAccessEntryCount( [in] WM_AETYPE aeType,
                                 [out] DWORD *pcEntries );

    //
    // Retrieve a single address access entry (by type)
    //
    HRESULT GetAccessEntry( [in] WM_AETYPE aeType,
                            [in] DWORD dwEntryNum,
                            [out] WM_ADDRESS_ACCESSENTRY *pAddrAccessEntry );

    //
    // Add a single address access entry
    //
    HRESULT AddAccessEntry( [in] WM_AETYPE aeType,
                            [in] WM_ADDRESS_ACCESSENTRY *pAddrAccessEntry );

    //
    // Remove a single address access entry (by type)
    //
    HRESULT RemoveAccessEntry( [in] WM_AETYPE aeType,
                               [in] DWORD dwEntryNum );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 65a83fc2-3e98-4d4d-81b5-2a742886b33d ),
    helpstring( "IWMAddressAccess2 Interface" ),
    pointer_default(unique),
    local
]
interface IWMAddressAccess2 : IWMAddressAccess
{
    //
    // Retrieve a single address access entry (by type)
    //
    HRESULT GetAccessEntryEx( [in] WM_AETYPE aeType,
                              [in] DWORD dwEntryNum,
                              [out] BSTR *pbstrAddress,
                              [out] BSTR *pbstrMask );

    //
    // Add a single address access entry
    //
    HRESULT AddAccessEntryEx( [in] WM_AETYPE aeType,
                              [in] BSTR bstrAddress,
                              [in] BSTR bstrMask );

};
///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 9F0AA3B6-7267-4d89-88F2-BA915AA5C4C6 ),
    helpstring( "IWMImageInfo Interface"),
    pointer_default(unique),
    local
]
//
// Used to get "APIC" ID3v2 frames
//
interface IWMImageInfo : IUnknown
{
    HRESULT GetImageCount(  [out] DWORD* pcImages);

    HRESULT GetImage(       [in] DWORD wIndex,
                            [in, out] WORD* pcchMIMEType,
                            [out, size_is( *pcchMIMEType )] WCHAR* pwszMIMEType,
                            [in, out] WORD* pcchDescription,
                            [out, size_is( *pcchDescription )] WCHAR* pwszDescription,
                            [out] WORD* pImageType,
                            [in, out] DWORD* pcbImageData,
                            [out, size_is( *pcbImageData )] BYTE* pbImageData );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6967F2C9-4E26-4b57-8894-799880F7AC7B),
    helpstring( "IWMLicenseRevocationAgent Interface"),
    pointer_default(unique),
    local
]
interface IWMLicenseRevocationAgent : IUnknown
{

    HRESULT GetLRBChallenge(  [in] BYTE *pMachineID,
                                [in] DWORD dwMachineIDLength,
                                [in] BYTE *pChallenge,
                                [in] DWORD dwChallengeLength,
                                [out] BYTE *pChallengeOutput,
                                [out] DWORD *pdwChallengeOutputLength );

    HRESULT ProcessLRB(  [in] BYTE *pSignedLRB,
                           [in] DWORD dwSignedLRBLength,
                           [out] BYTE *pSignedACK,
                           [out] DWORD *pdwSignedACKLength );

};


///////////////////////////////////////////////////////////////////////////////


cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
#pragma endregion

